<html>
<head>
<link rel="stylesheet" href="style.css" />
</head>
<body>
<div class="highlight"><pre><span></span><span class="c1"># The core janet library</span>
<span class="c1"># Copyright 2023 Â© Calvin Rose</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Macros and Basic Functions</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="k">def </span><span class="nb">defn </span><span class="no">:macro</span>
<span class="w">  </span><span class="s">```</span>
<span class="s">  (defn name &amp; more)</span>

<span class="s">  Define a function. Equivalent to `(def name (fn name [args] ...))`.</span>
<span class="s">  ```</span>
<span class="w">  </span><span class="p">(</span><span class="k">fn </span><span class="nb">defn </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">more</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">more</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">modifiers</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">docstr</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">fstart</span>
<span class="w">      </span><span class="p">(</span><span class="k">fn </span><span class="nv">recur</span><span class="w"> </span><span class="p">[</span><span class="nv">i</span><span class="p">]</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="p">{</span><span class="nv">i</span><span class="w"> </span><span class="nv">ith</span><span class="p">}</span><span class="w"> </span><span class="nv">more</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">t</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">ith</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:tuple</span><span class="p">)</span>
<span class="w">          </span><span class="nv">i</span>
<span class="w">          </span><span class="p">(</span><span class="nv">do</span>
<span class="w">            </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:string</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="k">set </span><span class="nv">docstr</span><span class="w"> </span><span class="nv">ith</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">modifiers</span><span class="w"> </span><span class="nv">ith</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)))))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">start</span><span class="w"> </span><span class="p">(</span><span class="nv">fstart</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">more</span><span class="w"> </span><span class="nv">start</span><span class="p">))</span>
<span class="w">    </span><span class="c1"># Add function signature to docstring</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">index</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">arglen</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">args</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">buf</span><span class="w"> </span><span class="p">(</span><span class="nb">buffer </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">index</span><span class="w"> </span><span class="nv">arglen</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">buffer/push-string </span><span class="nv">buf</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">buffer/format </span><span class="nv">buf</span><span class="w"> </span><span class="s">&quot;%j&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">args</span><span class="w"> </span><span class="nv">index</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">index</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">index</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">modifiers</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="nv">buf</span><span class="w"> </span><span class="s">&quot;)\n\n&quot;</span><span class="w"> </span><span class="nv">docstr</span><span class="p">))</span>
<span class="w">    </span><span class="c1"># Build return value</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">name</span><span class="w"> </span><span class="o">,;</span><span class="nv">modifiers</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="o">,</span><span class="nv">name</span><span class="w"> </span><span class="o">,;</span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">more</span><span class="w"> </span><span class="nv">start</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defn defmacro </span><span class="no">:macro</span>
<span class="w">  </span><span class="s">&quot;Define a macro.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">more</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">name</span><span class="w"> </span><span class="p">@{})</span><span class="w"> </span><span class="c1"># override old macro definitions in the case of a recursive macro</span>
<span class="w">  </span><span class="p">(</span><span class="nb">apply defn </span><span class="nv">name</span><span class="w"> </span><span class="no">:macro</span><span class="w"> </span><span class="nv">more</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">as-macro</span>
<span class="w">  </span><span class="s">``Use a function or macro literal `f` as a macro. This lets</span>
<span class="s">  any function be used as a macro. Inside a quasiquote, the</span>
<span class="s">  idiom `(as-macro ,my-custom-macro arg1 arg2...)` can be used</span>
<span class="s">  to avoid unwanted variable capture of `my-custom-macro`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">defmacro-</span>
<span class="w">  </span><span class="s">&quot;Define a private macro that will not be exported.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">more</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">apply defn </span><span class="nv">name</span><span class="w"> </span><span class="no">:macro</span><span class="w"> </span><span class="no">:private</span><span class="w"> </span><span class="nv">more</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">defn-</span>
<span class="w">  </span><span class="s">&quot;Define a private function that will not be exported.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">more</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">apply defn </span><span class="nv">name</span><span class="w"> </span><span class="no">:private</span><span class="w"> </span><span class="nv">more</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">def-</span>
<span class="w">  </span><span class="s">&quot;Define a private value that will not be exported.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">more</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">name</span><span class="w"> </span><span class="no">:private</span><span class="w"> </span><span class="o">,;</span><span class="nv">more</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">var-</span>
<span class="w">  </span><span class="s">&quot;Define a private var that will not be exported.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">more</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">var </span><span class="o">,</span><span class="nv">name</span><span class="w"> </span><span class="no">:private</span><span class="w"> </span><span class="o">,;</span><span class="nv">more</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">toggle</span>
<span class="w">  </span><span class="s">&quot;Set a value to its boolean inverse. Same as `(set value (not value))`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">value</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">value</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">not </span><span class="o">,</span><span class="nv">value</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">defglobal</span>
<span class="w">  </span><span class="s">&quot;Dynamically create a global def.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">value</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">name*</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol </span><span class="nv">name</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">name*</span><span class="w"> </span><span class="p">@{</span><span class="no">:value</span><span class="w"> </span><span class="nv">value</span><span class="p">})</span>
<span class="w">  </span><span class="kc">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">varglobal</span>
<span class="w">  </span><span class="s">&quot;Dynamically create a global var.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">init</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">name*</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol </span><span class="nv">name</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">name*</span><span class="w"> </span><span class="p">@{</span><span class="no">:ref</span><span class="w"> </span><span class="p">@[</span><span class="nv">init</span><span class="p">]})</span>
<span class="w">  </span><span class="kc">nil</span><span class="p">)</span>

<span class="c1"># Basic predicates</span>
<span class="p">(</span><span class="nb">defn nan? </span><span class="s">&quot;Check if x is NaN.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">not= </span><span class="nv">x</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn number? </span><span class="s">&quot;Check if x is a number.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:number</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn fiber? </span><span class="s">&quot;Check if x is a fiber.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:fiber</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn string? </span><span class="s">&quot;Check if x is a string.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:string</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn symbol? </span><span class="s">&quot;Check if x is a symbol.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:symbol</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn keyword? </span><span class="s">&quot;Check if x is a keyword.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:keyword</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn buffer? </span><span class="s">&quot;Check if x is a buffer.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:buffer</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn function? </span><span class="s">&quot;Check if x is a function (not a cfunction).&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:function</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn cfunction? </span><span class="s">&quot;Check if x a cfunction.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:cfunction</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn table? </span><span class="s">&quot;Check if x a table.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:table</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn struct? </span><span class="s">&quot;Check if x a struct.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:struct</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn array? </span><span class="s">&quot;Check if x is an array.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:array</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn tuple? </span><span class="s">&quot;Check if x is a tuple.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:tuple</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn boolean? </span><span class="s">&quot;Check if x is a boolean.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:boolean</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn truthy? </span><span class="s">&quot;Check if x is truthy.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">x</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="kc">false</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn </span><span class="kc">true</span><span class="nv">?</span><span class="w"> </span><span class="s">&quot;Check if x is true.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn </span><span class="kc">false</span><span class="nv">?</span><span class="w"> </span><span class="s">&quot;Check if x is false.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span><span class="w"> </span><span class="kc">false</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn </span><span class="kc">nil</span><span class="nv">?</span><span class="w"> </span><span class="s">&quot;Check if x is nil.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn empty? </span><span class="s">&quot;Check if xs is empty.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">xs</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">xs</span><span class="w"> </span><span class="kc">nil</span><span class="p">)))</span>

<span class="c1"># For macros, we define an imcomplete odd? function that will be overriden.</span>
<span class="p">(</span><span class="nb">defn odd? </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="mf">1</span><span class="w"> </span><span class="p">(</span><span class="nb">mod </span><span class="nv">x</span><span class="w"> </span><span class="mf">2</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">def- </span><span class="nv">non-atomic-types</span>
<span class="w">  </span><span class="p">{</span><span class="no">:array</span><span class="w"> </span><span class="kc">true</span>
<span class="w">   </span><span class="no">:tuple</span><span class="w"> </span><span class="kc">true</span>
<span class="w">   </span><span class="no">:table</span><span class="w"> </span><span class="kc">true</span>
<span class="w">   </span><span class="no">:buffer</span><span class="w"> </span><span class="kc">true</span>
<span class="w">   </span><span class="no">:symbol</span><span class="w"> </span><span class="kc">true</span>
<span class="w">   </span><span class="no">:struct</span><span class="w"> </span><span class="kc">true</span><span class="p">})</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">idempotent?</span>
<span class="w">  </span><span class="s">&quot;Check if x is a value that evaluates to itself when compiled.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">in </span><span class="nv">non-atomic-types</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">))))</span>

<span class="c1"># C style macros and functions for imperative sugar. No bitwise though.</span>
<span class="p">(</span><span class="nb">defn inc </span><span class="s">&quot;Returns x + 1.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">x</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn dec </span><span class="s">&quot;Returns x - 1.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="nv">x</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defmacro ++ </span><span class="s">&quot;Increments the var x by 1.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">+ </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="mf">1</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">defmacro -- </span><span class="s">&quot;Decrements the var x by 1.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">- </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="mf">1</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">defmacro += </span><span class="s">&quot;Increments the var x by n.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">ns</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">+ </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,;</span><span class="nv">ns</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">defmacro -= </span><span class="s">&quot;Decrements the var x by n.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">ns</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">- </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,;</span><span class="nv">ns</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">defmacro *= </span><span class="s">&quot;Shorthand for (set x (\\* x n)).&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">ns</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">* </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,;</span><span class="nv">ns</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">defmacro /= </span><span class="s">&quot;Shorthand for (set x (/ x n)).&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">ns</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">/ </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,;</span><span class="nv">ns</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">defmacro %= </span><span class="s">&quot;Shorthand for (set x (% x n)).&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">ns</span><span class="p">]</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">% </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,;</span><span class="nv">ns</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">assert</span>
<span class="w">  </span><span class="s">&quot;Throw an error if x is not truthy. Will not evaluate `err` if x is truthy.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">err</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">v</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">v</span><span class="w"> </span><span class="o">,</span><span class="nv">x</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">v</span>
<span class="w">       </span><span class="o">,</span><span class="nv">v</span>
<span class="w">       </span><span class="p">(</span><span class="o">,</span><span class="nb">error </span><span class="o">,</span><span class="p">(</span><span class="k">if </span><span class="nv">err</span><span class="w"> </span><span class="nv">err</span><span class="w"> </span><span class="p">(</span><span class="nb">string/format </span><span class="s">&quot;assert failure in %j&quot;</span><span class="w"> </span><span class="nv">x</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">errorf</span>
<span class="w">  </span><span class="s">&quot;A combination of `error` and `string/format`. Equivalent to `(error (string/format fmt ;args))`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">fmt</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string/format </span><span class="nv">fmt</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">default</span>
<span class="w">  </span><span class="s">``Define a default value for an optional argument.</span>
<span class="s">  Expands to `(def sym (if (= nil sym) val sym))`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">sym</span><span class="w"> </span><span class="nv">val</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">sym</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="o">,</span><span class="nv">sym</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">val</span><span class="w"> </span><span class="o">,</span><span class="nv">sym</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">comment</span>
<span class="w">  </span><span class="s">&quot;Ignores the body of the comment.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">])</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">if-not</span>
<span class="w">  </span><span class="s">&quot;Shorthand for `(if (not condition) else then)`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">condition</span><span class="w"> </span><span class="nv">then</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">else</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">condition</span><span class="w"> </span><span class="o">,</span><span class="nv">else</span><span class="w"> </span><span class="o">,</span><span class="nv">then</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">when</span>
<span class="w">  </span><span class="s">&quot;Evaluates the body when the condition is true. Otherwise returns nil.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">condition</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">condition</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">unless</span>
<span class="w">  </span><span class="s">&quot;Shorthand for `(when (not condition) ;body)`. &quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">condition</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">condition</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">cond</span>
<span class="w">  </span><span class="s">`Evaluates conditions sequentially until the first true condition</span>
<span class="s">  is found, and then executes the corresponding body. If there are an</span>
<span class="s">  odd number of forms, and no forms are matched, the last expression</span>
<span class="s">  is executed. If there are no matches, returns nil.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">pairs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">aux</span><span class="w"> </span><span class="p">[</span><span class="nv">i</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">restlen</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">pairs</span><span class="p">)</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">restlen</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">restlen</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">in pairs </span><span class="nv">i</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">if </span><span class="p">(</span><span class="nb">in pairs </span><span class="nv">i</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="nb">in pairs </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nv">aux</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">))))))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">aux</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">case</span>
<span class="w">  </span><span class="s">``Select the body that equals the dispatch value. When `pairs`</span>
<span class="s">  has an odd number of elements, the last is the default expression.</span>
<span class="s">  If no match is found, returns nil.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">dispatch</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">pairs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">atm</span><span class="w"> </span><span class="p">(</span><span class="nb">idempotent? </span><span class="nv">dispatch</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">sym</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">atm</span><span class="w"> </span><span class="nv">dispatch</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">aux</span><span class="w"> </span><span class="p">[</span><span class="nv">i</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">restlen</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">pairs</span><span class="p">)</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">restlen</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">restlen</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">in pairs </span><span class="nv">i</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">if </span><span class="p">(</span><span class="nb">tuple = </span><span class="nv">sym</span><span class="w"> </span><span class="p">(</span><span class="nb">in pairs </span><span class="nv">i</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nb">in pairs </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nv">aux</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">))))))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="nv">atm</span>
<span class="w">    </span><span class="p">(</span><span class="nv">aux</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="nv">do</span>
<span class="w">           </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">def </span><span class="nv">sym</span><span class="w"> </span><span class="nv">dispatch</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nv">aux</span><span class="w"> </span><span class="mf">0</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">let</span>
<span class="w">  </span><span class="s">``Create a scope and bind values to symbols. Each pair in `bindings` is</span>
<span class="s">  assigned as if with `def`, and the body of the `let` form returns the last</span>
<span class="s">  value.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">bindings</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">odd? </span><span class="p">(</span><span class="nb">length </span><span class="nv">bindings</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">error </span><span class="s">&quot;expected even number of bindings to let&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">bindings</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">accum</span><span class="w"> </span><span class="p">@[</span><span class="o">&#39;</span><span class="nv">do</span><span class="p">])</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="p">{</span><span class="nv">i</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nv">v</span><span class="p">}</span><span class="w"> </span><span class="nv">bindings</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">accum</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">def </span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+= </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">array/concat </span><span class="nv">accum</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">accum</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">try</span>
<span class="w">  </span><span class="s">``Try something and catch errors. `body` is any expression,</span>
<span class="s">  and `catch` should be a form, the first element of which is a tuple. This tuple</span>
<span class="s">  should contain a binding for errors and an optional binding for</span>
<span class="s">  the fiber wrapping the body. Returns the result of `body` if no error,</span>
<span class="s">  or the result of `catch` if an error.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">body</span><span class="w"> </span><span class="nv">catch</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">let </span><span class="p">[[[</span><span class="nv">err</span><span class="w"> </span><span class="nv">fib</span><span class="p">]]</span><span class="w"> </span><span class="nv">catch</span>
<span class="w">        </span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)</span>
<span class="w">        </span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/new </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="o">,</span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="no">:ie</span><span class="p">)</span>
<span class="w">           </span><span class="o">,</span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">resume </span><span class="o">,</span><span class="nv">f</span><span class="p">)]</span>
<span class="w">       </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="o">,</span><span class="nb">= </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/status </span><span class="o">,</span><span class="nv">f</span><span class="p">)</span><span class="w"> </span><span class="no">:error</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">err</span><span class="w"> </span><span class="o">,</span><span class="nv">r</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="k">if </span><span class="nv">fib</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">fib</span><span class="w"> </span><span class="o">,</span><span class="nv">f</span><span class="p">))</span><span class="w"> </span><span class="o">,;</span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">catch</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">         </span><span class="o">,</span><span class="nv">r</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">protect</span>
<span class="w">  </span><span class="s">`Evaluate expressions, while capturing any errors. Evaluates to a tuple</span>
<span class="s">  of two elements. The first element is true if successful, false if an</span>
<span class="s">  error, and the second is the return value or error.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/new </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="no">:ie</span><span class="p">)</span>
<span class="w">           </span><span class="o">,</span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">resume </span><span class="o">,</span><span class="nv">f</span><span class="p">)]</span>
<span class="w">       </span><span class="p">[(</span><span class="o">,</span><span class="nb">not= </span><span class="no">:error</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/status </span><span class="o">,</span><span class="nv">f</span><span class="p">))</span><span class="w"> </span><span class="o">,</span><span class="nv">r</span><span class="p">])))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">and</span>
<span class="w">  </span><span class="s">`Evaluates to the last argument if all preceding elements are truthy, otherwise</span>
<span class="s">  evaluates to the first falsey argument.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">forms</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">ret</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">forms</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">i</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">-- </span><span class="nv">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">v</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">forms</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="nv">len</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">               </span><span class="nv">v</span>
<span class="w">               </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">idempotent? </span><span class="nv">v</span><span class="p">)</span>
<span class="w">                 </span><span class="p">[</span><span class="o">&#39;</span><span class="k">if </span><span class="nv">v</span><span class="w"> </span><span class="nv">ret</span><span class="w"> </span><span class="nv">v</span><span class="p">]</span>
<span class="w">                 </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">                   </span><span class="p">[</span><span class="o">&#39;</span><span class="k">if </span><span class="p">[</span><span class="o">&#39;</span><span class="k">def </span><span class="nv">s</span><span class="w"> </span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="nv">ret</span><span class="w"> </span><span class="nv">s</span><span class="p">])))))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">or</span>
<span class="w">  </span><span class="s">`Evaluates to the last argument if all preceding elements are falsey, otherwise</span>
<span class="s">  evaluates to the first truthy element.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">forms</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">forms</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="nv">len</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">forms</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">-- </span><span class="nv">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">fi</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">forms</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">idempotent? </span><span class="nv">fi</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">if </span><span class="nv">fi</span><span class="w"> </span><span class="nv">fi</span><span class="w"> </span><span class="nv">ret</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="nv">do</span>
<span class="w">                 </span><span class="p">(</span><span class="k">def </span><span class="nv">$fi</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">do </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">def </span><span class="nv">$fi</span><span class="w"> </span><span class="nv">fi</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">if </span><span class="nv">$fi</span><span class="w"> </span><span class="nv">$fi</span><span class="w"> </span><span class="nv">ret</span><span class="p">))))))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">with-syms</span>
<span class="w">  </span><span class="s">&quot;Evaluates `body` with each symbol in `syms` bound to a generated, unique symbol.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">syms</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">syms</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">accum</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">accum</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">syms</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="nv">gensym</span><span class="p">])</span>
<span class="w">    </span><span class="p">(</span><span class="nb">++ </span><span class="nv">i</span><span class="p">))</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nb">let </span><span class="p">(</span><span class="o">,;</span><span class="nv">accum</span><span class="p">)</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">defer</span>
<span class="w">  </span><span class="s">``Run `form` unconditionally after `body`, even if the body throws an error.</span>
<span class="s">  Will also run `form` if a user signal 0-4 is received.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">form</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">r</span><span class="p">]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/new </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="no">:ti</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">resume </span><span class="o">,</span><span class="nv">f</span><span class="p">))</span>
<span class="w">       </span><span class="o">,</span><span class="nv">form</span>
<span class="w">       </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/status </span><span class="o">,</span><span class="nv">f</span><span class="p">)</span><span class="w"> </span><span class="no">:dead</span><span class="p">)</span>
<span class="w">         </span><span class="o">,</span><span class="nv">r</span>
<span class="w">         </span><span class="p">(</span><span class="o">,</span><span class="nb">propagate </span><span class="o">,</span><span class="nv">r</span><span class="w"> </span><span class="o">,</span><span class="nv">f</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">edefer</span>
<span class="w">  </span><span class="s">``Run `form` after `body` in the case that body terminates abnormally (an error or user signal 0-4).</span>
<span class="s">  Otherwise, return last form in `body`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">form</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">r</span><span class="p">]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/new </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="no">:ti</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">resume </span><span class="o">,</span><span class="nv">f</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/status </span><span class="o">,</span><span class="nv">f</span><span class="p">)</span><span class="w"> </span><span class="no">:dead</span><span class="p">)</span>
<span class="w">         </span><span class="o">,</span><span class="nv">r</span>
<span class="w">         </span><span class="p">(</span><span class="k">do </span><span class="o">,</span><span class="nv">form</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">propagate </span><span class="o">,</span><span class="nv">r</span><span class="w"> </span><span class="o">,</span><span class="nv">f</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">prompt</span>
<span class="w">  </span><span class="s">``Set up a checkpoint that can be returned to. `tag` should be a value</span>
<span class="s">  that is used in a `return` statement, like a keyword.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">tag</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">res</span><span class="w"> </span><span class="nv">target</span><span class="w"> </span><span class="nv">payload</span><span class="w"> </span><span class="nv">fib</span><span class="p">]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">fib</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/new </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="p">[</span><span class="o">,</span><span class="nv">tag</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">body</span><span class="p">)])</span><span class="w"> </span><span class="no">:i0</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">resume </span><span class="o">,</span><span class="nv">fib</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="o">,</span><span class="nv">target</span><span class="w"> </span><span class="o">,</span><span class="nv">payload</span><span class="p">]</span><span class="w"> </span><span class="o">,</span><span class="nv">res</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="o">,</span><span class="nb">= </span><span class="o">,</span><span class="nv">tag</span><span class="w"> </span><span class="o">,</span><span class="nv">target</span><span class="p">)</span>
<span class="w">         </span><span class="o">,</span><span class="nv">payload</span>
<span class="w">         </span><span class="p">(</span><span class="o">,</span><span class="nb">propagate </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="o">,</span><span class="nv">fib</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">chr</span>
<span class="w">  </span><span class="s">`Convert a string of length 1 to its byte (ascii) value at compile time.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">c</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">unless </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">string? </span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string/format </span><span class="s">&quot;expected string of length 1, got %v&quot;</span><span class="w"> </span><span class="nv">c</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">c</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">label</span>
<span class="w">  </span><span class="s">``Set a label point that is lexically scoped. `name` should be a symbol</span>
<span class="s">  that will be bound to the label.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">name</span><span class="w"> </span><span class="s">@&quot;&quot;</span><span class="p">)</span>
<span class="w">     </span><span class="o">,</span><span class="p">(</span><span class="nb">apply prompt </span><span class="nv">name</span><span class="w"> </span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">return</span>
<span class="w">  </span><span class="s">&quot;Return to a prompt point.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">to</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">value</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">signal </span><span class="mf">0</span><span class="w"> </span><span class="p">[</span><span class="nv">to</span><span class="w"> </span><span class="nv">value</span><span class="p">]))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">with</span>
<span class="w">  </span><span class="s">``Evaluate `body` with some resource, which will be automatically cleaned up</span>
<span class="s">  if there is an error in `body`. `binding` is bound to the expression `ctor`, and</span>
<span class="s">  `dtor` is a function or callable that is passed the binding. If no destructor</span>
<span class="s">  (`dtor`) is given, will call :close on the resource.``</span>
<span class="w">  </span><span class="p">[[</span><span class="nv">binding</span><span class="w"> </span><span class="nv">ctor</span><span class="w"> </span><span class="nv">dtor</span><span class="p">]</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">binding</span><span class="w"> </span><span class="o">,</span><span class="nv">ctor</span><span class="p">)</span>
<span class="w">     </span><span class="o">,</span><span class="p">(</span><span class="nb">apply defer </span><span class="p">[(</span><span class="nb">or </span><span class="nv">dtor</span><span class="w"> </span><span class="no">:close</span><span class="p">)</span><span class="w"> </span><span class="nv">binding</span><span class="p">]</span><span class="w"> </span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">when-with</span>
<span class="w">  </span><span class="s">``Similar to with, but if binding is false or nil, returns</span>
<span class="s">  nil without evaluating the body. Otherwise, the same as `with`.``</span>
<span class="w">  </span><span class="p">[[</span><span class="nv">binding</span><span class="w"> </span><span class="nv">ctor</span><span class="w"> </span><span class="nv">dtor</span><span class="p">]</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="o">,</span><span class="nv">binding</span><span class="w"> </span><span class="o">,</span><span class="nv">ctor</span><span class="p">]</span>
<span class="w">     </span><span class="o">,</span><span class="p">(</span><span class="nb">apply defer </span><span class="p">[(</span><span class="nb">or </span><span class="nv">dtor</span><span class="w"> </span><span class="no">:close</span><span class="p">)</span><span class="w"> </span><span class="nv">binding</span><span class="p">]</span><span class="w"> </span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">if-with</span>
<span class="w">  </span><span class="s">``Similar to `with`, but if binding is false or nil, evaluates</span>
<span class="s">  the falsey path. Otherwise, evaluates the truthy path. In both cases,</span>
<span class="s">  `ctor` is bound to binding.``</span>
<span class="w">  </span><span class="p">[[</span><span class="nv">binding</span><span class="w"> </span><span class="nv">ctor</span><span class="w"> </span><span class="nv">dtor</span><span class="p">]</span><span class="w"> </span><span class="nv">truthy</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="kc">false</span><span class="nv">y</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="o">,</span><span class="nv">binding</span><span class="w"> </span><span class="o">,</span><span class="nv">ctor</span><span class="p">]</span>
<span class="w">     </span><span class="o">,</span><span class="p">(</span><span class="nb">apply defer </span><span class="p">[(</span><span class="nb">or </span><span class="nv">dtor</span><span class="w"> </span><span class="no">:close</span><span class="p">)</span><span class="w"> </span><span class="nv">binding</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="nv">truthy</span><span class="p">])</span>
<span class="w">     </span><span class="o">,</span><span class="kc">false</span><span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">for-var-template</span>
<span class="w">  </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">stop</span><span class="w"> </span><span class="nv">step</span><span class="w"> </span><span class="nv">comparison</span><span class="w"> </span><span class="nv">delta</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">s</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">st</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">idempotent? </span><span class="nv">step</span><span class="p">)</span><span class="w"> </span><span class="nv">step</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">loop-body</span>
<span class="w">      </span><span class="o">~</span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="o">,</span><span class="nv">comparison</span><span class="w"> </span><span class="o">,</span><span class="nv">i</span><span class="w"> </span><span class="o">,</span><span class="nv">s</span><span class="p">)</span>
<span class="w">         </span><span class="o">,;</span><span class="nv">body</span>
<span class="w">         </span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nv">delta</span><span class="w"> </span><span class="o">,</span><span class="nv">i</span><span class="w"> </span><span class="o">,</span><span class="nv">st</span><span class="p">))))</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">       </span><span class="p">(</span><span class="k">var </span><span class="o">,</span><span class="nv">i</span><span class="w"> </span><span class="o">,</span><span class="nv">start</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">s</span><span class="w"> </span><span class="o">,</span><span class="nv">stop</span><span class="p">)</span>
<span class="w">       </span><span class="o">,;</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">st</span><span class="w"> </span><span class="nv">step</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">st</span><span class="w"> </span><span class="o">,</span><span class="nv">step</span><span class="p">)])</span>
<span class="w">       </span><span class="o">,</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">number? </span><span class="nv">st</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">st</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">          </span><span class="nv">loop-body</span>
<span class="w">          </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="o">,</span><span class="nb">&gt; </span><span class="o">,</span><span class="nv">st</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">loop-body</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">for-template</span>
<span class="w">  </span><span class="p">[</span><span class="nv">binding</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">stop</span><span class="w"> </span><span class="nv">step</span><span class="w"> </span><span class="nv">comparison</span><span class="w"> </span><span class="nv">delta</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">for-var-template</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">stop</span><span class="w"> </span><span class="nv">step</span><span class="w"> </span><span class="nv">comparison</span><span class="w"> </span><span class="nv">delta</span>
<span class="w">                    </span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">binding</span><span class="w"> </span><span class="o">,</span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="o">;</span><span class="nv">body</span><span class="p">]))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">check-indexed</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">indexed? </span><span class="nv">x</span><span class="p">)</span>
<span class="w">    </span><span class="nv">x</span>
<span class="w">    </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;expected tuple for range, got &quot;</span><span class="w"> </span><span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">range-template</span>
<span class="w">  </span><span class="p">[</span><span class="nv">binding</span><span class="w"> </span><span class="nv">object</span><span class="w"> </span><span class="nv">kind</span><span class="w"> </span><span class="nv">rest</span><span class="w"> </span><span class="nv">op</span><span class="w"> </span><span class="nv">comparison</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">let </span><span class="p">[[</span><span class="nv">start</span><span class="w"> </span><span class="nv">stop</span><span class="w"> </span><span class="nv">step</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">check-indexed</span><span class="w"> </span><span class="nv">object</span><span class="p">)]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">case </span><span class="nv">kind</span>
<span class="w">      </span><span class="no">:range</span><span class="w"> </span><span class="p">(</span><span class="nv">for-template</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">stop</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">stop</span><span class="w"> </span><span class="nv">start</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">step</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nv">comparison</span><span class="w"> </span><span class="nv">op</span><span class="w"> </span><span class="p">[</span><span class="nv">rest</span><span class="p">])</span>
<span class="w">      </span><span class="no">:down</span><span class="w"> </span><span class="p">(</span><span class="nv">for-template</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">stop</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">step</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nv">comparison</span><span class="w"> </span><span class="nv">op</span><span class="w"> </span><span class="p">[</span><span class="nv">rest</span><span class="p">]))))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">each-template</span>
<span class="w">  </span><span class="p">[</span><span class="nv">binding</span><span class="w"> </span><span class="nv">inx</span><span class="w"> </span><span class="nv">kind</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">k</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">ds</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">idempotent? </span><span class="nv">inx</span><span class="p">)</span><span class="w"> </span><span class="nv">inx</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)))</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">       </span><span class="o">,</span><span class="p">(</span><span class="nb">unless </span><span class="p">(</span><span class="nb">= </span><span class="nv">ds</span><span class="w"> </span><span class="nv">inx</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">ds</span><span class="w"> </span><span class="o">,</span><span class="nv">inx</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">var </span><span class="o">,</span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">next </span><span class="o">,</span><span class="nv">ds</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="o">,</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="o">,</span><span class="nv">k</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">binding</span>
<span class="w">           </span><span class="o">,</span><span class="p">(</span><span class="nb">case </span><span class="nv">kind</span>
<span class="w">              </span><span class="no">:each</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="o">,</span><span class="nb">in </span><span class="o">,</span><span class="nv">ds</span><span class="w"> </span><span class="o">,</span><span class="nv">k</span><span class="p">)</span>
<span class="w">              </span><span class="no">:keys</span><span class="w"> </span><span class="nv">k</span>
<span class="w">              </span><span class="no">:pairs</span><span class="w"> </span><span class="o">~</span><span class="p">[</span><span class="o">,</span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">in </span><span class="o">,</span><span class="nv">ds</span><span class="w"> </span><span class="o">,</span><span class="nv">k</span><span class="p">)]))</span>
<span class="w">         </span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">next </span><span class="o">,</span><span class="nv">ds</span><span class="w"> </span><span class="o">,</span><span class="nv">k</span><span class="p">))</span>
<span class="w">         </span><span class="o">,;</span><span class="nv">body</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">iterate-template</span>
<span class="w">  </span><span class="p">[</span><span class="nv">binding</span><span class="w"> </span><span class="nv">expr</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">i</span><span class="p">]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">       </span><span class="p">(</span><span class="k">var </span><span class="o">,</span><span class="nv">i</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">i</span><span class="w"> </span><span class="o">,</span><span class="nv">expr</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">binding</span><span class="w"> </span><span class="o">,</span><span class="nv">i</span><span class="p">)</span>
<span class="w">         </span><span class="o">,</span><span class="nv">body</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">loop1</span>
<span class="w">  </span><span class="p">[</span><span class="nv">body</span><span class="w"> </span><span class="nv">head</span><span class="w"> </span><span class="nv">i</span><span class="p">]</span>

<span class="w">  </span><span class="c1"># Terminate recursion</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">length </span><span class="nv">head</span><span class="p">)</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">break </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">body</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="p">{</span><span class="nv">i</span><span class="w"> </span><span class="nv">binding</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nv">verb</span><span class="p">}</span><span class="w"> </span><span class="nv">head</span><span class="p">)</span>

<span class="w">  </span><span class="c1"># 2 term expression</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">keyword? </span><span class="nv">binding</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">break</span>
<span class="w">      </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">rest</span><span class="w"> </span><span class="p">(</span><span class="nv">loop1</span><span class="w"> </span><span class="nv">body</span><span class="w"> </span><span class="nv">head</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">))]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">case </span><span class="nv">binding</span>
<span class="w">          </span><span class="no">:until</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">verb</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">rest</span><span class="p">)</span>
<span class="w">          </span><span class="no">:while</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">verb</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span><span class="w"> </span><span class="o">,</span><span class="nv">rest</span><span class="p">)</span>
<span class="w">          </span><span class="no">:let</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">let </span><span class="o">,</span><span class="nv">verb</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="o">,</span><span class="nv">rest</span><span class="p">))</span>
<span class="w">          </span><span class="no">:after</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="o">,</span><span class="nv">rest</span><span class="w"> </span><span class="o">,</span><span class="nv">verb</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">          </span><span class="no">:before</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="o">,</span><span class="nv">verb</span><span class="w"> </span><span class="o">,</span><span class="nv">rest</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">          </span><span class="no">:repeat</span><span class="w"> </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">iter</span><span class="p">]</span>
<span class="w">                    </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">var </span><span class="o">,</span><span class="nv">iter</span><span class="w"> </span><span class="o">,</span><span class="nv">verb</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">&gt; </span><span class="o">,</span><span class="nv">iter</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">rest</span><span class="w"> </span><span class="p">(</span><span class="nb">-- </span><span class="o">,</span><span class="nv">iter</span><span class="p">))))</span>
<span class="w">          </span><span class="no">:when</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">when </span><span class="o">,</span><span class="nv">verb</span><span class="w"> </span><span class="o">,</span><span class="nv">rest</span><span class="p">)</span>
<span class="w">          </span><span class="no">:unless</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">unless </span><span class="o">,</span><span class="nv">verb</span><span class="w"> </span><span class="o">,</span><span class="nv">rest</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;unexpected loop modifier &quot;</span><span class="w"> </span><span class="nv">binding</span><span class="p">))))))</span>

<span class="w">  </span><span class="c1"># 3 term expression</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="p">{(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="nv">object</span><span class="p">}</span><span class="w"> </span><span class="nv">head</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">rest</span><span class="w"> </span><span class="p">(</span><span class="nv">loop1</span><span class="w"> </span><span class="nv">body</span><span class="w"> </span><span class="nv">head</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">3</span><span class="p">))]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">case </span><span class="nv">verb</span>
<span class="w">      </span><span class="no">:range</span><span class="w"> </span><span class="p">(</span><span class="nv">range-template</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="nv">object</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="nv">rest</span><span class="w"> </span><span class="nb">+ </span><span class="nv">&lt;</span><span class="p">)</span>
<span class="w">      </span><span class="no">:range-to</span><span class="w"> </span><span class="p">(</span><span class="nv">range-template</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="nv">object</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="nv">rest</span><span class="w"> </span><span class="nb">+ </span><span class="nv">&lt;=</span><span class="p">)</span>
<span class="w">      </span><span class="no">:down</span><span class="w"> </span><span class="p">(</span><span class="nv">range-template</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="nv">object</span><span class="w"> </span><span class="no">:down</span><span class="w"> </span><span class="nv">rest</span><span class="w"> </span><span class="nb">- </span><span class="nv">&gt;</span><span class="p">)</span>
<span class="w">      </span><span class="no">:down-to</span><span class="w"> </span><span class="p">(</span><span class="nv">range-template</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="nv">object</span><span class="w"> </span><span class="no">:down</span><span class="w"> </span><span class="nv">rest</span><span class="w"> </span><span class="nb">- </span><span class="nv">&gt;=</span><span class="p">)</span>
<span class="w">      </span><span class="no">:keys</span><span class="w"> </span><span class="p">(</span><span class="nv">each-template</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="nv">object</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="nv">rest</span><span class="p">])</span>
<span class="w">      </span><span class="no">:pairs</span><span class="w"> </span><span class="p">(</span><span class="nv">each-template</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="nv">object</span><span class="w"> </span><span class="no">:pairs</span><span class="w"> </span><span class="p">[</span><span class="nv">rest</span><span class="p">])</span>
<span class="w">      </span><span class="no">:in</span><span class="w"> </span><span class="p">(</span><span class="nv">each-template</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="nv">object</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="p">[</span><span class="nv">rest</span><span class="p">])</span>
<span class="w">      </span><span class="no">:iterate</span><span class="w"> </span><span class="p">(</span><span class="nv">iterate-template</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="nv">object</span><span class="w"> </span><span class="nv">rest</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;unexpected loop verb &quot;</span><span class="w"> </span><span class="nv">verb</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">forv</span>
<span class="w">  </span><span class="s">``Do a C-style for-loop for side effects. The iteration variable `i`</span>
<span class="s">  can be mutated in the loop, unlike normal `for`. Returns nil.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">stop</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">for-var-template</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">stop</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="nb">&lt; + </span><span class="nv">body</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">for</span>
<span class="w">  </span><span class="s">&quot;Do a C-style for-loop for side effects. Returns nil.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">stop</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">for-template</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">stop</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="nb">&lt; + </span><span class="nv">body</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">eachk</span>
<span class="w">  </span><span class="s">&quot;Loop over each key in `ds`. Returns nil.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">ds</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">each-template</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">ds</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="nv">body</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">eachp</span>
<span class="w">  </span><span class="s">&quot;Loop over each (key, value) pair in `ds`. Returns nil.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">ds</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">each-template</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">ds</span><span class="w"> </span><span class="no">:pairs</span><span class="w"> </span><span class="nv">body</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">repeat</span>
<span class="w">  </span><span class="s">&quot;Evaluate body n times. If n is negative, body will be evaluated 0 times. Evaluates to nil.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">n</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">iter</span><span class="p">]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">var </span><span class="o">,</span><span class="nv">iter</span><span class="w"> </span><span class="o">,</span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">&gt; </span><span class="o">,</span><span class="nv">iter</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="w"> </span><span class="p">(</span><span class="nb">-- </span><span class="o">,</span><span class="nv">iter</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">forever</span>
<span class="w">  </span><span class="s">&quot;Evaluate body forever in a loop, or until a break statement.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">while </span><span class="kc">true</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">each</span>
<span class="w">  </span><span class="s">&quot;Loop over each value in `ds`. Returns nil.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">ds</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">each-template</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">ds</span><span class="w"> </span><span class="no">:each</span><span class="w"> </span><span class="nv">body</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">loop</span>
<span class="w">  </span><span class="s">```</span>
<span class="s">  A general purpose loop macro. This macro is similar to the Common Lisp loop</span>
<span class="s">  macro, although intentionally much smaller in scope.  The head of the loop</span>
<span class="s">  should be a tuple that contains a sequence of either bindings or</span>
<span class="s">  conditionals. A binding is a sequence of three values that define something</span>
<span class="s">  to loop over. Bindings are written in the format:</span>

<span class="s">      binding :verb object/expression</span>

<span class="s">  where `binding` is a binding as passed to def, `:verb` is one of a set of</span>
<span class="s">  keywords, and `object` is any expression. Each subsequent binding creates a</span>
<span class="s">  nested loop within the loop created by the previous binding.</span>

<span class="s">  The available verbs are:</span>

<span class="s">  * `:iterate` -- repeatedly evaluate and bind to the expression while it is</span>
<span class="s">    truthy.</span>

<span class="s">  * `:range` -- loop over a range. The object should be a two-element tuple with</span>
<span class="s">    a start and end value, and an optional positive step. The range is half</span>
<span class="s">    open, [start, end).</span>

<span class="s">  * `:range-to` -- same as :range, but the range is inclusive [start, end].</span>

<span class="s">  * `:down` -- loop over a range, stepping downwards. The object should be a</span>
<span class="s">    two-element tuple with a start and (exclusive) end value, and an optional</span>
<span class="s">    (positive!) step size.</span>

<span class="s">  * `:down-to` -- same as :down, but the range is inclusive [start, end].</span>

<span class="s">  * `:keys` -- iterate over the keys in a data structure.</span>

<span class="s">  * `:pairs` -- iterate over the key-value pairs as tuples in a data structure.</span>

<span class="s">  * `:in` -- iterate over the values in a data structure or fiber.</span>

<span class="s">  `loop` also accepts conditionals to refine the looping further. Conditionals are of</span>
<span class="s">  the form:</span>

<span class="s">      :modifier argument</span>

<span class="s">  where `:modifier` is one of a set of keywords, and `argument` is keyword-dependent.</span>
<span class="s">  `:modifier` can be one of:</span>

<span class="s">  * `:while expression` -- breaks from the current loop if `expression` is</span>
<span class="s">    falsey.</span>

<span class="s">  * `:until expression` -- breaks from the current loop if `expression` is</span>
<span class="s">    truthy.</span>

<span class="s">  * `:let bindings` -- defines bindings inside the current loop as passed to the</span>
<span class="s">    `let` macro.</span>

<span class="s">  * `:before form` -- evaluates a form for a side effect before the next inner</span>
<span class="s">    loop.</span>

<span class="s">  * `:after form` -- same as `:before`, but the side effect happens after the</span>
<span class="s">    next inner loop.</span>

<span class="s">  * `:repeat n` -- repeats the next inner loop `n` times.</span>

<span class="s">  * `:when condition` -- only evaluates the current loop body when `condition`</span>
<span class="s">    is truthy.</span>

<span class="s">  * `:unless condition` -- only evaluates the current loop body when `condition`</span>
<span class="s">    is falsey.</span>

<span class="s">  The `loop` macro always evaluates to nil.</span>
<span class="s">  ```</span>
<span class="w">  </span><span class="p">[</span><span class="nv">head</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">loop1</span><span class="w"> </span><span class="nv">body</span><span class="w"> </span><span class="nv">head</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">seq</span>
<span class="w">  </span><span class="s">``Similar to `loop`, but accumulates the loop body into an array and returns that.</span>
<span class="s">  See `loop` for details.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">head</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">$accum</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">$accum</span><span class="w"> </span><span class="p">@[])</span><span class="w"> </span><span class="p">(</span><span class="nb">loop </span><span class="o">,</span><span class="nv">head</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">array/push </span><span class="o">,</span><span class="nv">$accum</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">body</span><span class="p">)))</span><span class="w"> </span><span class="o">,</span><span class="nv">$accum</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">catseq</span>
<span class="w">  </span><span class="s">``Similar to `loop`, but concatenates each element from the loop body into an array and returns that.</span>
<span class="s">  See `loop` for details.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">head</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">$accum</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">$accum</span><span class="w"> </span><span class="p">@[])</span><span class="w"> </span><span class="p">(</span><span class="nb">loop </span><span class="o">,</span><span class="nv">head</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">array/concat </span><span class="o">,</span><span class="nv">$accum</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">body</span><span class="p">)))</span><span class="w"> </span><span class="o">,</span><span class="nv">$accum</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">tabseq</span>
<span class="w">  </span><span class="s">``Similar to `loop`, but accumulates key value pairs into a table.</span>
<span class="s">  See `loop` for details.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">head</span><span class="w"> </span><span class="nv">key-body</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">value-body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">$accum</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">$accum</span><span class="w"> </span><span class="p">@{})</span><span class="w"> </span><span class="p">(</span><span class="nb">loop </span><span class="o">,</span><span class="nv">head</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">put </span><span class="o">,</span><span class="nv">$accum</span><span class="w"> </span><span class="o">,</span><span class="nv">key-body</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">value-body</span><span class="p">)))</span><span class="w"> </span><span class="o">,</span><span class="nv">$accum</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">generate</span>
<span class="w">  </span><span class="s">``Create a generator expression using the `loop` syntax. Returns a fiber</span>
<span class="s">  that yields all values inside the loop in order. See `loop` for details.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">head</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/new </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">loop </span><span class="o">,</span><span class="nv">head</span><span class="w"> </span><span class="p">(</span><span class="nb">yield </span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">body</span><span class="p">))))</span><span class="w"> </span><span class="no">:yi</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">coro</span>
<span class="w">  </span><span class="s">&quot;A wrapper for making fibers that may yield multiple values (coroutine). Same as `(fiber/new (fn [] ;body) :yi)`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">tuple fiber/new </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">fn </span><span class="o">&#39;</span><span class="p">[]</span><span class="w"> </span><span class="o">;</span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="no">:yi</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">fiber-fn</span>
<span class="w">  </span><span class="s">&quot;A wrapper for making fibers. Same as `(fiber/new (fn [] ;body) flags)`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">flags</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">tuple fiber/new </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">fn </span><span class="o">&#39;</span><span class="p">[]</span><span class="w"> </span><span class="o">;</span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="nv">flags</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">sum</span>
<span class="w">  </span><span class="s">&quot;Returns the sum of xs. If xs is empty, returns 0.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">accum</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="nv">xs</span><span class="w"> </span><span class="p">(</span><span class="nb">+= </span><span class="nv">accum</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">  </span><span class="nv">accum</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">mean</span>
<span class="w">  </span><span class="s">&quot;Returns the mean of xs. If empty, returns NaN.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">lengthable? </span><span class="nv">xs</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">sum </span><span class="nv">xs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">xs</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="p">[</span><span class="nv">accum</span><span class="w"> </span><span class="nv">total</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="mf">0</span><span class="p">])</span>
<span class="w">      </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="nv">xs</span><span class="w"> </span><span class="p">(</span><span class="nb">+= </span><span class="nv">accum</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">++ </span><span class="nv">total</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">/ </span><span class="nv">accum</span><span class="w"> </span><span class="nv">total</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">product</span>
<span class="w">  </span><span class="s">&quot;Returns the product of xs. If xs is empty, returns 1.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">accum</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="nv">xs</span><span class="w"> </span><span class="p">(</span><span class="nb">*= </span><span class="nv">accum</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">  </span><span class="nv">accum</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">if-let</span>
<span class="w">  </span><span class="s">``Make multiple bindings, and if all are truthy,</span>
<span class="s">  evaluate the `tru` form. If any are false or nil, evaluate</span>
<span class="s">  the `fal` form. Bindings have the same syntax as the `let` macro.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">bindings</span><span class="w"> </span><span class="nv">tru</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">fal</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">bindings</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mf">0</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">error </span><span class="s">&quot;expected at least 1 binding&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">odd? </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">error </span><span class="s">&quot;expected an even number of bindings&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">aux</span><span class="w"> </span><span class="p">[</span><span class="nv">i</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">i</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span>
<span class="w">      </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="o">,</span><span class="nv">tru</span><span class="p">)</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">bl</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">bindings</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">br</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">bindings</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="mf">1</span><span class="w"> </span><span class="nv">i</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">symbol? </span><span class="nv">bl</span><span class="p">)</span>
<span class="w">          </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">bl</span><span class="w"> </span><span class="o">,</span><span class="nv">br</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nv">aux</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="mf">2</span><span class="w"> </span><span class="nv">i</span><span class="p">)))</span>
<span class="w">          </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="p">(</span><span class="k">def </span><span class="nv">sym</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span><span class="w"> </span><span class="o">,</span><span class="nv">br</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">bl</span><span class="w"> </span><span class="o">,</span><span class="nv">sym</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nv">aux</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="mf">2</span><span class="w"> </span><span class="nv">i</span><span class="p">))))))))</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">var </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="p">(</span><span class="nv">aux</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="o">,</span><span class="nv">fal</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">when-let</span>
<span class="w">  </span><span class="s">&quot;Same as `(if-let bindings (do ;body))`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">bindings</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nb">if-let </span><span class="o">,</span><span class="nv">bindings</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">comp</span>
<span class="w">  </span><span class="s">`Takes multiple functions and returns a function that is the composition</span>
<span class="s">  of those functions.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">functions</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">length </span><span class="nv">functions</span><span class="p">)</span>
<span class="w">    </span><span class="mf">0</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">    </span><span class="mf">1</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">functions</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">    </span><span class="mf">2</span><span class="w"> </span><span class="p">(</span><span class="nb">let </span><span class="p">[[</span><span class="nv">f</span><span class="w"> </span><span class="nv">g</span><span class="p">]</span><span class="w"> </span><span class="nv">functions</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nv">g</span><span class="w"> </span><span class="o">;</span><span class="nv">x</span><span class="p">))))</span>
<span class="w">    </span><span class="mf">3</span><span class="w"> </span><span class="p">(</span><span class="nb">let </span><span class="p">[[</span><span class="nv">f</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="nv">h</span><span class="p">]</span><span class="w"> </span><span class="nv">functions</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nv">g</span><span class="w"> </span><span class="p">(</span><span class="nv">h</span><span class="w"> </span><span class="o">;</span><span class="nv">x</span><span class="p">)))))</span>
<span class="w">    </span><span class="mf">4</span><span class="w"> </span><span class="p">(</span><span class="nb">let </span><span class="p">[[</span><span class="nv">f</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="nv">i</span><span class="p">]</span><span class="w"> </span><span class="nv">functions</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nv">g</span><span class="w"> </span><span class="p">(</span><span class="nv">h</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="o">;</span><span class="nv">x</span><span class="p">))))))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">let </span><span class="p">[[</span><span class="nv">f</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="nv">i</span><span class="p">]</span><span class="w"> </span><span class="nv">functions</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">comp </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nv">g</span><span class="w"> </span><span class="p">(</span><span class="nv">h</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="nv">x</span><span class="p">)))))</span>
<span class="w">            </span><span class="o">;</span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">functions</span><span class="w"> </span><span class="mf">4</span><span class="w"> </span><span class="mf">-1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">identity</span>
<span class="w">  </span><span class="s">&quot;A function that returns its argument.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="nv">x</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">complement</span>
<span class="w">  </span><span class="s">&quot;Returns a function that is the complement to the argument.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defmacro- </span><span class="nv">do-extreme</span>
<span class="w">  </span><span class="p">[</span><span class="nv">order</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">def </span><span class="nv">ds</span><span class="w"> </span><span class="o">,</span><span class="nv">args</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">var </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ds</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">     </span><span class="p">(</span><span class="k">var </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">ds</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">     </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="o">,</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ds</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ds</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="o">,</span><span class="nv">order</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">ret</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">     </span><span class="nv">ret</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">extreme</span>
<span class="w">  </span><span class="s">``Returns the most extreme value in `args` based on the function `order`.</span>
<span class="s">  `order` should take two values and return true or false (a comparison).</span>
<span class="s">  Returns nil if `args` is empty.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">order</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">do-extreme</span><span class="w"> </span><span class="nv">order</span><span class="w"> </span><span class="nv">args</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">max</span>
<span class="w">  </span><span class="s">&quot;Returns the numeric maximum of the arguments.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">do-extreme</span><span class="w"> </span><span class="nb">&gt; </span><span class="nv">args</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">min</span>
<span class="w">  </span><span class="s">&quot;Returns the numeric minimum of the arguments.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">do-extreme</span><span class="w"> </span><span class="nb">&lt; </span><span class="nv">args</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">max-of</span>
<span class="w">  </span><span class="s">&quot;Returns the numeric maximum of the argument sequence.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">args</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">do-extreme</span><span class="w"> </span><span class="nb">&gt; </span><span class="nv">args</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">min-of</span>
<span class="w">  </span><span class="s">&quot;Returns the numeric minimum of the argument sequence.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">args</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">do-extreme</span><span class="w"> </span><span class="nb">&lt; </span><span class="nv">args</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">first</span>
<span class="w">  </span><span class="s">&quot;Get the first element from an indexed data structure.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">get </span><span class="nv">xs</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">last</span>
<span class="w">  </span><span class="s">&quot;Get the last element from an indexed data structure.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">get </span><span class="nv">xs</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">xs</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>

<span class="c1">## Polymorphic comparisons</span>

<span class="p">(</span><span class="nb">defmacro- </span><span class="nv">do-compare</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">def </span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="no">:compare</span><span class="p">))</span>
<span class="w">     </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="nv">y</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">def </span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="o">,</span><span class="nv">y</span><span class="w"> </span><span class="no">:compare</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="o">,</span><span class="nv">y</span><span class="w"> </span><span class="o">,</span><span class="nv">x</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="nb">cmp </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="nv">y</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">compare</span>
<span class="w">  </span><span class="s">``Polymorphic compare. Returns -1, 0, 1 for x &lt; y, x = y, x &gt; y respectively.</span>
<span class="s">  Differs from the primitive comparators in that it first checks to</span>
<span class="s">  see whether either x or y implement a `compare` method which can</span>
<span class="s">  compare x and y. If so, it uses that method. If not, it</span>
<span class="s">  delegates to the primitive comparators.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">do-compare</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro- </span><span class="nv">compare-reduce</span><span class="w"> </span><span class="p">[</span><span class="nv">op</span><span class="w"> </span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">var </span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="o">,</span><span class="nv">xs</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">     </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="o">,</span><span class="nv">xs</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">y</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="o">,</span><span class="nv">xs</span><span class="w"> </span><span class="nv">i</span><span class="p">)]</span>
<span class="w">         </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="o">,</span><span class="nv">op</span><span class="w"> </span><span class="p">(</span><span class="nv">do-compare</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="k">set </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">set </span><span class="nv">res</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))))</span>
<span class="w">     </span><span class="nv">res</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">compare=</span>
<span class="w">  </span><span class="s">``Equivalent of `=` but using polymorphic `compare` instead of primitive comparator.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">compare-reduce</span><span class="w"> </span><span class="nb">= </span><span class="nv">xs</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">compare&lt;</span>
<span class="w">  </span><span class="s">``Equivalent of `&lt;` but using polymorphic `compare` instead of primitive comparator.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">compare-reduce</span><span class="w"> </span><span class="nb">&lt; </span><span class="nv">xs</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">compare&lt;=</span>
<span class="w">  </span><span class="s">``Equivalent of `&lt;=` but using polymorphic `compare` instead of primitive comparator.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">compare-reduce</span><span class="w"> </span><span class="nb">&lt;= </span><span class="nv">xs</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">compare&gt;</span>
<span class="w">  </span><span class="s">``Equivalent of `&gt;` but using polymorphic `compare` instead of primitive comparator.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">compare-reduce</span><span class="w"> </span><span class="nb">&gt; </span><span class="nv">xs</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">compare&gt;=</span>
<span class="w">  </span><span class="s">``Equivalent of `&gt;=` but using polymorphic `compare` instead of primitive comparator.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">compare-reduce</span><span class="w"> </span><span class="nb">&gt;= </span><span class="nv">xs</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn zero? </span><span class="s">&quot;Check if x is zero.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">compare </span><span class="nv">x</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn pos? </span><span class="s">&quot;Check if x is greater than 0.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">compare </span><span class="nv">x</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn neg? </span><span class="s">&quot;Check if x is less than 0.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">compare </span><span class="nv">x</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="mf">-1</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn one? </span><span class="s">&quot;Check if x is equal to 1.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">compare </span><span class="nv">x</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn even? </span><span class="s">&quot;Check if x is even.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">compare </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">mod </span><span class="nv">x</span><span class="w"> </span><span class="mf">2</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">defn odd? </span><span class="s">&quot;Check if x is odd.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">compare </span><span class="mf">1</span><span class="w"> </span><span class="p">(</span><span class="nb">mod </span><span class="nv">x</span><span class="w"> </span><span class="mf">2</span><span class="p">))))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Indexed Combinators</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defmacro- </span><span class="nv">median-of-three</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="nv">z</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="nv">y</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="o">,</span><span class="nv">y</span><span class="w"> </span><span class="o">,</span><span class="nv">z</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">y</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="o">,</span><span class="nv">z</span><span class="w"> </span><span class="o">,</span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="nv">z</span><span class="p">))</span>
<span class="w">     </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="o">,</span><span class="nv">z</span><span class="w"> </span><span class="o">,</span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">y</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="nv">z</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="nv">z</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defmacro- </span><span class="nv">sort-partition-template</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ind</span><span class="w"> </span><span class="nv">before?</span><span class="w"> </span><span class="nv">left</span><span class="w"> </span><span class="nv">right</span><span class="w"> </span><span class="nv">pivot</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="o">,</span><span class="nv">before?</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="o">,</span><span class="nv">ind</span><span class="w"> </span><span class="o">,</span><span class="nv">left</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">pivot</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">++ </span><span class="o">,</span><span class="nv">left</span><span class="p">))</span>
<span class="w">     </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="o">,</span><span class="nv">before?</span><span class="w"> </span><span class="o">,</span><span class="nv">pivot</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="o">,</span><span class="nv">ind</span><span class="w"> </span><span class="o">,</span><span class="nv">right</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">-- </span><span class="o">,</span><span class="nv">right</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">sort-help</span><span class="w"> </span><span class="p">[</span><span class="nv">a</span><span class="w"> </span><span class="nv">lo</span><span class="w"> </span><span class="nv">hi</span><span class="w"> </span><span class="nv">before?</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">lo</span><span class="w"> </span><span class="nv">hi</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="nv">z</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nb">in </span><span class="nv">a</span><span class="w"> </span><span class="nv">lo</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">in </span><span class="nv">a</span><span class="w"> </span><span class="p">(</span><span class="nb">div </span><span class="p">(</span><span class="nb">+ </span><span class="nv">lo</span><span class="w"> </span><span class="nv">hi</span><span class="p">)</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">in </span><span class="nv">a</span><span class="w"> </span><span class="nv">hi</span><span class="p">)])</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">pivot</span><span class="w"> </span><span class="p">(</span><span class="nv">median-of-three</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="nv">z</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">left</span><span class="w"> </span><span class="nv">lo</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">right</span><span class="w"> </span><span class="nv">hi</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="kc">true</span>
<span class="w">      </span><span class="p">(</span><span class="nb">case </span><span class="nv">before?</span>
<span class="w">        </span><span class="nb">&lt; </span><span class="p">(</span><span class="nv">sort-partition-template</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nb">&lt; </span><span class="nv">left</span><span class="w"> </span><span class="nv">right</span><span class="w"> </span><span class="nv">pivot</span><span class="p">)</span>
<span class="w">        </span><span class="nb">&gt; </span><span class="p">(</span><span class="nv">sort-partition-template</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nb">&gt; </span><span class="nv">left</span><span class="w"> </span><span class="nv">right</span><span class="w"> </span><span class="nv">pivot</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nv">sort-partition-template</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">before?</span><span class="w"> </span><span class="nv">left</span><span class="w"> </span><span class="nv">right</span><span class="w"> </span><span class="nv">pivot</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">left</span><span class="w"> </span><span class="nv">right</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">tmp</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">a</span><span class="w"> </span><span class="nv">left</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="p">(</span><span class="nv">a</span><span class="w"> </span><span class="nv">left</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">a</span><span class="w"> </span><span class="nv">right</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="p">(</span><span class="nv">a</span><span class="w"> </span><span class="nv">right</span><span class="p">)</span><span class="w"> </span><span class="nv">tmp</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">++ </span><span class="nv">left</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">-- </span><span class="nv">right</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">left</span><span class="w"> </span><span class="nv">right</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">lo</span><span class="w"> </span><span class="nv">right</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">sort-help</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">lo</span><span class="w"> </span><span class="nv">right</span><span class="w"> </span><span class="nv">before?</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">left</span><span class="w"> </span><span class="nv">hi</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">sort-help</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">left</span><span class="w"> </span><span class="nv">hi</span><span class="w"> </span><span class="nv">before?</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">a</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">sort</span>
<span class="w">  </span><span class="s">``Sorts `ind` in-place, and returns it. Uses quick-sort and is not a stable sort.</span>
<span class="s">  If a `before?` comparator function is provided, sorts elements using that,</span>
<span class="s">  otherwise uses `&lt;`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">before?</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">before?</span><span class="w"> </span><span class="nv">&lt;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">sort-help</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nv">before?</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">sort-by</span>
<span class="w">  </span><span class="s">``Sorts `ind` in-place by calling a function `f` on each element and</span>
<span class="s">  comparing the result with `&lt;`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">sort </span><span class="nv">ind</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">y</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">sorted</span>
<span class="w">  </span><span class="s">``Returns a new sorted array without modifying the old one.</span>
<span class="s">  If a `before?` comparator function is provided, sorts elements using that,</span>
<span class="s">  otherwise uses `&lt;`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">before?</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">array/slice </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="nv">before?</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">sorted-by</span>
<span class="w">  </span><span class="s">``Returns a new sorted array that compares elements by invoking</span>
<span class="s">  a function `f` on each element and comparing the result with `&lt;`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">sorted </span><span class="nv">ind</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">y</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">reduce</span>
<span class="w">  </span><span class="s">``Reduce, also know as fold-left in many languages, transforms</span>
<span class="s">  an indexed type (array, tuple) with a function to produce a value by applying `f` to</span>
<span class="s">  each element in order. `f` is a function of 2 arguments, `(f accum el)`, where</span>
<span class="s">  `accum` is the initial value and `el` is the next value in the indexed type `ind`.</span>
<span class="s">  `f` returns a value that will be used as `accum` in the next call to `f`. `reduce`</span>
<span class="s">  returns the value of the final call to `f`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">init</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">accum</span><span class="w"> </span><span class="nv">init</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">el</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">accum</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">accum</span><span class="w"> </span><span class="nv">el</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">accum</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">reduce2</span>
<span class="w">  </span><span class="s">``The 2-argument version of `reduce` that does not take an initialization value.</span>
<span class="s">  Instead, the first element of the array is used for initialization.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">break </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">set </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">accumulate</span>
<span class="w">  </span><span class="s">``Similar to `reduce`, but accumulates intermediate values into an array.</span>
<span class="s">  The last element in the array is what would be the return value from `reduce`.</span>
<span class="s">  The `init` value is not added to the array (the return value will have the same</span>
<span class="s">  number of elements as `ind`).</span>
<span class="s">  Returns a new array.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">init</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="nv">init</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">x</span><span class="p">))))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">accumulate2</span>
<span class="w">  </span><span class="s">``The 2-argument version of `accumulate` that does not take an initialization value.</span>
<span class="s">  The first value in `ind` will be added to the array as is, so the length of the</span>
<span class="s">  return value will be `(length ind)`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">break </span><span class="nv">ret</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="nv">res</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">set </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="nv">res</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defmacro- </span><span class="nv">map-aggregator</span>
<span class="w">  </span><span class="s">`Aggregation logic for various map functions.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">maptype</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">val</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">case </span><span class="nv">maptype</span>
<span class="w">    </span><span class="no">:map</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">array/push </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="o">,</span><span class="nv">val</span><span class="p">)</span>
<span class="w">    </span><span class="no">:mapcat</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">array/concat </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="o">,</span><span class="nv">val</span><span class="p">)</span>
<span class="w">    </span><span class="no">:keep</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">def </span><span class="nv">y</span><span class="w"> </span><span class="o">,</span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span>
<span class="w">    </span><span class="no">:count</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">val</span><span class="w"> </span><span class="p">(</span><span class="nb">++ </span><span class="o">,</span><span class="nv">res</span><span class="p">))</span>
<span class="w">    </span><span class="no">:some</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">def </span><span class="nv">y</span><span class="w"> </span><span class="o">,</span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))</span>
<span class="w">    </span><span class="no">:all</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">def </span><span class="nv">y</span><span class="w"> </span><span class="o">,</span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defmacro- </span><span class="nv">map-n</span>
<span class="w">  </span><span class="s">`Generates efficient map logic for a specific number of</span>
<span class="s">  indexed beyond the first.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">n</span><span class="w"> </span><span class="nv">maptype</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">inds</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="nv">n</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol </span><span class="o">&#39;</span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span><span class="w"> </span><span class="o">,</span><span class="nv">inds</span><span class="p">)</span>
<span class="w">     </span><span class="o">,;</span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="nv">n</span><span class="p">]]</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">var </span><span class="o">,</span><span class="p">(</span><span class="nb">symbol </span><span class="o">&#39;</span><span class="nv">key</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">     </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="nv">ind</span>
<span class="w">       </span><span class="o">,;</span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="nv">n</span><span class="p">]]</span>
<span class="w">           </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="p">(</span><span class="nb">symbol </span><span class="o">&#39;</span><span class="nv">key</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="o">,</span><span class="p">(</span><span class="nb">symbol </span><span class="o">&#39;</span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nb">symbol </span><span class="o">&#39;</span><span class="nv">key</span><span class="w"> </span><span class="nv">k</span><span class="p">))))</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))</span>
<span class="w">       </span><span class="p">(</span><span class="nv">map-aggregator</span><span class="w"> </span><span class="o">,</span><span class="nv">maptype</span><span class="w"> </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">,;</span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="nv">n</span><span class="p">]]</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">in </span><span class="o">,</span><span class="p">(</span><span class="nb">symbol </span><span class="o">&#39;</span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nb">symbol </span><span class="o">&#39;</span><span class="nv">key</span><span class="w"> </span><span class="nv">k</span><span class="p">))))))))</span>

<span class="p">(</span><span class="nb">defmacro- </span><span class="nv">map-template</span>
<span class="w">  </span><span class="p">[</span><span class="nv">maptype</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">inds</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">     </span><span class="p">(</span><span class="k">def </span><span class="nv">ninds</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="o">,</span><span class="nv">inds</span><span class="p">))</span>
<span class="w">     </span><span class="p">(</span><span class="nb">case </span><span class="nv">ninds</span>
<span class="w">       </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="nv">ind</span><span class="w"> </span><span class="p">(</span><span class="nv">map-aggregator</span><span class="w"> </span><span class="o">,</span><span class="nv">maptype</span><span class="w"> </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">       </span><span class="mf">1</span><span class="w"> </span><span class="p">(</span><span class="nv">map-n</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="o">,</span><span class="nv">maptype</span><span class="w"> </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="o">,</span><span class="nv">ind</span><span class="w"> </span><span class="o">,</span><span class="nv">inds</span><span class="p">)</span>
<span class="w">       </span><span class="mf">2</span><span class="w"> </span><span class="p">(</span><span class="nv">map-n</span><span class="w"> </span><span class="mf">2</span><span class="w"> </span><span class="o">,</span><span class="nv">maptype</span><span class="w"> </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="o">,</span><span class="nv">ind</span><span class="w"> </span><span class="o">,</span><span class="nv">inds</span><span class="p">)</span>
<span class="w">       </span><span class="mf">3</span><span class="w"> </span><span class="p">(</span><span class="nv">map-n</span><span class="w"> </span><span class="mf">3</span><span class="w"> </span><span class="o">,</span><span class="nv">maptype</span><span class="w"> </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="o">,</span><span class="nv">ind</span><span class="w"> </span><span class="o">,</span><span class="nv">inds</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nv">do</span>
<span class="w">         </span><span class="p">(</span><span class="k">def </span><span class="nv">iter-keys</span><span class="w"> </span><span class="p">(</span><span class="nb">array/new-filled </span><span class="nv">ninds</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="k">def </span><span class="nv">call-buffer</span><span class="w"> </span><span class="p">(</span><span class="nb">array/new-filled </span><span class="nv">ninds</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="k">var </span><span class="nv">done</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="o">,</span><span class="nv">ind</span>
<span class="w">           </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="nv">ninds</span>
<span class="w">             </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">old-key</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">iter-keys</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span>
<span class="w">                   </span><span class="nv">ii</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="o">,</span><span class="nv">inds</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span>
<span class="w">                   </span><span class="nv">new-key</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ii</span><span class="w"> </span><span class="nv">old-key</span><span class="p">)]</span>
<span class="w">               </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">new-key</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">set </span><span class="nv">done</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">set </span><span class="p">(</span><span class="nv">iter-keys</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="nv">new-key</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="p">(</span><span class="nv">call-buffer</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ii</span><span class="w"> </span><span class="nv">new-key</span><span class="p">))))))</span>
<span class="w">           </span><span class="p">(</span><span class="k">if </span><span class="nv">done</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="nv">map-aggregator</span><span class="w"> </span><span class="o">,</span><span class="nv">maptype</span><span class="w"> </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">;</span><span class="nv">call-buffer</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">map</span>
<span class="w">  </span><span class="s">`Map a function over every value in a data structure and</span>
<span class="s">  return an array of the results.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">inds</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="nv">map-template</span><span class="w"> </span><span class="no">:map</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">inds</span><span class="p">)</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">mapcat</span>
<span class="w">  </span><span class="s">``Map a function over every element in an array or tuple and</span>
<span class="s">  use `array/concat` to concatenate the results.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">inds</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="nv">map-template</span><span class="w"> </span><span class="no">:mapcat</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">inds</span><span class="p">)</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">filter</span>
<span class="w">  </span><span class="s">``Given a predicate, take only elements from an array or tuple for</span>
<span class="s">  which `(pred element)` is truthy. Returns a new array.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">item</span><span class="w"> </span><span class="nv">ind</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nv">pred</span><span class="w"> </span><span class="nv">item</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">res</span><span class="w"> </span><span class="nv">item</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">count</span>
<span class="w">  </span><span class="s">``Count the number of items in `ind` for which `(pred item)`</span>
<span class="s">  is true.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">inds</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">map-template</span><span class="w"> </span><span class="no">:count</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">inds</span><span class="p">)</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">keep</span>
<span class="w">  </span><span class="s">``Given a predicate `pred`, return a new array containing the truthy results</span>
<span class="s">  of applying `pred` to each element in the indexed collection `ind`. This is</span>
<span class="s">  different from `filter` which returns an array of the original elements where</span>
<span class="s">  the predicate is truthy.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">inds</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="nv">map-template</span><span class="w"> </span><span class="no">:keep</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">inds</span><span class="p">)</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">find-index</span>
<span class="w">  </span><span class="s">``Find the index of indexed type for which `pred` is true. Returns `dflt` if not found.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">dflt</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">k</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">ret</span><span class="w"> </span><span class="nv">dflt</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="kc">true</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">k</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">item</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nv">pred</span><span class="w"> </span><span class="nv">item</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">break</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">find</span>
<span class="w">  </span><span class="s">``Find the first value in an indexed collection that satisfies a predicate. Returns</span>
<span class="s">  `dflt` if not found.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">dflt</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">k</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">ret</span><span class="w"> </span><span class="nv">dflt</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="kc">true</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">k</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">item</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nv">pred</span><span class="w"> </span><span class="nv">item</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="nv">item</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">break</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">index-of</span>
<span class="w">  </span><span class="s">``Find the first key associated with a value x in a data structure, acting like a reverse lookup.</span>
<span class="s">  Will not look at table prototypes.</span>
<span class="s">  Returns `dflt` if not found.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">dflt</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">ret</span><span class="w"> </span><span class="nv">dflt</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">take-n-slice</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">m</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">len</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">start</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">n</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="nv">m</span><span class="p">)</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">end</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="mf">0</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">len</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">end</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">take</span>
<span class="w">  </span><span class="s">``Take the first n elements of a fiber, indexed or bytes type. Returns a new array, tuple or string,</span>
<span class="s">  respectively. If `n` is negative, takes the last `n` elements instead.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">    </span><span class="p">(</span><span class="nb">indexed? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">take-n-slice</span><span class="w"> </span><span class="nb">tuple/slice </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">bytes? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">take-n-slice</span><span class="w"> </span><span class="nb">string/slice </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">dictionary? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">do</span>
<span class="w">                        </span><span class="p">(</span><span class="k">var </span><span class="nv">left</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">tabseq </span><span class="p">[[</span><span class="nv">i</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="no">:pairs</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="no">:until</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">-- </span><span class="nv">left</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">)]</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="nv">key</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">repeat </span><span class="nv">n</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">key</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">key</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">key</span><span class="p">)))</span>
<span class="w">      </span><span class="nv">res</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">take-until-slice</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nb">find-index </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">end</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="kc">nil</span><span class="nv">?</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="nv">end</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">take-until</span>
<span class="w">  </span><span class="s">&quot;Same as `(take-while (complement pred) ind)`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">    </span><span class="p">(</span><span class="nb">indexed? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">take-until-slice</span><span class="w"> </span><span class="nb">tuple/slice </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">bytes? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">take-until-slice</span><span class="w"> </span><span class="nb">string/slice </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">dictionary? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">tabseq </span><span class="p">[[</span><span class="nv">i</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="no">:pairs</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="no">:until</span><span class="w"> </span><span class="p">(</span><span class="nv">pred</span><span class="w"> </span><span class="nv">x</span><span class="p">)]</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="no">:until</span><span class="w"> </span><span class="p">(</span><span class="nv">pred</span><span class="w"> </span><span class="nv">x</span><span class="p">)]</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">take-while</span>
<span class="w">  </span><span class="s">`Given a predicate, take only elements from a fiber, indexed, or bytes type that satisfy</span>
<span class="s">  the predicate, and abort on first failure. Returns a new array, tuple, or string, respectively.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">take-until </span><span class="p">(</span><span class="nb">complement </span><span class="nv">pred</span><span class="p">)</span><span class="w"> </span><span class="nv">ind</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">drop-n-slice</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">    </span><span class="p">(</span><span class="nb">&lt;= </span><span class="mf">0</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">- </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">len</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">len</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">drop-n-dict</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">left</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[[</span><span class="nv">i</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="no">:pairs</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="no">:until</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">-- </span><span class="nv">left</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="p">(</span><span class="nv">res</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">drop</span>
<span class="w">  </span><span class="s">``Drop the first `n` elements in an indexed or bytes type. Returns a new tuple or string</span>
<span class="s">  instance, respectively. If `n` is negative, drops the last `n` elements instead.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">    </span><span class="p">(</span><span class="nb">indexed? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">drop-n-slice</span><span class="w"> </span><span class="nb">tuple/slice </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">bytes? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">drop-n-slice</span><span class="w"> </span><span class="nb">string/slice </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">struct? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">drop-n-dict</span><span class="w"> </span><span class="nb">struct/to-table </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">table? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">drop-n-dict</span><span class="w"> </span><span class="nb">table/clone </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="nv">key</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">repeat </span><span class="nv">n</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">key</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">key</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))</span>
<span class="w">      </span><span class="nv">ind</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">drop-until-slice</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nb">find-index </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">start</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="kc">nil</span><span class="nv">?</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">start</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">drop-until-dict</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[[</span><span class="nv">i</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="no">:pairs</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="no">:until</span><span class="w"> </span><span class="p">(</span><span class="nv">pred</span><span class="w"> </span><span class="nv">x</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="p">(</span><span class="nv">res</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">drop-until</span>
<span class="w">  </span><span class="s">&quot;Same as `(drop-while (complement pred) ind)`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">    </span><span class="p">(</span><span class="nb">indexed? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">drop-until-slice</span><span class="w"> </span><span class="nb">tuple/slice </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">bytes? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">drop-until-slice</span><span class="w"> </span><span class="nb">string/slice </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">struct? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">drop-until-dict</span><span class="w"> </span><span class="nb">struct/to-table </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">table? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">drop-until-dict</span><span class="w"> </span><span class="nb">table/clone </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">find </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="nv">ind</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">drop-while</span>
<span class="w">  </span><span class="s">`Given a predicate, remove elements from an indexed or bytes type that satisfy</span>
<span class="s">  the predicate, and abort on first failure. Returns a new tuple or string, respectively.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">drop-until </span><span class="p">(</span><span class="nb">complement </span><span class="nv">pred</span><span class="p">)</span><span class="w"> </span><span class="nv">ind</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">juxt*</span>
<span class="w">  </span><span class="s">``Returns the juxtaposition of functions. In other words,</span>
<span class="s">  `((juxt* a b c) x)` evaluates to `[(a x) (b x) (c x)]`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">funs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">    </span><span class="p">(</span><span class="nb">each </span><span class="nv">f</span><span class="w"> </span><span class="nv">funs</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">ret</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">juxt</span>
<span class="w">  </span><span class="s">&quot;Macro form of `juxt*`. Same behavior but more efficient.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">funs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">parts</span><span class="w"> </span><span class="p">@[</span><span class="o">&#39;</span><span class="nv">tuple</span><span class="p">])</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">$args</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">f</span><span class="w"> </span><span class="nv">funs</span>
<span class="w">    </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">parts</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple apply </span><span class="nv">f</span><span class="w"> </span><span class="nv">$args</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">fn </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">$args</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">parts</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">defdyn</span>
<span class="w">  </span><span class="s">``Define an alias for a keyword that is used as a dynamic binding. The</span>
<span class="s">  alias is a normal, lexically scoped binding that can be used instead of</span>
<span class="s">  a keyword to prevent typos. `defdyn` does not set dynamic bindings or otherwise</span>
<span class="s">  replace `dyn` and `setdyn`. The alias _must_ start and end with the `*` character, usually</span>
<span class="s">  called &quot;earmuffs&quot;.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">alias</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">more</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">symbol? </span><span class="nv">alias</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;alias must be a symbol&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">length </span><span class="nv">alias</span><span class="p">)</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="mf">42</span><span class="w"> </span><span class="p">(</span><span class="nb">first </span><span class="nv">alias</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">last </span><span class="nv">alias</span><span class="p">)))</span><span class="w"> </span><span class="s">&quot;name must have leading and trailing &#39;*&#39; characters&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">prefix</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="no">:defdyn-prefix</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">kw</span><span class="w"> </span><span class="p">(</span><span class="nb">keyword </span><span class="nv">prefix</span><span class="w"> </span><span class="p">(</span><span class="nb">slice </span><span class="nv">alias</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="mf">-2</span><span class="p">)))</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">alias</span><span class="w"> </span><span class="no">:dyn</span><span class="w"> </span><span class="o">,;</span><span class="nv">more</span><span class="w"> </span><span class="o">,</span><span class="nv">kw</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">has-key?</span>
<span class="w">  </span><span class="s">&quot;Check if a data structure `ds` contains the key `key`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ds</span><span class="w"> </span><span class="nv">key</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">ds</span><span class="w"> </span><span class="nv">key</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">has-value?</span>
<span class="w">  </span><span class="s">&quot;Check if a data structure `ds` contains the value `value`. Will run in time proportional to the size of `ds`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ds</span><span class="w"> </span><span class="nv">value</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="nb">index-of </span><span class="nv">value</span><span class="w"> </span><span class="nv">ds</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*defdyn-prefix*</span><span class="w"> </span><span class="s">``Optional namespace prefix to add to keywords declared with `defdyn`.</span>
<span class="s">  Use this to prevent keyword collisions between dynamic bindings.``</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*out*</span><span class="w"> </span><span class="s">&quot;Where normal print functions print output to.&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*err*</span><span class="w"> </span><span class="s">&quot;Where error printing prints output to.&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*redef*</span><span class="w"> </span><span class="s">&quot;When set, allow dynamically rebinding top level defs. Will slow generated code and is intended to be used for development.&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*debug*</span><span class="w"> </span><span class="s">&quot;Enables a built in debugger on errors and other useful features for debugging in a repl.&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*exit*</span><span class="w"> </span><span class="s">&quot;When set, will cause the current context to complete. Can be set to exit from repl (or file), for example.&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*exit-value*</span><span class="w"> </span><span class="s">&quot;Set the return value from `run-context` upon an exit. By default, `run-context` will return nil.&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*task-id*</span><span class="w"> </span><span class="s">&quot;When spawning a thread or fiber, the task-id can be assigned for concurrency control.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*macro-form*</span>
<span class="w">  </span><span class="s">&quot;Inside a macro, is bound to the source form that invoked the macro&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*lint-error*</span>
<span class="w">  </span><span class="s">&quot;The current lint error level. The error level is the lint level at which compilation will exit with an error and not continue.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*lint-warn*</span>
<span class="w">  </span><span class="s">&quot;The current lint warning level. The warning level is the lint level at which and error will be printed but compilation will continue as normal.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*lint-levels*</span>
<span class="w">  </span><span class="s">&quot;A table of keyword alias to numbers denoting a lint level. Can be used to provided custom aliases for numeric lint levels.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*current-file*</span>
<span class="w">  </span><span class="s">&quot;Bound to the name of the currently compiling file.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">tracev</span>
<span class="w">  </span><span class="s">`Print to stderr a value and a description of the form that produced that value.</span>
<span class="s">  Evaluates to x.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">l</span><span class="w"> </span><span class="nv">c</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/sourcemap </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*macro-form*</span><span class="w"> </span><span class="p">())))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">cf</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*current-file*</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">fmt-1</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">cf</span><span class="w"> </span><span class="p">(</span><span class="nb">string/format </span><span class="s">&quot;trace [%s]&quot;</span><span class="w"> </span><span class="nv">cf</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;trace&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">fmt-2</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">c</span><span class="p">))</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">string/format </span><span class="s">&quot; on line %d, column %d:&quot;</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="nv">c</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">fmt</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="nv">fmt-1</span><span class="w"> </span><span class="nv">fmt-2</span><span class="w"> </span><span class="s">&quot; %j is &quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="nv">upscope</span>
<span class="w">     </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">s</span><span class="w"> </span><span class="o">,</span><span class="nv">x</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="o">,</span><span class="nb">eprinf </span><span class="o">,</span><span class="nv">fmt</span><span class="w"> </span><span class="o">&#39;,</span><span class="nv">x</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="o">,</span><span class="nb">eprintf </span><span class="p">(</span><span class="o">,</span><span class="nb">dyn </span><span class="no">:pretty-format</span><span class="w"> </span><span class="s">&quot;%q&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">s</span><span class="p">)</span>
<span class="w">     </span><span class="o">,</span><span class="nv">s</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">keep-syntax</span>
<span class="w">  </span><span class="s">``Creates a tuple with the tuple type and sourcemap of `before` but the</span>
<span class="s">  elements of `after`. If either one of its arguments is not a tuple, returns</span>
<span class="s">  `after` unmodified. Useful to preserve syntactic information when transforming</span>
<span class="s">  an ast in macros.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">before</span><span class="w"> </span><span class="nv">after</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">before</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="nb">= </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">after</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:parens</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/type </span><span class="nv">before</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">after</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple/brackets </span><span class="o">;</span><span class="nv">after</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">tuple/setmap </span><span class="nv">res</span><span class="w"> </span><span class="o">;</span><span class="p">(</span><span class="nb">tuple/sourcemap </span><span class="nv">before</span><span class="p">)))</span>
<span class="w">    </span><span class="nv">after</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">keep-syntax!</span>
<span class="w">  </span><span class="s">``Like `keep-syntax`, but if `after` is an array, it is coerced into a tuple.</span>
<span class="s">  Useful to preserve syntactic information when transforming an ast in macros.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">before</span><span class="w"> </span><span class="nv">after</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">keep-syntax </span><span class="nv">before</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:array</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">after</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">after</span><span class="p">)</span>
<span class="w">                        </span><span class="nv">after</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">-&gt;</span>
<span class="w">  </span><span class="s">``Threading macro. Inserts x as the second value in the first form</span>
<span class="s">  in `forms`, and inserts the modified first form into the second form</span>
<span class="s">  in the same manner, and so on. Useful for expressing pipelines of data.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">forms</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">fop</span><span class="w"> </span><span class="p">[</span><span class="nb">last </span><span class="nv">n</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">h</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">n</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple </span><span class="p">(</span><span class="nb">in </span><span class="nv">n</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">array/slice </span><span class="nv">n</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple </span><span class="nv">n</span><span class="w"> </span><span class="p">@[])))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">parts</span><span class="w"> </span><span class="p">(</span><span class="nb">array/concat </span><span class="p">@[</span><span class="nv">h</span><span class="w"> </span><span class="nv">last</span><span class="p">]</span><span class="w"> </span><span class="nv">t</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">keep-syntax! </span><span class="nv">n</span><span class="w"> </span><span class="nv">parts</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">reduce </span><span class="nv">fop</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">forms</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">-&gt;&gt;</span>
<span class="w">  </span><span class="s">``Threading macro. Inserts x as the last value in the first form</span>
<span class="s">  in `forms`, and inserts the modified first form into the second form</span>
<span class="s">  in the same manner, and so on. Useful for expressing pipelines of data.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">forms</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">fop</span><span class="w"> </span><span class="p">[</span><span class="nb">last </span><span class="nv">n</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">h</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">n</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple </span><span class="p">(</span><span class="nb">in </span><span class="nv">n</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">array/slice </span><span class="nv">n</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple </span><span class="nv">n</span><span class="w"> </span><span class="p">@[])))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">parts</span><span class="w"> </span><span class="p">(</span><span class="nb">array/concat </span><span class="p">@[</span><span class="nv">h</span><span class="p">]</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="p">@[</span><span class="nv">last</span><span class="p">]))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">keep-syntax! </span><span class="nv">n</span><span class="w"> </span><span class="nv">parts</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">reduce </span><span class="nv">fop</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">forms</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">-?&gt;</span>
<span class="w">  </span><span class="s">``Short circuit threading macro. Inserts x as the second value in the first form</span>
<span class="s">  in `forms`, and inserts the modified first form into the second form</span>
<span class="s">  in the same manner, and so on. The pipeline will return nil</span>
<span class="s">  if an intermediate value is nil.</span>
<span class="s">  Useful for expressing pipelines of data.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">forms</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">fop</span><span class="w"> </span><span class="p">[</span><span class="nb">last </span><span class="nv">n</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">h</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">n</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple </span><span class="p">(</span><span class="nb">in </span><span class="nv">n</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">array/slice </span><span class="nv">n</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple </span><span class="nv">n</span><span class="w"> </span><span class="p">@[])))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">sym</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">parts</span><span class="w"> </span><span class="p">(</span><span class="nb">array/concat </span><span class="p">@[</span><span class="nv">h</span><span class="w"> </span><span class="nv">sym</span><span class="p">]</span><span class="w"> </span><span class="nv">t</span><span class="p">))</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="o">,</span><span class="nv">sym</span><span class="w"> </span><span class="o">,</span><span class="nv">last</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">sym</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nb">keep-syntax! </span><span class="nv">n</span><span class="w"> </span><span class="nv">parts</span><span class="p">))))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">reduce </span><span class="nv">fop</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">forms</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">-?&gt;&gt;</span>
<span class="w">  </span><span class="s">``Short circuit threading macro. Inserts x as the last value in the first form</span>
<span class="s">  in `forms`, and inserts the modified first form into the second form</span>
<span class="s">  in the same manner, and so on. The pipeline will return nil</span>
<span class="s">  if an intermediate value is nil.</span>
<span class="s">  Useful for expressing pipelines of data.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">forms</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">fop</span><span class="w"> </span><span class="p">[</span><span class="nb">last </span><span class="nv">n</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">h</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">n</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple </span><span class="p">(</span><span class="nb">in </span><span class="nv">n</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">array/slice </span><span class="nv">n</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">tuple </span><span class="nv">n</span><span class="w"> </span><span class="p">@[])))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">sym</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">parts</span><span class="w"> </span><span class="p">(</span><span class="nb">array/concat </span><span class="p">@[</span><span class="nv">h</span><span class="p">]</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="p">@[</span><span class="nv">sym</span><span class="p">]))</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="o">,</span><span class="nv">sym</span><span class="w"> </span><span class="o">,</span><span class="nv">last</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">sym</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nb">keep-syntax! </span><span class="nv">n</span><span class="w"> </span><span class="nv">parts</span><span class="p">))))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">reduce </span><span class="nv">fop</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">forms</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">walk-ind</span><span class="w"> </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">form</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="nv">form</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">walk-dict</span><span class="w"> </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">form</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="nv">form</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">form</span><span class="w"> </span><span class="nv">k</span><span class="p">))))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">walk</span>
<span class="w">  </span><span class="s">``Iterate over the values in ast and apply `f`</span>
<span class="s">  to them. Collect the results in a data structure. If ast is not a</span>
<span class="s">  table, struct, array, or tuple,</span>
<span class="s">  returns form.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">form</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">type </span><span class="nv">form</span><span class="p">)</span>
<span class="w">    </span><span class="no">:table</span><span class="w"> </span><span class="p">(</span><span class="nv">walk-dict</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">form</span><span class="p">)</span>
<span class="w">    </span><span class="no">:struct</span><span class="w"> </span><span class="p">(</span><span class="nb">table/to-struct </span><span class="p">(</span><span class="nv">walk-dict</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">form</span><span class="p">))</span>
<span class="w">    </span><span class="no">:array</span><span class="w"> </span><span class="p">(</span><span class="nv">walk-ind</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">form</span><span class="p">)</span>
<span class="w">    </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nb">keep-syntax! </span><span class="nv">form</span><span class="w"> </span><span class="p">(</span><span class="nv">walk-ind</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">form</span><span class="p">))</span>
<span class="w">    </span><span class="nv">form</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">postwalk</span>
<span class="w">  </span><span class="s">``Do a post-order traversal of a data structure and call `(f x)`</span>
<span class="s">  on every visitation.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">form</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">walk </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">postwalk </span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span><span class="w"> </span><span class="nv">form</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">prewalk</span>
<span class="w">  </span><span class="s">&quot;Similar to `postwalk`, but do pre-order traversal.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">form</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">walk </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">prewalk </span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">form</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">as-&gt;</span>
<span class="w">  </span><span class="s">``Thread forms together, replacing `as` in `forms` with the value</span>
<span class="s">  of the previous form. The first form is the value x. Returns the</span>
<span class="s">  last value.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">forms</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">prev</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">form</span><span class="w"> </span><span class="nv">forms</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">sym</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">next-prev</span><span class="w"> </span><span class="p">(</span><span class="nb">postwalk </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">y</span><span class="w"> </span><span class="nv">as</span><span class="p">)</span><span class="w"> </span><span class="nv">sym</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span><span class="w"> </span><span class="nv">form</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">prev</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="o">,</span><span class="nv">sym</span><span class="w"> </span><span class="o">,</span><span class="nv">prev</span><span class="p">]</span><span class="w"> </span><span class="o">,</span><span class="nv">next-prev</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">prev</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">as?-&gt;</span>
<span class="w">  </span><span class="s">``Thread forms together, replacing `as` in `forms` with the value</span>
<span class="s">  of the previous form. The first form is the value x. If any</span>
<span class="s">  intermediate values are falsey, return nil; otherwise, returns the</span>
<span class="s">  last value.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">forms</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">prev</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">form</span><span class="w"> </span><span class="nv">forms</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">sym</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">next-prev</span><span class="w"> </span><span class="p">(</span><span class="nb">postwalk </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">y</span><span class="w"> </span><span class="nv">as</span><span class="p">)</span><span class="w"> </span><span class="nv">sym</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span><span class="w"> </span><span class="nv">form</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">prev</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="o">,</span><span class="nv">sym</span><span class="w"> </span><span class="o">,</span><span class="nv">prev</span><span class="p">]</span><span class="w"> </span><span class="o">,</span><span class="nv">next-prev</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">prev</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">with-dyns</span>
<span class="w">  </span><span class="s">`Run a block of code in a new fiber that has some</span>
<span class="s">  dynamic bindings set. The fiber will not mask errors</span>
<span class="s">  or signals, but the dynamic bindings will be properly</span>
<span class="s">  unset, as dynamic bindings are fiber-local.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">bindings</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">dyn-forms</span>
<span class="w">    </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">bindings</span><span class="p">)</span><span class="w"> </span><span class="mf">2</span><span class="p">]]</span>
<span class="w">      </span><span class="o">~</span><span class="p">(</span><span class="nb">setdyn </span><span class="o">,</span><span class="p">(</span><span class="nv">bindings</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nv">bindings</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)))))</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="o">,</span><span class="nb">resume </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/new </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="o">,;</span><span class="nv">dyn-forms</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="no">:p</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">with-vars</span>
<span class="w">  </span><span class="s">``Evaluates `body` with each var in `vars` temporarily bound. Similar signature to</span>
<span class="s">  `let`, but each binding must be a var.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">vars</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">vars</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">unless </span><span class="p">(</span><span class="nb">even? </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">error </span><span class="s">&quot;expected even number of argument to vars&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">temp</span><span class="w"> </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="mf">2</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">saveold</span><span class="w"> </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="mf">2</span><span class="p">]]</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="k">def </span><span class="p">(</span><span class="nv">temp</span><span class="w"> </span><span class="p">(</span><span class="nb">/ </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nv">vars</span><span class="w"> </span><span class="nv">i</span><span class="p">)]))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">setnew</span><span class="w"> </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="mf">2</span><span class="p">]]</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="k">set </span><span class="p">(</span><span class="nv">vars</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">vars</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">))]))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">restoreold</span><span class="w"> </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="mf">2</span><span class="p">]]</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="k">set </span><span class="p">(</span><span class="nv">vars</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">temp</span><span class="w"> </span><span class="p">(</span><span class="nb">/ </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">))]))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">ret</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">s</span><span class="p">]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">       </span><span class="o">,;</span><span class="nv">saveold</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/new </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="o">,;</span><span class="nv">setnew</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="no">:ti</span><span class="p">))</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">resume </span><span class="o">,</span><span class="nv">f</span><span class="p">))</span>
<span class="w">       </span><span class="o">,;</span><span class="nv">restoreold</span>
<span class="w">       </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="o">,</span><span class="nb">fiber/status </span><span class="o">,</span><span class="nv">f</span><span class="p">)</span><span class="w"> </span><span class="no">:dead</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">propagate </span><span class="o">,</span><span class="nv">ret</span><span class="w"> </span><span class="o">,</span><span class="nv">f</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">partial</span>
<span class="w">  </span><span class="s">&quot;Partial function application.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">more</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">zero? </span><span class="p">(</span><span class="nb">length </span><span class="nv">more</span><span class="p">))</span><span class="w"> </span><span class="nv">f</span>
<span class="w">    </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">r</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="o">;</span><span class="nv">more</span><span class="w"> </span><span class="o">;</span><span class="nv">r</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">every?</span>
<span class="w">  </span><span class="s">``Evaluates to the last element of `ind` if all preceding elements are truthy,</span>
<span class="s">  otherwise evaluates to the first falsey element.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="no">:while</span><span class="w"> </span><span class="nv">res</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">res</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">any?</span>
<span class="w">  </span><span class="s">``Evaluates to the last element of `ind` if all preceding elements are falsey,</span>
<span class="s">  otherwise evaluates to the first truthy element.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="no">:until</span><span class="w"> </span><span class="nv">res</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">res</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">reverse!</span>
<span class="w">  </span><span class="s">`Reverses the order of the elements in a given array or buffer and returns it</span>
<span class="s">  mutated.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">t</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">j</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nb">-- </span><span class="nv">j</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">ti</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">t</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="nv">j</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">t</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="nv">ti</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">++ </span><span class="nv">i</span><span class="p">))</span>
<span class="w">  </span><span class="nv">t</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">reverse</span>
<span class="w">  </span><span class="s">`Reverses the order of the elements in a given array or tuple and returns</span>
<span class="s">  a new array. If a string or buffer is provided, returns a buffer instead.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">t</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">lengthable? </span><span class="nv">t</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">t</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">bytes? </span><span class="nv">t</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">buffer/new-filled </span><span class="nv">n</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">array/new-filled </span><span class="nv">n</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">each </span><span class="nv">v</span><span class="w"> </span><span class="nv">t</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">-- </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="nv">v</span><span class="p">))</span>
<span class="w">      </span><span class="nv">ret</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">reverse! </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">v</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="nv">v</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">invert</span>
<span class="w">  </span><span class="s">``Given an associative data structure `ds`, returns a new table where the</span>
<span class="s">  keys of `ds` are the values, and the values are the keys. If multiple keys</span>
<span class="s">  in `ds` are mapped to the same value, only one of those values will</span>
<span class="s">  become a key in the returned table.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ds</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="nv">ds</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ds</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">zipcoll</span>
<span class="w">  </span><span class="s">`Creates a table from two arrays/tuples.</span>
<span class="s">  Returns a new table.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ks</span><span class="w"> </span><span class="nv">vs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">kk</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">vk</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="kc">true</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">kk</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ks</span><span class="w"> </span><span class="nv">kk</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">kk</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">vk</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">vs</span><span class="w"> </span><span class="nv">vk</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">vk</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ks</span><span class="w"> </span><span class="nv">kk</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">vs</span><span class="w"> </span><span class="nv">vk</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">get-in</span>
<span class="w">  </span><span class="s">``Access a value in a nested data structure. Looks into the data structure via</span>
<span class="s">  a sequence of keys. If value is not found, and `dflt` is provided, returns `dflt`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ds</span><span class="w"> </span><span class="nv">ks</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">dflt</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">d</span><span class="w"> </span><span class="nv">ds</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">ks</span><span class="w"> </span><span class="no">:while</span><span class="w"> </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="kc">nil</span><span class="nv">?</span><span class="w"> </span><span class="nv">d</span><span class="p">))]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">d</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">d</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">d</span><span class="p">)</span><span class="w"> </span><span class="nv">dflt</span><span class="w"> </span><span class="nv">d</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">update-in</span>
<span class="w">  </span><span class="s">``Update a value in a nested data structure `ds`. Looks into `ds` via a sequence of keys,</span>
<span class="s">  and replaces the value found there with `f` applied to that value.</span>
<span class="s">  Missing data structures will be replaced with tables. Returns</span>
<span class="s">  the modified, original data structure.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ds</span><span class="w"> </span><span class="nv">ks</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">d</span><span class="w"> </span><span class="nv">ds</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len-1</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">ks</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">len-1</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">error </span><span class="s">&quot;expected at least 1 key in ks&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="nv">len-1</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">ks</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">v</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">d</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">v</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">newv</span><span class="w"> </span><span class="p">(</span><span class="nv">table</span><span class="p">)]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put </span><span class="nv">d</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="nv">newv</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="nv">d</span><span class="w"> </span><span class="nv">newv</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">d</span><span class="w"> </span><span class="nv">v</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">last-key</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">ks</span><span class="w"> </span><span class="nv">len-1</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">last-val</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">d</span><span class="w"> </span><span class="nv">last-key</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">put </span><span class="nv">d</span><span class="w"> </span><span class="nv">last-key</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">last-val</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">))</span>
<span class="w">  </span><span class="nv">ds</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">put-in</span>
<span class="w">  </span><span class="s">``Put a value into a nested data structure `ds`. Looks into `ds` via</span>
<span class="s">  a sequence of keys. Missing data structures will be replaced with tables. Returns</span>
<span class="s">  the modified, original data structure.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ds</span><span class="w"> </span><span class="nv">ks</span><span class="w"> </span><span class="nv">v</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">d</span><span class="w"> </span><span class="nv">ds</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len-1</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">ks</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">len-1</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">error </span><span class="s">&quot;expected at least 1 key in ks&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="nv">len-1</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">ks</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">v</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">d</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">v</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">newv</span><span class="w"> </span><span class="p">(</span><span class="nv">table</span><span class="p">)]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put </span><span class="nv">d</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="nv">newv</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="nv">d</span><span class="w"> </span><span class="nv">newv</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">d</span><span class="w"> </span><span class="nv">v</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">last-key</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">ks</span><span class="w"> </span><span class="nv">len-1</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">last-val</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">d</span><span class="w"> </span><span class="nv">last-key</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">put </span><span class="nv">d</span><span class="w"> </span><span class="nv">last-key</span><span class="w"> </span><span class="nv">v</span><span class="p">)</span>
<span class="w">  </span><span class="nv">ds</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">update</span>
<span class="w">  </span><span class="s">``For a given key in data structure `ds`, replace its corresponding value with the</span>
<span class="s">  result of calling `func` on that value. If `args` are provided, they will be passed</span>
<span class="s">  along to `func` as well. Returns `ds`, updated.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ds</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="nv">func</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">old</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">ds</span><span class="w"> </span><span class="nv">key</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">put </span><span class="nv">ds</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="p">(</span><span class="nv">func</span><span class="w"> </span><span class="nv">old</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">merge-into</span>
<span class="w">  </span><span class="s">``Merges multiple tables/structs into table `tab`. If a key appears in more than one</span>
<span class="s">  collection in `colls`, then later values replace any previous ones. Returns `tab`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">tab</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">colls</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">c</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">colls</span>
<span class="w">         </span><span class="nv">key</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="nv">c</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">tab</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">c</span><span class="w"> </span><span class="nv">key</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">tab</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">merge</span>
<span class="w">  </span><span class="s">``Merges multiple tables/structs into one new table. If a key appears in more than one</span>
<span class="s">  collection in `colls`, then later values replace any previous ones.</span>
<span class="s">  Returns the new table.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">colls</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">container</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">c</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">colls</span>
<span class="w">         </span><span class="nv">key</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="nv">c</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">container</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">c</span><span class="w"> </span><span class="nv">key</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">container</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">keys</span>
<span class="w">  </span><span class="s">&quot;Get the keys of an associative data structure.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">lengthable? </span><span class="nv">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">arr</span><span class="w"> </span><span class="p">(</span><span class="nb">array/new-filled </span><span class="p">(</span><span class="nb">length </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eachk </span><span class="nv">k</span><span class="w"> </span><span class="nv">x</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put </span><span class="nv">arr</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">++ </span><span class="nv">i</span><span class="p">))</span>
<span class="w">      </span><span class="nv">arr</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">values</span>
<span class="w">  </span><span class="s">&quot;Get the values of an associative data structure.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">lengthable? </span><span class="nv">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">arr</span><span class="w"> </span><span class="p">(</span><span class="nb">array/new-filled </span><span class="p">(</span><span class="nb">length </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">each </span><span class="nv">v</span><span class="w"> </span><span class="nv">x</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put </span><span class="nv">arr</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">v</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">++ </span><span class="nv">i</span><span class="p">))</span>
<span class="w">      </span><span class="nv">arr</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">v</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="nv">v</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">pairs</span>
<span class="w">  </span><span class="s">&quot;Get the key-value pairs of an associative data structure.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">lengthable? </span><span class="nv">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">arr</span><span class="w"> </span><span class="p">(</span><span class="nb">array/new-filled </span><span class="p">(</span><span class="nb">length </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eachp </span><span class="nv">p</span><span class="w"> </span><span class="nv">x</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put </span><span class="nv">arr</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">++ </span><span class="nv">i</span><span class="p">))</span>
<span class="w">      </span><span class="nv">arr</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">p</span><span class="w"> </span><span class="no">:pairs</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="nv">p</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">frequencies</span>
<span class="w">  </span><span class="s">&quot;Get the number of occurrences of each value in an indexed data structure.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">freqs</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="nv">ind</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">freqs</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="p">(</span><span class="nv">freqs</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="mf">1</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">freqs</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">group-by</span>
<span class="w">  </span><span class="s">``Group elements of `ind` by a function `f` and put the results into a new table. The keys of</span>
<span class="s">  the table are the distinct return values from calling `f` on the elements of `ind`. The values</span>
<span class="s">  of the table are arrays of all elements of `ind` for which `f` called on the element equals</span>
<span class="s">  that corresponding key.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="nv">ind</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">y</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">arr</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">ret</span><span class="w"> </span><span class="nv">y</span><span class="p">)]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">arr</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">put </span><span class="nv">ret</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="p">@[</span><span class="nv">x</span><span class="p">])))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">partition-by</span>
<span class="w">  </span><span class="s">``Partition elements of a sequential data structure by a representative function `f`. Partitions</span>
<span class="s">  split when `(f x)` changes values when iterating to the next element `x` of `ind`. Returns a new array</span>
<span class="s">  of arrays.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">span</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">category</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">is-new</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="nv">ind</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">y</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">      </span><span class="nv">is-new</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">set </span><span class="nv">is-new</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">category</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">span</span><span class="w"> </span><span class="p">@[</span><span class="nv">x</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="nv">span</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">= </span><span class="nv">y</span><span class="w"> </span><span class="nv">category</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">span</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">set </span><span class="nv">category</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">span</span><span class="w"> </span><span class="p">@[</span><span class="nv">x</span><span class="p">])</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="nv">span</span><span class="p">))))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">interleave</span>
<span class="w">  </span><span class="s">&quot;Returns an array of the first elements of each col, then the second elements, etc.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">cols</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">mapcat tuple </span><span class="o">;</span><span class="nv">cols</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">distinct</span>
<span class="w">  </span><span class="s">&quot;Returns an array of the deduplicated values in `xs`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">seen</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="nv">xs</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">in </span><span class="nv">seen</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">put </span><span class="nv">seen</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="nv">x</span><span class="p">))))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">flatten-into</span>
<span class="w">  </span><span class="s">``Takes a nested array (tree) `xs` and appends the depth first traversal of</span>
<span class="s">  `xs` to array `into`. Returns `into`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">into</span><span class="w"> </span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="nv">xs</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">indexed? </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">flatten-into </span><span class="nv">into</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">into</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">into</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">flatten</span>
<span class="w">  </span><span class="s">``Takes a nested array (tree) `xs` and returns the depth first traversal of</span>
<span class="s">  it. Returns a new array.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">xs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">flatten-into </span><span class="p">@[]</span><span class="w"> </span><span class="nv">xs</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">kvs</span>
<span class="w">  </span><span class="s">``Takes a table or struct and returns and array of key value pairs</span>
<span class="s">  like `@[k v k v ...]`. Returns a new array.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">dict</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="nv">dict</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">dict</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">from-pairs</span>
<span class="w">  </span><span class="s">``Takes a sequence of pairs and creates a table from each pair. It is the inverse of</span>
<span class="s">  `pairs` on a table. Returns a new table.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ps</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="nv">ps</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">ret</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">interpose</span>
<span class="w">  </span><span class="s">``Returns a sequence of the elements of `ind` separated by</span>
<span class="s">  `sep`. Returns a new array.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">sep</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">lengthable? </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">array/new-filled </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">* </span><span class="mf">2</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">ind</span><span class="p">))</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nv">sep</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">var </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">put </span><span class="nv">ret</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="k">set </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">+= </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span>
<span class="w">        </span><span class="nv">ret</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">@[(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="nv">sep</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">ind</span><span class="w"> </span><span class="nv">k</span><span class="p">)))</span>
<span class="w">        </span><span class="nv">ret</span><span class="p">))</span>
<span class="w">    </span><span class="p">@[]))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">partition-slice</span>
<span class="w">  </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="p">[</span><span class="nv">start</span><span class="w"> </span><span class="nv">end</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="nv">n</span><span class="p">])</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">ind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">parts</span><span class="w"> </span><span class="p">(</span><span class="nb">div </span><span class="nv">len</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">array/new-filled </span><span class="nv">parts</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">forv </span><span class="nv">k</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="nv">parts</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">ret</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">end</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">start</span><span class="w"> </span><span class="nv">end</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+= </span><span class="nv">end</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">start</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">start</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">partition</span>
<span class="w">  </span><span class="s">``Partition an indexed data structure `ind` into tuples</span>
<span class="s">  of size `n`. Returns a new array.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">    </span><span class="p">(</span><span class="nb">indexed? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">partition-slice</span><span class="w"> </span><span class="nb">tuple/slice </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">bytes? </span><span class="nv">ind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">partition-slice</span><span class="w"> </span><span class="nb">string/slice </span><span class="nv">n</span><span class="w"> </span><span class="nv">ind</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">partition-slice</span><span class="w"> </span><span class="nb">tuple/slice </span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="nb">values </span><span class="nv">ind</span><span class="p">))))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### IO Helpers</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">slurp</span>
<span class="w">  </span><span class="s">``Read all data from a file with name `path` and then close the file.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">path</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">file/open </span><span class="nv">path</span><span class="w"> </span><span class="no">:rb</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">if-not </span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;could not open file &quot;</span><span class="w"> </span><span class="nv">path</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">contents</span><span class="w"> </span><span class="p">(</span><span class="nb">file/read </span><span class="nv">f</span><span class="w"> </span><span class="no">:all</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">file/close </span><span class="nv">f</span><span class="p">)</span>
<span class="w">  </span><span class="nv">contents</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">spit</span>
<span class="w">  </span><span class="s">``Write `contents` to a file at `path`. Can optionally append to the file.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">contents</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">mode</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">mode</span><span class="w"> </span><span class="no">:wb</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">file/open </span><span class="nv">path</span><span class="w"> </span><span class="nv">mode</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">if-not </span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;could not open file &quot;</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="s">&quot; with mode &quot;</span><span class="w"> </span><span class="nv">mode</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">file/write </span><span class="nv">f</span><span class="w"> </span><span class="nv">contents</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">file/close </span><span class="nv">f</span><span class="p">)</span>
<span class="w">  </span><span class="kc">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*pretty-format*</span>
<span class="w">  </span><span class="s">&quot;Format specifier for the `pp` function&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">pp</span>
<span class="w">  </span><span class="s">``Pretty-print to stdout or `(dyn *out*)`. The format string used is `(dyn *pretty-format* &quot;%q&quot;)`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">printf </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*pretty-format*</span><span class="w"> </span><span class="s">&quot;%q&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">flush</span><span class="p">))</span>


<span class="p">(</span><span class="nb">defn </span><span class="nv">file/lines</span>
<span class="w">  </span><span class="s">&quot;Return an iterator over the lines of a file.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">file</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">coro</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="k">def </span><span class="nv">line</span><span class="w"> </span><span class="p">(</span><span class="nb">file/read </span><span class="nv">file</span><span class="w"> </span><span class="no">:line</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">yield </span><span class="nv">line</span><span class="p">))))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Pattern Matching</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">match</span>
<span class="w">  </span><span class="s">```</span>
<span class="s">  Pattern matching. Match an expression `x` against any number of cases.</span>
<span class="s">  Each case is a pattern to match against, followed by an expression to</span>
<span class="s">  evaluate to if that case is matched.  Legal patterns are:</span>

<span class="s">  * symbol -- a pattern that is a symbol will match anything, binding `x`&#39;s</span>
<span class="s">    value to that symbol.</span>

<span class="s">  * array or bracket tuple -- an array or bracket tuple will match only if</span>
<span class="s">    all of its elements match the corresponding elements in `x`.</span>
<span class="s">    Use `&amp; rest` at the end of an array or bracketed tuple to bind all remaining values to `rest`.</span>

<span class="s">  * table or struct -- a table or struct will match if all values match with</span>
<span class="s">    the corresponding values in `x`.</span>

<span class="s">  * tuple -- a tuple pattern will match if its first element matches, and the</span>
<span class="s">    following elements are treated as predicates and are true.</span>

<span class="s">  * `_` symbol -- the last special case is the `_` symbol, which is a wildcard</span>
<span class="s">    that will match any value without creating a binding.</span>

<span class="s">  While a symbol pattern will ordinarily match any value, the pattern `(@ &lt;sym&gt;)`,</span>
<span class="s">  where &lt;sym&gt; is any symbol, will attempt to match `x` against a value</span>
<span class="s">  already bound to `&lt;sym&gt;`, rather than matching and rebinding it.</span>

<span class="s">  Any other value pattern will only match if it is equal to `x`.</span>
<span class="s">  Quoting a pattern with `&#39;` will also treat the value as a literal value to match against.</span>

<span class="s">  ```</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">cases</span><span class="p">]</span>

<span class="w">  </span><span class="c1"># Partition body into sections.</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">oddlen</span><span class="w"> </span><span class="p">(</span><span class="nb">odd? </span><span class="p">(</span><span class="nb">length </span><span class="nv">cases</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">else</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">oddlen</span><span class="w"> </span><span class="p">(</span><span class="nb">last </span><span class="nv">cases</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">patterns</span><span class="w"> </span><span class="p">(</span><span class="nb">partition </span><span class="mf">2</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">oddlen</span><span class="w"> </span><span class="p">(</span><span class="nb">slice </span><span class="nv">cases</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="mf">-2</span><span class="p">)</span><span class="w"> </span><span class="nv">cases</span><span class="p">)))</span>

<span class="w">  </span><span class="c1"># Keep an array for accumulating the compilation output</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">x-sym</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">idempotent? </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">accum</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not= </span><span class="nv">x</span><span class="w"> </span><span class="nv">x-sym</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">accum</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="k">def </span><span class="nv">x-sym</span><span class="w"> </span><span class="nv">x</span><span class="p">]))</span>

<span class="w">  </span><span class="c1"># Table of gensyms</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">symbols</span><span class="w"> </span><span class="p">@{[</span><span class="kc">nil</span><span class="w"> </span><span class="kc">nil</span><span class="p">]</span><span class="w"> </span><span class="nv">x-sym</span><span class="p">})</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">length-symbols</span><span class="w"> </span><span class="p">@{})</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">emit</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">accum</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">emit-branch</span><span class="w"> </span><span class="p">[</span><span class="nv">condition</span><span class="w"> </span><span class="nv">result</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">accum</span><span class="w"> </span><span class="no">:branch</span><span class="w"> </span><span class="nv">condition</span><span class="w"> </span><span class="nv">result</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">get-sym</span>
<span class="w">    </span><span class="p">[</span><span class="nv">parent-sym</span><span class="w"> </span><span class="nv">key</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">symbol-key</span><span class="w"> </span><span class="p">[</span><span class="nv">parent-sym</span><span class="w"> </span><span class="nv">key</span><span class="p">])</span>
<span class="w">    </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">get </span><span class="nv">symbols</span><span class="w"> </span><span class="nv">symbol-key</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)]</span>
<span class="w">          </span><span class="p">(</span><span class="nb">put </span><span class="nv">symbols</span><span class="w"> </span><span class="nv">symbol-key</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nv">emit</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="k">def </span><span class="nv">s</span><span class="w"> </span><span class="p">[</span><span class="nb">get </span><span class="nv">parent-sym</span><span class="w"> </span><span class="nv">key</span><span class="p">]])</span>
<span class="w">          </span><span class="nv">s</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">get-length-sym</span>
<span class="w">    </span><span class="p">[</span><span class="nv">parent-sym</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">get </span><span class="nv">length-symbols</span><span class="w"> </span><span class="nv">parent-sym</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">)]</span>
<span class="w">          </span><span class="p">(</span><span class="nb">put </span><span class="nv">length-symbols</span><span class="w"> </span><span class="nv">parent-sym</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nv">emit</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="k">def </span><span class="nv">s</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="k">if </span><span class="p">[</span><span class="nb">indexed? </span><span class="nv">parent-sym</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="nb">length </span><span class="nv">parent-sym</span><span class="p">]]])</span>
<span class="w">          </span><span class="nv">s</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">visit-pattern-1</span>
<span class="w">    </span><span class="p">[</span><span class="nv">b2g</span><span class="w"> </span><span class="nv">parent-sym</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="nv">pattern</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">pattern</span><span class="w"> </span><span class="o">&#39;</span><span class="nv">_</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nv">get-sym</span><span class="w"> </span><span class="nv">parent-sym</span><span class="w"> </span><span class="nv">key</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">t</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">pattern</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">isarr</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:array</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:tuple</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">tuple/type </span><span class="nv">pattern</span><span class="p">)</span><span class="w"> </span><span class="no">:brackets</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">cond</span>

<span class="w">      </span><span class="c1"># match local binding</span>
<span class="w">      </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:symbol</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">b2g</span><span class="w"> </span><span class="nv">pattern</span><span class="p">)]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">x</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put </span><span class="nv">b2g</span><span class="w"> </span><span class="nv">pattern</span><span class="w"> </span><span class="p">@[</span><span class="nv">s</span><span class="p">]))</span>

<span class="w">      </span><span class="c1"># match quoted literal</span>
<span class="w">      </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:tuple</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="mf">2</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">pattern</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="o">&#39;</span><span class="k">quote </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">break</span><span class="p">)</span>

<span class="w">      </span><span class="c1"># match data structure template</span>
<span class="w">      </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:struct</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:table</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eachp </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">sub-pattern</span><span class="p">]</span><span class="w"> </span><span class="nv">pattern</span>
<span class="w">        </span><span class="p">(</span><span class="nv">visit-pattern-1</span><span class="w"> </span><span class="nv">b2g</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">sub-pattern</span><span class="p">))</span>

<span class="w">      </span><span class="nv">isarr</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="nv">get-length-sym</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">eachp </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">sub-pattern</span><span class="p">]</span><span class="w"> </span><span class="nv">pattern</span>
<span class="w">          </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="nv">sub-pattern</span><span class="w"> </span><span class="o">&#39;</span><span class="nv">&amp;</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">length </span><span class="nv">pattern</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nb">errorf </span><span class="s">&quot;expected symbol following &amp; in pattern&quot;</span><span class="p">))</span>

<span class="w">            </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">pattern</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nb">errorf </span><span class="s">&quot;expected a single symbol follow &#39;&amp; in pattern, found %q&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">slice </span><span class="nv">pattern</span><span class="w"> </span><span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))))</span>

<span class="w">            </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">not= </span><span class="p">(</span><span class="nb">type </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)))</span><span class="w"> </span><span class="no">:symbol</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">errorf </span><span class="s">&quot;expected symbol following &amp; in pattern, found %q&quot;</span><span class="w"> </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))))</span>

<span class="w">            </span><span class="p">(</span><span class="nb">put </span><span class="nv">b2g</span><span class="w"> </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">))</span><span class="w"> </span><span class="p">@[[</span><span class="nb">slice </span><span class="nv">s</span><span class="w"> </span><span class="nv">i</span><span class="p">]])</span>
<span class="w">            </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nv">visit-pattern-1</span><span class="w"> </span><span class="nv">b2g</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">sub-pattern</span><span class="p">)))</span>

<span class="w">      </span><span class="c1"># match global unification</span>
<span class="w">      </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:tuple</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="mf">2</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">pattern</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="o">&#39;</span><span class="nv">@</span><span class="w"> </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">break</span><span class="p">)</span>

<span class="w">      </span><span class="c1"># match predicated binding</span>
<span class="w">      </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:tuple</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nb">length </span><span class="nv">pattern</span><span class="p">)</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="nv">visit-pattern-1</span><span class="w"> </span><span class="nv">b2g</span><span class="w"> </span><span class="nv">parent-sym</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="mf">0</span><span class="p">)))))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">visit-pattern-2</span>
<span class="w">    </span><span class="p">[</span><span class="nv">anda</span><span class="w"> </span><span class="nv">gun</span><span class="w"> </span><span class="nv">preds</span><span class="w"> </span><span class="nv">parent-sym</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="nv">pattern</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">pattern</span><span class="w"> </span><span class="o">&#39;</span><span class="nv">_</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nv">get-sym</span><span class="w"> </span><span class="nv">parent-sym</span><span class="w"> </span><span class="nv">key</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">t</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">pattern</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">isarr</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:array</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:tuple</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">tuple/type </span><span class="nv">pattern</span><span class="p">)</span><span class="w"> </span><span class="no">:brackets</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="nv">isarr</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">anda</span><span class="w"> </span><span class="p">(</span><span class="nv">get-length-sym</span><span class="w"> </span><span class="nv">s</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">pattern-len</span>
<span class="w">        </span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">rest-idx</span><span class="w"> </span><span class="p">(</span><span class="nb">find-index </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span><span class="w"> </span><span class="o">&#39;</span><span class="nv">&amp;</span><span class="p">))</span><span class="w"> </span><span class="nv">pattern</span><span class="p">)]</span>
<span class="w">          </span><span class="nv">rest-idx</span>
<span class="w">          </span><span class="p">(</span><span class="nb">length </span><span class="nv">pattern</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">anda</span><span class="w"> </span><span class="p">[</span><span class="nb">&lt;= </span><span class="nv">pattern-len</span><span class="w"> </span><span class="p">(</span><span class="nv">get-length-sym</span><span class="w"> </span><span class="nv">s</span><span class="p">)]))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">cond</span>

<span class="w">      </span><span class="c1"># match data structure template</span>
<span class="w">      </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:struct</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:table</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eachp </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">sub-pattern</span><span class="p">]</span><span class="w"> </span><span class="nv">pattern</span>
<span class="w">        </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">anda</span><span class="w"> </span><span class="p">[</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="nv">get-sym</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="nv">i</span><span class="p">)])</span>
<span class="w">        </span><span class="p">(</span><span class="nv">visit-pattern-2</span><span class="w"> </span><span class="nv">anda</span><span class="w"> </span><span class="nv">gun</span><span class="w"> </span><span class="nv">preds</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">sub-pattern</span><span class="p">))</span>

<span class="w">      </span><span class="nv">isarr</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eachp </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">sub-pattern</span><span class="p">]</span><span class="w"> </span><span class="nv">pattern</span>
<span class="w">        </span><span class="c1"># stop recursing to sub-patterns if the rest sigil is found</span>
<span class="w">        </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="nv">sub-pattern</span><span class="w"> </span><span class="o">&#39;</span><span class="nv">&amp;</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">visit-pattern-2</span><span class="w"> </span><span class="nv">anda</span><span class="w"> </span><span class="nv">gun</span><span class="w"> </span><span class="nv">preds</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">sub-pattern</span><span class="p">))</span>

<span class="w">      </span><span class="c1"># match local binding</span>
<span class="w">      </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:symbol</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)</span>

<span class="w">      </span><span class="c1"># match quoted literal</span>
<span class="w">      </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:tuple</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="mf">2</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">pattern</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="o">&#39;</span><span class="k">quote </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">anda</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="nb">= </span><span class="nv">s</span><span class="w"> </span><span class="nv">pattern</span><span class="p">])</span>

<span class="w">      </span><span class="c1"># match global unification</span>
<span class="w">      </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:tuple</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="mf">2</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">pattern</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="o">&#39;</span><span class="nv">@</span><span class="w"> </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">gun</span><span class="w"> </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="mf">1</span><span class="p">))]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">x</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put </span><span class="nv">gun</span><span class="w"> </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">@[</span><span class="nv">s</span><span class="p">]))</span>

<span class="w">      </span><span class="c1"># match predicated binding</span>
<span class="w">      </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">t</span><span class="w"> </span><span class="no">:tuple</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nb">length </span><span class="nv">pattern</span><span class="p">)</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">preds</span><span class="w"> </span><span class="o">;</span><span class="p">(</span><span class="nb">slice </span><span class="nv">pattern</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">visit-pattern-2</span><span class="w"> </span><span class="nv">anda</span><span class="w"> </span><span class="nv">gun</span><span class="w"> </span><span class="nv">preds</span><span class="w"> </span><span class="nv">parent-sym</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="p">(</span><span class="nv">pattern</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span>

<span class="w">      </span><span class="c1"># match literal</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">anda</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="nb">= </span><span class="nv">s</span><span class="w"> </span><span class="nv">pattern</span><span class="p">])))</span>

<span class="w">  </span><span class="c1"># Compile the patterns</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="p">[</span><span class="nv">pattern</span><span class="w"> </span><span class="nv">expression</span><span class="p">]</span><span class="w"> </span><span class="nv">patterns</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">b2g</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">gun</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">preds</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">    </span><span class="p">(</span><span class="nv">visit-pattern-1</span><span class="w"> </span><span class="nv">b2g</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="nv">pattern</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">anda</span><span class="w"> </span><span class="p">@[</span><span class="o">&#39;</span><span class="nv">and</span><span class="p">])</span>
<span class="w">    </span><span class="p">(</span><span class="nv">visit-pattern-2</span><span class="w"> </span><span class="nv">anda</span><span class="w"> </span><span class="nv">gun</span><span class="w"> </span><span class="nv">preds</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="nv">pattern</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># Local unification</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">unify</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">    </span><span class="p">(</span><span class="nb">each </span><span class="nv">syms</span><span class="w"> </span><span class="nv">b2g</span>
<span class="w">      </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&lt; </span><span class="mf">1</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">syms</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">unify</span><span class="w"> </span><span class="p">[</span><span class="nb">= </span><span class="o">;</span><span class="nv">syms</span><span class="p">])))</span>
<span class="w">    </span><span class="c1"># Global unification</span>
<span class="w">    </span><span class="p">(</span><span class="nb">eachp </span><span class="p">[</span><span class="nv">binding</span><span class="w"> </span><span class="nv">syms</span><span class="p">]</span><span class="w"> </span><span class="nv">gun</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">unify</span><span class="w"> </span><span class="p">[</span><span class="nb">= </span><span class="nv">binding</span><span class="w"> </span><span class="o">;</span><span class="nv">syms</span><span class="p">]))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">sort </span><span class="nv">unify</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">array/concat </span><span class="nv">anda</span><span class="w"> </span><span class="nv">unify</span><span class="p">)</span>
<span class="w">    </span><span class="c1"># Final binding</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">defs</span><span class="w"> </span><span class="p">(</span><span class="nb">seq </span><span class="p">[[</span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">pairs </span><span class="nv">b2g</span><span class="p">))]</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="k">def </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">first </span><span class="nv">v</span><span class="p">)]))</span>
<span class="w">    </span><span class="c1"># Predicates</span>
<span class="w">    </span><span class="p">(</span><span class="nb">unless </span><span class="p">(</span><span class="nb">empty? </span><span class="nv">preds</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">pred-join</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">defs</span><span class="w"> </span><span class="p">(</span><span class="nb">and </span><span class="o">,;</span><span class="nv">preds</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">anda</span><span class="w"> </span><span class="nv">pred-join</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">emit-branch</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">anda</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="k">do </span><span class="o">;</span><span class="nv">defs</span><span class="w"> </span><span class="nv">expression</span><span class="p">]))</span>

<span class="w">  </span><span class="c1"># Expand branches</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">stack</span><span class="w"> </span><span class="p">@[</span><span class="nv">else</span><span class="p">])</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">el</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse </span><span class="nv">accum</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:branch</span><span class="w"> </span><span class="nv">el</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">condition</span><span class="w"> </span><span class="p">(</span><span class="nb">array/pop </span><span class="nv">stack</span><span class="p">)</span>
<span class="w">            </span><span class="nv">truthy</span><span class="w"> </span><span class="p">(</span><span class="nb">array/pop </span><span class="nv">stack</span><span class="p">)</span>
<span class="w">            </span><span class="nv">if-form</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">condition</span><span class="w"> </span><span class="o">,</span><span class="nv">truthy</span>
<span class="w">                       </span><span class="o">,</span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">length </span><span class="nv">stack</span><span class="p">)</span>
<span class="w">                          </span><span class="mf">0</span><span class="w"> </span><span class="kc">nil</span>
<span class="w">                          </span><span class="mf">1</span><span class="w"> </span><span class="p">(</span><span class="nv">stack</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">                          </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="p">(</span><span class="nb">reverse </span><span class="nv">stack</span><span class="p">))))]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">array/remove </span><span class="nv">stack</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">stack</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">stack</span><span class="w"> </span><span class="nv">if-form</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">stack</span><span class="w"> </span><span class="nv">el</span><span class="p">)))</span>

<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="p">(</span><span class="nb">reverse </span><span class="nv">stack</span><span class="p">)))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Macro Expansion</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*macro-lints*</span>
<span class="w">  </span><span class="s">``Bound to an array of lint messages that will be reported by the compiler inside a macro.</span>
<span class="s">  To indicate an error or warning, a macro author should use `maclintf`.``</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">maclintf</span>
<span class="w">  </span><span class="s">``When inside a macro, call this function to add a linter warning. Takes</span>
<span class="s">  a `fmt` argument like `string/format`, which is used to format the message.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">level</span><span class="w"> </span><span class="nv">fmt</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">lints</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*macro-lints*</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="nv">lints</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">form</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*macro-form*</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">l</span><span class="w"> </span><span class="nv">c</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">tuple? </span><span class="nv">form</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/sourcemap </span><span class="nv">form</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="kc">nil</span><span class="w"> </span><span class="kc">nil</span><span class="p">]))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">l</span><span class="w"> </span><span class="p">(</span><span class="nb">if-not </span><span class="p">(</span><span class="nb">= </span><span class="mf">-1</span><span class="w"> </span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="nv">l</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">c</span><span class="w"> </span><span class="p">(</span><span class="nb">if-not </span><span class="p">(</span><span class="nb">= </span><span class="mf">-1</span><span class="w"> </span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="nv">c</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">msg</span><span class="w"> </span><span class="p">(</span><span class="nb">string/format </span><span class="nv">fmt</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">lints</span><span class="w"> </span><span class="p">[</span><span class="nv">level</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="nv">msg</span><span class="p">]))</span>
<span class="w">  </span><span class="kc">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">macex1</span>
<span class="w">  </span><span class="s">``Expand macros in a form, but do not recursively expand macros.</span>
<span class="s">  See `macex` docs for info on `on-binding`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">on-binding</span><span class="p">]</span>

<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="nv">on-binding</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">symbol? </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">break </span><span class="p">(</span><span class="nv">on-binding</span><span class="w"> </span><span class="nv">x</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">recur</span><span class="w"> </span><span class="p">[</span><span class="nv">y</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">macex1 </span><span class="nv">y</span><span class="w"> </span><span class="nv">on-binding</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">dotable</span><span class="w"> </span><span class="p">[</span><span class="nv">t</span><span class="w"> </span><span class="nv">on-value</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">newt</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">key</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">t</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">key</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">put </span><span class="nv">newt</span><span class="w"> </span><span class="p">(</span><span class="nv">recur</span><span class="w"> </span><span class="nv">key</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">on-value</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="nv">key</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">key</span><span class="w"> </span><span class="p">(</span><span class="nb">next </span><span class="nv">t</span><span class="w"> </span><span class="nv">key</span><span class="p">)))</span>
<span class="w">    </span><span class="nv">newt</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">expand-bindings</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="no">:array</span><span class="w"> </span><span class="p">(</span><span class="nb">map </span><span class="nv">expand-bindings</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="p">(</span><span class="nb">map </span><span class="nv">expand-bindings</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">      </span><span class="no">:table</span><span class="w"> </span><span class="p">(</span><span class="nv">dotable</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">expand-bindings</span><span class="p">)</span>
<span class="w">      </span><span class="no">:struct</span><span class="w"> </span><span class="p">(</span><span class="nb">table/to-struct </span><span class="p">(</span><span class="nv">dotable</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">expand-bindings</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">recur</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">expanddef</span><span class="w"> </span><span class="p">[</span><span class="nv">t</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nb">last </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">t</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">bound</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">tuple/slice</span>
<span class="w">      </span><span class="p">(</span><span class="nv">array/concat</span>
<span class="w">        </span><span class="p">@[(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">expand-bindings</span><span class="w"> </span><span class="nv">bound</span><span class="p">)]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">t</span><span class="w"> </span><span class="mf">2</span><span class="w"> </span><span class="mf">-2</span><span class="p">)</span>
<span class="w">        </span><span class="p">@[(</span><span class="nv">recur</span><span class="w"> </span><span class="nv">last</span><span class="p">)])))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">expandall</span><span class="w"> </span><span class="p">[</span><span class="nv">t</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">map </span><span class="nv">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">t</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">tuple </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">expandfn</span><span class="w"> </span><span class="p">[</span><span class="nv">t</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">t1</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">symbol? </span><span class="nv">t1</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">map </span><span class="nv">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">t</span><span class="w"> </span><span class="mf">3</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">fn </span><span class="nv">t1</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">map </span><span class="nv">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">t</span><span class="w"> </span><span class="mf">2</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">tuple </span><span class="o">&#39;</span><span class="k">fn </span><span class="nv">t1</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">expandqq</span><span class="w"> </span><span class="p">[</span><span class="nv">t</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">defn </span><span class="nv">qq</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span>
<span class="w">        </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:brackets</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/type </span><span class="nv">x</span><span class="p">))</span>
<span class="w">                 </span><span class="o">~</span><span class="p">[</span><span class="o">,;</span><span class="p">(</span><span class="nb">map </span><span class="nv">qq</span><span class="w"> </span><span class="nv">x</span><span class="p">)]</span>
<span class="w">                 </span><span class="p">(</span><span class="nv">do</span>
<span class="w">                   </span><span class="p">(</span><span class="k">def </span><span class="nv">x0</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">x</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">                   </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="o">&#39;</span><span class="k">unquote </span><span class="nv">x0</span><span class="p">)</span>
<span class="w">                     </span><span class="p">(</span><span class="nb">tuple </span><span class="nv">x0</span><span class="w"> </span><span class="p">(</span><span class="nv">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">x</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">                     </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="p">(</span><span class="nb">map </span><span class="nv">qq</span><span class="w"> </span><span class="nv">x</span><span class="p">)))))</span>
<span class="w">        </span><span class="no">:array</span><span class="w"> </span><span class="p">(</span><span class="nb">map </span><span class="nv">qq</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">        </span><span class="no">:table</span><span class="w"> </span><span class="p">(</span><span class="nb">table </span><span class="o">;</span><span class="p">(</span><span class="nb">map </span><span class="nv">qq</span><span class="w"> </span><span class="p">(</span><span class="nb">kvs </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">        </span><span class="no">:struct</span><span class="w"> </span><span class="p">(</span><span class="nb">struct </span><span class="o">;</span><span class="p">(</span><span class="nb">map </span><span class="nv">qq</span><span class="w"> </span><span class="p">(</span><span class="nb">kvs </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">        </span><span class="nv">x</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">tuple </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">qq</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="mf">1</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">specs</span>
<span class="w">    </span><span class="p">{</span><span class="o">&#39;</span><span class="k">set </span><span class="nv">expanddef</span>
<span class="w">     </span><span class="o">&#39;</span><span class="k">def </span><span class="nv">expanddef</span>
<span class="w">     </span><span class="o">&#39;</span><span class="k">do </span><span class="nv">expandall</span>
<span class="w">     </span><span class="o">&#39;</span><span class="k">fn </span><span class="nv">expandfn</span>
<span class="w">     </span><span class="o">&#39;</span><span class="k">if </span><span class="nv">expandall</span>
<span class="w">     </span><span class="o">&#39;</span><span class="k">quote </span><span class="nv">identity</span>
<span class="w">     </span><span class="o">&#39;</span><span class="k">quasiquote </span><span class="nv">expandqq</span>
<span class="w">     </span><span class="o">&#39;</span><span class="k">var </span><span class="nv">expanddef</span>
<span class="w">     </span><span class="o">&#39;</span><span class="k">while </span><span class="nv">expandall</span>
<span class="w">     </span><span class="o">&#39;</span><span class="k">break </span><span class="nv">expandall</span>
<span class="w">     </span><span class="o">&#39;</span><span class="k">upscope </span><span class="nv">expandall</span><span class="p">})</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">dotup</span><span class="w"> </span><span class="p">[</span><span class="nv">t</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">h</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">t</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">specs</span><span class="w"> </span><span class="nv">h</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">entry</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">h</span><span class="p">)</span><span class="w"> </span><span class="p">{}))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">m</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">entry</span><span class="w"> </span><span class="no">:ref</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">r</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">entry</span><span class="w"> </span><span class="no">:value</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">m?</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">entry</span><span class="w"> </span><span class="no">:macro</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">      </span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nv">s</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span>
<span class="w">      </span><span class="nv">m?</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*macro-form*</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">m</span><span class="w"> </span><span class="o">;</span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">t</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="p">(</span><span class="nb">map </span><span class="nv">recur</span><span class="w"> </span><span class="nv">t</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret</span>
<span class="w">    </span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">tuple/type </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="no">:brackets</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="nb">tuple/brackets </span><span class="o">;</span><span class="p">(</span><span class="nb">map </span><span class="nv">recur</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nv">dotup</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">      </span><span class="no">:array</span><span class="w"> </span><span class="p">(</span><span class="nb">map </span><span class="nv">recur</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="no">:struct</span><span class="w"> </span><span class="p">(</span><span class="nb">table/to-struct </span><span class="p">(</span><span class="nv">dotable</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">recur</span><span class="p">))</span>
<span class="w">      </span><span class="no">:table</span><span class="w"> </span><span class="p">(</span><span class="nv">dotable</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">recur</span><span class="p">)</span>
<span class="w">      </span><span class="nv">x</span><span class="p">))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">all</span>
<span class="w">  </span><span class="s">``Returns true if `(pred item)` is truthy for every item in `ind`.</span>
<span class="s">  Otherwise, returns the first falsey result encountered.</span>
<span class="s">  Returns true if `ind` is empty.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">inds</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">map-template</span><span class="w"> </span><span class="no">:all</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">inds</span><span class="p">)</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">some</span>
<span class="w">  </span><span class="s">``Returns nil if `(pred item)` is false or nil for every item in `ind`.</span>
<span class="s">  Otherwise, returns the first truthy result encountered.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">inds</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">map-template</span><span class="w"> </span><span class="no">:some</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">pred</span><span class="w"> </span><span class="nv">ind</span><span class="w"> </span><span class="nv">inds</span><span class="p">)</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">deep-not=</span>
<span class="w">  </span><span class="s">``Like `not=`, but mutable types (arrays, tables, buffers) are considered</span>
<span class="s">  equal if they have identical structure. Much slower than `not=`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">tx</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">or</span>
<span class="w">    </span><span class="p">(</span><span class="nb">not= </span><span class="nv">tx</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="nv">y</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">case </span><span class="nv">tx</span>
<span class="w">      </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">not= </span><span class="p">(</span><span class="nb">length </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">y</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nv">do</span>
<span class="w">                   </span><span class="p">(</span><span class="k">var </span><span class="nv">ret</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">x</span><span class="p">)</span>
<span class="w">                     </span><span class="p">(</span><span class="k">def </span><span class="nv">xx</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">x</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">                     </span><span class="p">(</span><span class="k">def </span><span class="nv">yy</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">y</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">                     </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">deep-not= </span><span class="nv">xx</span><span class="w"> </span><span class="nv">yy</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="k">break </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="kc">true</span><span class="p">))))</span>
<span class="w">                   </span><span class="nv">ret</span><span class="p">))</span>
<span class="w">      </span><span class="no">:array</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">not= </span><span class="p">(</span><span class="nb">length </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">y</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nv">do</span>
<span class="w">                   </span><span class="p">(</span><span class="k">var </span><span class="nv">ret</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">x</span><span class="p">)</span>
<span class="w">                     </span><span class="p">(</span><span class="k">def </span><span class="nv">xx</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">x</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">                     </span><span class="p">(</span><span class="k">def </span><span class="nv">yy</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">y</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">                     </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">deep-not= </span><span class="nv">xx</span><span class="w"> </span><span class="nv">yy</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="k">break </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="kc">true</span><span class="p">))))</span>
<span class="w">                   </span><span class="nv">ret</span><span class="p">))</span>
<span class="w">      </span><span class="no">:struct</span><span class="w"> </span><span class="p">(</span><span class="nb">deep-not= </span><span class="p">(</span><span class="nb">kvs </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">kvs </span><span class="nv">y</span><span class="p">))</span>
<span class="w">      </span><span class="no">:table</span><span class="w"> </span><span class="p">(</span><span class="nb">deep-not= </span><span class="p">(</span><span class="nb">table/to-struct </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">table/to-struct </span><span class="nv">y</span><span class="p">))</span>
<span class="w">      </span><span class="no">:buffer</span><span class="w"> </span><span class="p">(</span><span class="nb">not= </span><span class="p">(</span><span class="nb">string </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="nv">y</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">not= </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">deep=</span>
<span class="w">  </span><span class="s">``Like `=`, but mutable types (arrays, tables, buffers) are considered</span>
<span class="s">  equal if they have identical structure. Much slower than `=`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">deep-not= </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">freeze</span>
<span class="w">  </span><span class="s">`Freeze an object (make it immutable) and do a deep copy, making</span>
<span class="s">  child values also immutable. Closures, fibers, and abstract types</span>
<span class="s">  will not be recursively frozen, but all other types will.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span>
<span class="w">    </span><span class="no">:array</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="p">(</span><span class="nb">map freeze </span><span class="nv">x</span><span class="p">))</span>
<span class="w">    </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="p">(</span><span class="nb">map freeze </span><span class="nv">x</span><span class="p">))</span>
<span class="w">    </span><span class="no">:table</span><span class="w"> </span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">p</span><span class="w"> </span><span class="p">(</span><span class="nb">table/getproto </span><span class="nv">x</span><span class="p">)]</span>
<span class="w">             </span><span class="p">(</span><span class="nb">freeze </span><span class="p">(</span><span class="nb">merge </span><span class="p">(</span><span class="nb">table/clone </span><span class="nv">p</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="nb">struct </span><span class="o">;</span><span class="p">(</span><span class="nb">map freeze </span><span class="p">(</span><span class="nb">kvs </span><span class="nv">x</span><span class="p">))))</span>
<span class="w">    </span><span class="no">:struct</span><span class="w"> </span><span class="p">(</span><span class="nb">struct </span><span class="o">;</span><span class="p">(</span><span class="nb">map freeze </span><span class="p">(</span><span class="nb">kvs </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">    </span><span class="no">:buffer</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="nv">x</span><span class="p">)</span>
<span class="w">    </span><span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">thaw</span>
<span class="w">  </span><span class="s">`Thaw an object (make it mutable) and do a deep copy, making</span>
<span class="s">  child value also mutable. Closures, fibers, and abstract</span>
<span class="s">  types will not be recursively thawed, but all other types will`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ds</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">type </span><span class="nv">ds</span><span class="p">)</span>
<span class="w">    </span><span class="no">:array</span><span class="w"> </span><span class="p">(</span><span class="nv">walk-ind</span><span class="w"> </span><span class="nb">thaw </span><span class="nv">ds</span><span class="p">)</span>
<span class="w">    </span><span class="no">:tuple</span><span class="w"> </span><span class="p">(</span><span class="nv">walk-ind</span><span class="w"> </span><span class="nb">thaw </span><span class="nv">ds</span><span class="p">)</span>
<span class="w">    </span><span class="no">:table</span><span class="w"> </span><span class="p">(</span><span class="nv">walk-dict</span><span class="w"> </span><span class="nb">thaw </span><span class="p">(</span><span class="nb">table/proto-flatten </span><span class="nv">ds</span><span class="p">))</span>
<span class="w">    </span><span class="no">:struct</span><span class="w"> </span><span class="p">(</span><span class="nv">walk-dict</span><span class="w"> </span><span class="nb">thaw </span><span class="p">(</span><span class="nb">struct/proto-flatten </span><span class="nv">ds</span><span class="p">))</span>
<span class="w">    </span><span class="no">:string</span><span class="w"> </span><span class="p">(</span><span class="nb">buffer </span><span class="nv">ds</span><span class="p">)</span>
<span class="w">    </span><span class="nv">ds</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">macex</span>
<span class="w">  </span><span class="s">``Expand macros completely.</span>
<span class="s">  `on-binding` is an optional callback for whenever a normal symbolic binding</span>
<span class="s">  is encountered. This allows macros to easily see all bindings used by their</span>
<span class="s">  arguments by calling `macex` on their contents. The binding itself is also</span>
<span class="s">  replaced by the value returned by `on-binding` within the expanded macro.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">on-binding</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">previous</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">current</span><span class="w"> </span><span class="p">(</span><span class="nb">macex1 </span><span class="nv">x</span><span class="w"> </span><span class="nv">on-binding</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">counter</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">deep-not= </span><span class="nv">current</span><span class="w"> </span><span class="nv">previous</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">++ </span><span class="nv">counter</span><span class="p">)</span><span class="w"> </span><span class="mf">200</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">error </span><span class="s">&quot;macro expansion too nested&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">previous</span><span class="w"> </span><span class="nv">current</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">current</span><span class="w"> </span><span class="p">(</span><span class="nb">macex1 </span><span class="nv">current</span><span class="w"> </span><span class="nv">on-binding</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">current</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">varfn</span>
<span class="w">  </span><span class="s">``Create a function that can be rebound. `varfn` has the same signature</span>
<span class="s">  as `defn`, but defines functions in the environment as vars. If a var `name`</span>
<span class="s">  already exists in the environment, it is rebound to the new function. Returns</span>
<span class="s">  a function.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">expansion</span><span class="w"> </span><span class="p">(</span><span class="nb">apply defn </span><span class="nv">name</span><span class="w"> </span><span class="nv">body</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">fbody</span><span class="w"> </span><span class="p">(</span><span class="nb">last </span><span class="nv">expansion</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">modifiers</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">expansion</span><span class="w"> </span><span class="mf">2</span><span class="w"> </span><span class="mf">-2</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">metadata</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">m</span><span class="w"> </span><span class="nv">modifiers</span>
<span class="w">    </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">      </span><span class="p">(</span><span class="nb">keyword? </span><span class="nv">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">put </span><span class="nv">metadata</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">string? </span><span class="nv">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">put </span><span class="nv">metadata</span><span class="w"> </span><span class="no">:doc</span><span class="w"> </span><span class="nv">m</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;invalid metadata &quot;</span><span class="w"> </span><span class="nv">m</span><span class="p">))))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">entry</span><span class="w"> </span><span class="nv">old-entry</span><span class="w"> </span><span class="nv">f</span><span class="p">]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="o">,</span><span class="nv">old-entry</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">dyn </span><span class="o">&#39;,</span><span class="nv">name</span><span class="p">)]</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">entry</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="o">,</span><span class="nv">old-entry</span><span class="w"> </span><span class="p">@{</span><span class="no">:ref</span><span class="w"> </span><span class="p">@[</span><span class="kc">nil</span><span class="p">]}))</span>
<span class="w">       </span><span class="p">(</span><span class="o">,</span><span class="nb">setdyn </span><span class="o">&#39;,</span><span class="nv">name</span><span class="w"> </span><span class="o">,</span><span class="nv">entry</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="o">,</span><span class="nv">fbody</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="o">,</span><span class="nb">put-in </span><span class="o">,</span><span class="nv">entry</span><span class="w"> </span><span class="p">[</span><span class="no">:ref</span><span class="w"> </span><span class="mf">0</span><span class="p">]</span><span class="w"> </span><span class="o">,</span><span class="nv">f</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="o">,</span><span class="nb">merge-into </span><span class="o">,</span><span class="nv">entry</span><span class="w"> </span><span class="o">&#39;,</span><span class="nv">metadata</span><span class="p">)</span>
<span class="w">       </span><span class="o">,</span><span class="nv">f</span><span class="p">)))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Function shorthand</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">short-fn</span>
<span class="w">  </span><span class="s">```</span>
<span class="s">  Shorthand for `fn`. Arguments are given as `$n`, where `n` is the 0-indexed</span>
<span class="s">  argument of the function. `$` is also an alias for the first (index 0) argument.</span>
<span class="s">  The `$&amp;` symbol will make the anonymous function variadic if it appears in the</span>
<span class="s">  body of the function, and can be combined with positional arguments.</span>

<span class="s">  Example usage:</span>

<span class="s">      (short-fn (+ $ $)) # A function that doubles its arguments.</span>
<span class="s">      (short-fn (string $0 $1)) # accepting multiple args.</span>
<span class="s">      |(+ $ $) # use pipe reader macro for terse function literals.</span>
<span class="s">      |(+ $&amp;)  # variadic functions</span>
<span class="s">  ```</span>
<span class="w">  </span><span class="p">[</span><span class="nv">arg</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">name</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">max-param-seen</span><span class="w"> </span><span class="mf">-1</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">vararg</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">saw-special-arg</span>
<span class="w">    </span><span class="p">[</span><span class="nv">num</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">max-param-seen</span><span class="w"> </span><span class="p">(</span><span class="nb">max </span><span class="nv">max-param-seen</span><span class="w"> </span><span class="nv">num</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">prefix</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">on-binding</span>
<span class="w">    </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">string/has-prefix? </span><span class="o">&#39;</span><span class="nv">$</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">        </span><span class="p">(</span><span class="nb">= </span><span class="o">&#39;</span><span class="nv">$</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nv">do</span>
<span class="w">          </span><span class="p">(</span><span class="nv">saw-special-arg</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">symbol </span><span class="nv">prefix</span><span class="w"> </span><span class="o">&#39;</span><span class="nv">$0</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">= </span><span class="o">&#39;</span><span class="nv">$&amp;</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nv">do</span>
<span class="w">          </span><span class="p">(</span><span class="k">set </span><span class="nv">vararg</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">symbol </span><span class="nv">prefix</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">        </span><span class="no">:else</span>
<span class="w">        </span><span class="p">(</span><span class="nv">do</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="nv">num</span><span class="w"> </span><span class="p">(</span><span class="nb">scan-number </span><span class="p">(</span><span class="nb">string/slice </span><span class="nv">x</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">nat? </span><span class="nv">num</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nv">do</span>
<span class="w">              </span><span class="p">(</span><span class="nv">saw-special-arg</span><span class="w"> </span><span class="nv">num</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">symbol </span><span class="nv">prefix</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">            </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">      </span><span class="nv">x</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">expanded</span><span class="w"> </span><span class="p">(</span><span class="nb">macex </span><span class="nv">arg</span><span class="w"> </span><span class="nv">on-binding</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">name-splice</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">name</span><span class="w"> </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span><span class="w"> </span><span class="p">[]))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">fn-args</span><span class="w"> </span><span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="mf">1</span><span class="w"> </span><span class="nv">max-param-seen</span><span class="p">)]]</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol </span><span class="nv">prefix</span><span class="w"> </span><span class="o">&#39;</span><span class="nv">$</span><span class="w"> </span><span class="nv">i</span><span class="p">)))</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">fn </span><span class="o">,;</span><span class="nv">name-splice</span><span class="w"> </span><span class="p">[</span><span class="o">,;</span><span class="nv">fn-args</span><span class="w"> </span><span class="o">,;</span><span class="p">(</span><span class="k">if </span><span class="nv">vararg</span><span class="w"> </span><span class="p">[</span><span class="o">&#39;</span><span class="nv">&amp;</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol </span><span class="nv">prefix</span><span class="w"> </span><span class="o">&#39;</span><span class="nv">$&amp;</span><span class="p">)]</span><span class="w"> </span><span class="p">[])]</span><span class="w"> </span><span class="o">,</span><span class="nv">expanded</span><span class="p">))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Default PEG patterns</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*peg-grammar*</span>
<span class="w">  </span><span class="s">``The implicit base grammar used when compiling PEGs. Any undefined keywords</span>
<span class="s">  found when compiling a peg will use lookup in this table (if defined).``</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">default-peg-grammar</span>
<span class="w">  </span><span class="s">`The default grammar used for pegs. This grammar defines several common patterns</span>
<span class="s">  that should make it easier to write more complex patterns.`</span>
<span class="w">  </span><span class="o">~</span><span class="p">@{</span><span class="no">:a</span><span class="w"> </span><span class="p">(</span><span class="nb">range </span><span class="s">&quot;az&quot;</span><span class="w"> </span><span class="s">&quot;AZ&quot;</span><span class="p">)</span>
<span class="w">     </span><span class="no">:d</span><span class="w"> </span><span class="p">(</span><span class="nb">range </span><span class="s">&quot;09&quot;</span><span class="p">)</span>
<span class="w">     </span><span class="no">:h</span><span class="w"> </span><span class="p">(</span><span class="nb">range </span><span class="s">&quot;09&quot;</span><span class="w"> </span><span class="s">&quot;af&quot;</span><span class="w"> </span><span class="s">&quot;AF&quot;</span><span class="p">)</span>
<span class="w">     </span><span class="no">:s</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="s">&quot; \t\r\n\0\f\v&quot;</span><span class="p">)</span>
<span class="w">     </span><span class="no">:w</span><span class="w"> </span><span class="p">(</span><span class="nb">range </span><span class="s">&quot;az&quot;</span><span class="w"> </span><span class="s">&quot;AZ&quot;</span><span class="w"> </span><span class="s">&quot;09&quot;</span><span class="p">)</span>
<span class="w">     </span><span class="no">:A</span><span class="w"> </span><span class="p">(</span><span class="nb">if-not </span><span class="no">:a</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="no">:D</span><span class="w"> </span><span class="p">(</span><span class="nb">if-not </span><span class="no">:d</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="no">:H</span><span class="w"> </span><span class="p">(</span><span class="nb">if-not </span><span class="no">:h</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="no">:S</span><span class="w"> </span><span class="p">(</span><span class="nb">if-not </span><span class="no">:s</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="no">:W</span><span class="w"> </span><span class="p">(</span><span class="nb">if-not </span><span class="no">:w</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="no">:a+</span><span class="w"> </span><span class="p">(</span><span class="nb">some </span><span class="no">:a</span><span class="p">)</span>
<span class="w">     </span><span class="no">:d+</span><span class="w"> </span><span class="p">(</span><span class="nb">some </span><span class="no">:d</span><span class="p">)</span>
<span class="w">     </span><span class="no">:h+</span><span class="w"> </span><span class="p">(</span><span class="nb">some </span><span class="no">:h</span><span class="p">)</span>
<span class="w">     </span><span class="no">:s+</span><span class="w"> </span><span class="p">(</span><span class="nb">some </span><span class="no">:s</span><span class="p">)</span>
<span class="w">     </span><span class="no">:w+</span><span class="w"> </span><span class="p">(</span><span class="nb">some </span><span class="no">:w</span><span class="p">)</span>
<span class="w">     </span><span class="no">:A+</span><span class="w"> </span><span class="p">(</span><span class="nb">some </span><span class="no">:A</span><span class="p">)</span>
<span class="w">     </span><span class="no">:D+</span><span class="w"> </span><span class="p">(</span><span class="nb">some </span><span class="no">:D</span><span class="p">)</span>
<span class="w">     </span><span class="no">:H+</span><span class="w"> </span><span class="p">(</span><span class="nb">some </span><span class="no">:H</span><span class="p">)</span>
<span class="w">     </span><span class="no">:S+</span><span class="w"> </span><span class="p">(</span><span class="nb">some </span><span class="no">:S</span><span class="p">)</span>
<span class="w">     </span><span class="no">:W+</span><span class="w"> </span><span class="p">(</span><span class="nb">some </span><span class="no">:W</span><span class="p">)</span>
<span class="w">     </span><span class="no">:a*</span><span class="w"> </span><span class="p">(</span><span class="nv">any</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span>
<span class="w">     </span><span class="no">:d*</span><span class="w"> </span><span class="p">(</span><span class="nv">any</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span>
<span class="w">     </span><span class="no">:h*</span><span class="w"> </span><span class="p">(</span><span class="nv">any</span><span class="w"> </span><span class="no">:h</span><span class="p">)</span>
<span class="w">     </span><span class="no">:s*</span><span class="w"> </span><span class="p">(</span><span class="nv">any</span><span class="w"> </span><span class="no">:s</span><span class="p">)</span>
<span class="w">     </span><span class="no">:w*</span><span class="w"> </span><span class="p">(</span><span class="nv">any</span><span class="w"> </span><span class="no">:w</span><span class="p">)</span>
<span class="w">     </span><span class="no">:A*</span><span class="w"> </span><span class="p">(</span><span class="nv">any</span><span class="w"> </span><span class="no">:A</span><span class="p">)</span>
<span class="w">     </span><span class="no">:D*</span><span class="w"> </span><span class="p">(</span><span class="nv">any</span><span class="w"> </span><span class="no">:D</span><span class="p">)</span>
<span class="w">     </span><span class="no">:H*</span><span class="w"> </span><span class="p">(</span><span class="nv">any</span><span class="w"> </span><span class="no">:H</span><span class="p">)</span>
<span class="w">     </span><span class="no">:S*</span><span class="w"> </span><span class="p">(</span><span class="nv">any</span><span class="w"> </span><span class="no">:S</span><span class="p">)</span>
<span class="w">     </span><span class="no">:W*</span><span class="w"> </span><span class="p">(</span><span class="nv">any</span><span class="w"> </span><span class="no">:W</span><span class="p">)})</span>

<span class="p">(</span><span class="nb">setdyn </span><span class="nv">*peg-grammar*</span><span class="w"> </span><span class="nv">default-peg-grammar</span><span class="p">)</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Evaluation and Compilation</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*syspath*</span>
<span class="w">  </span><span class="s">&quot;Path of directory to load system modules from.&quot;</span><span class="p">)</span>

<span class="c1"># Initialize syspath</span>
<span class="p">(</span><span class="nb">each </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">partition </span><span class="mf">2</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">boot/args</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">case </span><span class="nv">k</span>
<span class="w">    </span><span class="s">&quot;JANET_PATH&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*syspath*</span><span class="w"> </span><span class="nv">v</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">make-env</span>
<span class="w">  </span><span class="s">`Create a new environment table. The new environment</span>
<span class="s">  will inherit bindings from the parent environment, but new</span>
<span class="s">  bindings will not pollute the parent environment.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">parent</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">parent</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">parent</span><span class="w"> </span><span class="nv">parent</span><span class="w"> </span><span class="nv">root-env</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">newenv</span><span class="w"> </span><span class="p">(</span><span class="nb">table/setproto </span><span class="p">@{}</span><span class="w"> </span><span class="nv">parent</span><span class="p">))</span>
<span class="w">  </span><span class="nv">newenv</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*err-color*</span>
<span class="w">  </span><span class="s">&quot;Whether or not to turn on error coloring in stacktraces and other error messages.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">bad-parse</span>
<span class="w">  </span><span class="s">&quot;Default handler for a parse error.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">p</span><span class="w"> </span><span class="nv">where</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ec</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*err-color*</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">line</span><span class="w"> </span><span class="nv">col</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="no">:where</span><span class="w"> </span><span class="nv">p</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">eprint</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="nv">ec</span><span class="w"> </span><span class="s">&quot;\e[31m&quot;</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nv">where</span>
<span class="w">    </span><span class="s">&quot;:&quot;</span>
<span class="w">    </span><span class="nv">line</span>
<span class="w">    </span><span class="s">&quot;:&quot;</span>
<span class="w">    </span><span class="nv">col</span>
<span class="w">    </span><span class="s">&quot;: parse error: &quot;</span>
<span class="w">    </span><span class="p">(</span><span class="no">:error</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="nv">ec</span><span class="w"> </span><span class="s">&quot;\e[0m&quot;</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">eflush</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">print-line-col</span>
<span class="w">  </span><span class="s">``Print the source code at a line, column in a source file. If unable to open</span>
<span class="s">  the file, prints nothing.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">where</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="nv">col</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">if-not </span><span class="nv">line</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">unless </span><span class="p">(</span><span class="nb">string? </span><span class="nv">where</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when-with </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">file/open </span><span class="nv">where</span><span class="w"> </span><span class="no">:r</span><span class="p">)]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">source-code</span><span class="w"> </span><span class="p">(</span><span class="nb">file/read </span><span class="nv">f</span><span class="w"> </span><span class="no">:all</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">index</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">dec </span><span class="nv">line</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">if-not </span><span class="nv">index</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">index</span><span class="w"> </span><span class="p">(</span><span class="nb">string/find </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="nv">source-code</span><span class="w"> </span><span class="nv">index</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="nv">index</span><span class="w"> </span><span class="p">(</span><span class="nb">++ </span><span class="nv">index</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="nv">index</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">line-end</span><span class="w"> </span><span class="p">(</span><span class="nb">string/find </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="nv">source-code</span><span class="w"> </span><span class="nv">index</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;  &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">string/slice </span><span class="nv">source-code</span><span class="w"> </span><span class="nv">index</span><span class="w"> </span><span class="nv">line-end</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">when </span><span class="nv">col</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+= </span><span class="nv">index</span><span class="w"> </span><span class="nv">col</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">eprint </span><span class="p">(</span><span class="nb">string/repeat </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">inc </span><span class="nv">col</span><span class="p">))</span><span class="w"> </span><span class="s">&quot;^&quot;</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">warn-compile</span>
<span class="w">  </span><span class="s">&quot;Default handler for a compile warning.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">msg</span><span class="w"> </span><span class="nv">level</span><span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="nv">col</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ec</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*err-color*</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">eprin</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="nv">ec</span><span class="w"> </span><span class="s">&quot;\e[33m&quot;</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nv">where</span>
<span class="w">    </span><span class="s">&quot;:&quot;</span>
<span class="w">    </span><span class="nv">line</span>
<span class="w">    </span><span class="s">&quot;:&quot;</span>
<span class="w">    </span><span class="nv">col</span>
<span class="w">    </span><span class="s">&quot;: compile warning (&quot;</span><span class="w"> </span><span class="nv">level</span><span class="w"> </span><span class="s">&quot;): &quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">eprint </span><span class="nv">msg</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="nv">ec</span>
<span class="w">    </span><span class="p">(</span><span class="nv">print-line-col</span><span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="nv">col</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">eprin </span><span class="s">&quot;\e[0m&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">eflush</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">bad-compile</span>
<span class="w">  </span><span class="s">&quot;Default handler for a compile error.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">msg</span><span class="w"> </span><span class="nv">macrof</span><span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="nv">col</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ec</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*err-color*</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">eprin</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="nv">ec</span><span class="w"> </span><span class="s">&quot;\e[31m&quot;</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nv">where</span>
<span class="w">    </span><span class="s">&quot;:&quot;</span>
<span class="w">    </span><span class="nv">line</span>
<span class="w">    </span><span class="s">&quot;:&quot;</span>
<span class="w">    </span><span class="nv">col</span>
<span class="w">    </span><span class="s">&quot;: compile error: &quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="nv">macrof</span>
<span class="w">    </span><span class="p">(</span><span class="nb">debug/stacktrace </span><span class="nv">macrof</span><span class="w"> </span><span class="nv">msg</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">eprint </span><span class="nv">msg</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="nv">ec</span>
<span class="w">    </span><span class="p">(</span><span class="nv">print-line-col</span><span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="nv">col</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">eprin </span><span class="s">&quot;\e[0m&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">eflush</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">curenv</span>
<span class="w">  </span><span class="s">``Get the current environment table. Same as `(fiber/getenv (fiber/current))`. If `n`</span>
<span class="s">  is provided, gets the nth prototype of the environment table.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">e</span><span class="w"> </span><span class="p">(</span><span class="nb">fiber/getenv </span><span class="p">(</span><span class="nv">fiber/current</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat </span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">e</span><span class="w"> </span><span class="p">(</span><span class="nb">table/getproto </span><span class="nv">e</span><span class="p">))))</span>
<span class="w">  </span><span class="nv">e</span><span class="p">)</span>

<span class="p">(</span><span class="nb">def- </span><span class="nv">lint-levels</span>
<span class="w">  </span><span class="p">{</span><span class="no">:none</span><span class="w"> </span><span class="mf">0</span>
<span class="w">   </span><span class="no">:relaxed</span><span class="w"> </span><span class="mf">1</span>
<span class="w">   </span><span class="no">:normal</span><span class="w"> </span><span class="mf">2</span>
<span class="w">   </span><span class="no">:strict</span><span class="w"> </span><span class="mf">3</span>
<span class="w">   </span><span class="no">:all</span><span class="w"> </span><span class="nv">math/inf</span><span class="p">})</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">run-context</span>
<span class="w">  </span><span class="s">```</span>
<span class="s">  Run a context. This evaluates expressions in an environment,</span>
<span class="s">  and encapsulates the parsing, compilation, and evaluation.</span>
<span class="s">  Returns `(in environment :exit-value environment)` when complete.</span>
<span class="s">  `opts` is a table or struct of options. The options are as follows:</span>

<span class="s">    * `:chunks` -- callback to read into a buffer - default is getline</span>

<span class="s">    * `:on-parse-error` -- callback when parsing fails - default is bad-parse</span>

<span class="s">    * `:env` -- the environment to compile against - default is the current env</span>

<span class="s">    * `:source` -- source path for better errors (use keywords for non-paths) - default</span>
<span class="s">      is :&lt;anonymous&gt;</span>

<span class="s">    * `:on-compile-error` -- callback when compilation fails - default is bad-compile</span>

<span class="s">    * `:on-compile-warning` -- callback for any linting error - default is warn-compile</span>

<span class="s">    * `:evaluator` -- callback that executes thunks. Signature is (evaluator thunk source</span>
<span class="s">      env where)</span>

<span class="s">    * `:on-status` -- callback when a value is evaluated - default is debug/stacktrace.</span>

<span class="s">    * `:fiber-flags` -- what flags to wrap the compilation fiber with. Default is :ia.</span>

<span class="s">    * `:expander` -- an optional function that is called on each top level form before</span>
<span class="s">      being compiled.</span>

<span class="s">    * `:parser` -- provide a custom parser that implements the same interface as Janet&#39;s</span>
<span class="s">      built-in parser.</span>

<span class="s">    * `:read` -- optional function to get the next form, called like `(read env source)`.</span>
<span class="s">      Overrides all parsing.</span>
<span class="s">  ```</span>
<span class="w">  </span><span class="p">[</span><span class="nv">opts</span><span class="p">]</span>

<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="p">{</span><span class="no">:env</span><span class="w"> </span><span class="nv">env</span>
<span class="w">        </span><span class="no">:chunks</span><span class="w"> </span><span class="nv">chunks</span>
<span class="w">        </span><span class="no">:on-status</span><span class="w"> </span><span class="nv">onstatus</span>
<span class="w">        </span><span class="no">:on-compile-error</span><span class="w"> </span><span class="nv">on-compile-error</span>
<span class="w">        </span><span class="no">:on-compile-warning</span><span class="w"> </span><span class="nv">on-compile-warning</span>
<span class="w">        </span><span class="no">:on-parse-error</span><span class="w"> </span><span class="nv">on-parse-error</span>
<span class="w">        </span><span class="no">:fiber-flags</span><span class="w"> </span><span class="nv">guard</span>
<span class="w">        </span><span class="no">:evaluator</span><span class="w"> </span><span class="nv">evaluator</span>
<span class="w">        </span><span class="no">:source</span><span class="w"> </span><span class="nv">default-where</span>
<span class="w">        </span><span class="no">:parser</span><span class="w"> </span><span class="nv">parser</span>
<span class="w">        </span><span class="no">:read</span><span class="w"> </span><span class="nv">read</span>
<span class="w">        </span><span class="no">:expander</span><span class="w"> </span><span class="nv">expand</span><span class="p">}</span><span class="w"> </span><span class="nv">opts</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">env</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">fiber/getenv </span><span class="p">(</span><span class="nv">fiber/current</span><span class="p">))</span><span class="w"> </span><span class="p">@{}))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">chunks</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">buf</span><span class="w"> </span><span class="nv">p</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">getline </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="nv">buf</span><span class="w"> </span><span class="nv">env</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">onstatus</span><span class="w"> </span><span class="nv">debug/stacktrace</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">on-compile-error</span><span class="w"> </span><span class="nv">bad-compile</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">on-compile-warning</span><span class="w"> </span><span class="nv">warn-compile</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">on-parse-error</span><span class="w"> </span><span class="nv">bad-parse</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">evaluator</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="nv">evaluate</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">default-where</span><span class="w"> </span><span class="no">:&lt;anonymous&gt;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">guard</span><span class="w"> </span><span class="no">:ydt</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">where</span><span class="w"> </span><span class="nv">default-where</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">string? </span><span class="nv">where</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*current-file*</span><span class="w"> </span><span class="nv">where</span><span class="p">))</span>

<span class="w">  </span><span class="c1"># Evaluate 1 source form in a protected manner</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">lints</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">eval1</span><span class="w"> </span><span class="p">[</span><span class="nv">source</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="nv">c</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">source</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">expand</span><span class="w"> </span><span class="p">(</span><span class="nv">expand</span><span class="w"> </span><span class="nv">source</span><span class="p">)</span><span class="w"> </span><span class="nv">source</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">good</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">resumeval</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">f</span>
<span class="w">      </span><span class="p">(</span><span class="nv">fiber/new</span>
<span class="w">        </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span>
<span class="w">          </span><span class="p">(</span><span class="nb">array/clear </span><span class="nv">lints</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">compile </span><span class="nv">source</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="nv">lints</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">unless </span><span class="p">(</span><span class="nb">empty? </span><span class="nv">lints</span><span class="p">)</span>
<span class="w">            </span><span class="c1"># Convert lint levels to numbers.</span>
<span class="w">            </span><span class="p">(</span><span class="k">def </span><span class="nv">levels</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">env</span><span class="w"> </span><span class="nv">*lint-levels*</span><span class="w"> </span><span class="nv">lint-levels</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="k">def </span><span class="nv">lint-error</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">env</span><span class="w"> </span><span class="nv">*lint-error*</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="k">def </span><span class="nv">lint-warning</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">env</span><span class="w"> </span><span class="nv">*lint-warn*</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="k">def </span><span class="nv">lint-error</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">get </span><span class="nv">levels</span><span class="w"> </span><span class="nv">lint-error</span><span class="w"> </span><span class="nv">lint-error</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="k">def </span><span class="nv">lint-warning</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">get </span><span class="nv">levels</span><span class="w"> </span><span class="nv">lint-warning</span><span class="w"> </span><span class="nv">lint-warning</span><span class="p">)</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">each </span><span class="p">[</span><span class="nv">level</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="nv">col</span><span class="w"> </span><span class="nv">msg</span><span class="p">]</span><span class="w"> </span><span class="nv">lints</span>
<span class="w">              </span><span class="p">(</span><span class="k">def </span><span class="nv">lvl</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">lint-levels</span><span class="w"> </span><span class="nv">level</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">                </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">lvl</span><span class="w"> </span><span class="nv">lint-error</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">do</span>
<span class="w">                                      </span><span class="p">(</span><span class="k">set </span><span class="nv">good</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">                                      </span><span class="p">(</span><span class="nv">on-compile-error</span><span class="w"> </span><span class="nv">msg</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">line</span><span class="w"> </span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">col</span><span class="w"> </span><span class="nv">c</span><span class="p">)))</span>
<span class="w">                </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">lvl</span><span class="w"> </span><span class="nv">lint-warning</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">on-compile-warning</span><span class="w"> </span><span class="nv">msg</span><span class="w"> </span><span class="nv">level</span><span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">line</span><span class="w"> </span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">col</span><span class="w"> </span><span class="nv">c</span><span class="p">)))))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">when </span><span class="nv">good</span>
<span class="w">            </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">res</span><span class="p">)</span><span class="w"> </span><span class="no">:function</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nv">evaluator</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">source</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">where</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nv">do</span>
<span class="w">                </span><span class="p">(</span><span class="k">set </span><span class="nv">good</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="k">def </span><span class="p">{</span><span class="no">:error</span><span class="w"> </span><span class="nv">err</span><span class="w"> </span><span class="no">:line</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="no">:column</span><span class="w"> </span><span class="nv">column</span><span class="w"> </span><span class="no">:fiber</span><span class="w"> </span><span class="nv">errf</span><span class="p">}</span><span class="w"> </span><span class="nv">res</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nv">on-compile-error</span><span class="w"> </span><span class="nv">err</span><span class="w"> </span><span class="nv">errf</span><span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">line</span><span class="w"> </span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">column</span><span class="w"> </span><span class="nv">c</span><span class="p">))))))</span>
<span class="w">        </span><span class="nv">guard</span>
<span class="w">        </span><span class="nv">env</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">fiber/can-resume? </span><span class="nv">f</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">resume </span><span class="nv">f</span><span class="w"> </span><span class="nv">resumeval</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">when </span><span class="nv">good</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">resumeval</span><span class="w"> </span><span class="p">(</span><span class="nv">onstatus</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">res</span><span class="p">)))))</span>

<span class="w">  </span><span class="c1"># Reader version</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="nv">read</span>
<span class="w">    </span><span class="p">(</span><span class="nv">forever</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">in </span><span class="nv">env</span><span class="w"> </span><span class="no">:exit</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">eval1</span><span class="w"> </span><span class="p">(</span><span class="nv">read</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">where</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">break </span><span class="p">(</span><span class="nb">in </span><span class="nv">env</span><span class="w"> </span><span class="no">:exit-value</span><span class="w"> </span><span class="nv">env</span><span class="p">)))</span>

<span class="w">  </span><span class="c1"># The parser object</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">p</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">parser</span><span class="w"> </span><span class="p">(</span><span class="nv">parser/new</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">p-consume</span><span class="w"> </span><span class="p">(</span><span class="nv">p</span><span class="w"> </span><span class="no">:consume</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">p-produce</span><span class="w"> </span><span class="p">(</span><span class="nv">p</span><span class="w"> </span><span class="no">:produce</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">p-status</span><span class="w"> </span><span class="p">(</span><span class="nv">p</span><span class="w"> </span><span class="no">:status</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">p-has-more</span><span class="w"> </span><span class="p">(</span><span class="nv">p</span><span class="w"> </span><span class="no">:has-more</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">parse-err</span>
<span class="w">    </span><span class="s">&quot;Handle parser error in the correct environment&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="nv">p</span><span class="w"> </span><span class="nv">where</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">coro </span><span class="p">(</span><span class="nv">on-parse-error</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="nv">where</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">fiber/setenv </span><span class="nv">f</span><span class="w"> </span><span class="nv">env</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">resume </span><span class="nv">f</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">produce</span><span class="w"> </span><span class="p">[]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">tup</span><span class="w"> </span><span class="p">(</span><span class="nv">p-produce</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>
<span class="w">    </span><span class="p">[(</span><span class="nb">in </span><span class="nv">tup</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="o">;</span><span class="p">(</span><span class="nb">tuple/sourcemap </span><span class="nv">tup</span><span class="p">)])</span>

<span class="w">  </span><span class="c1"># Loop</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">buf</span><span class="w"> </span><span class="s">@&quot;&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">parser-not-done</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="nv">parser-not-done</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nv">env</span><span class="w"> </span><span class="no">:exit</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">buffer/clear </span><span class="nv">buf</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">match </span><span class="p">(</span><span class="nv">chunks</span><span class="w"> </span><span class="nv">buf</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span>
<span class="w">      </span><span class="no">:cancel</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="c1"># A :cancel chunk represents a cancelled form in the REPL, so reset.</span>
<span class="w">        </span><span class="p">(</span><span class="no">:flush</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">buffer/clear </span><span class="nv">buf</span><span class="p">))</span>

<span class="w">      </span><span class="p">[</span><span class="no">:source</span><span class="w"> </span><span class="nv">new-where</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="nv">where</span><span class="w"> </span><span class="nv">new-where</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">string? </span><span class="nv">new-where</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*current-file*</span><span class="w"> </span><span class="nv">new-where</span><span class="p">)))</span>

<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="k">var </span><span class="nv">pindex</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">var </span><span class="nv">pstatus</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">buf</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="nv">len</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="no">:eof</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="k">set </span><span class="nv">parser-not-done</span><span class="w"> </span><span class="kc">false</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">len</span><span class="w"> </span><span class="nv">pindex</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">+= </span><span class="nv">pindex</span><span class="w"> </span><span class="p">(</span><span class="nv">p-consume</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="nv">buf</span><span class="w"> </span><span class="nv">pindex</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nv">p-has-more</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nv">eval1</span><span class="w"> </span><span class="o">;</span><span class="p">(</span><span class="nv">produce</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nv">env</span><span class="w"> </span><span class="no">:exit</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nv">p-status</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span><span class="w"> </span><span class="no">:error</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nv">parse-err</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="nv">where</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nv">env</span><span class="w"> </span><span class="no">:exit</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))))))</span>

<span class="w">  </span><span class="c1"># Check final parser state</span>
<span class="w">  </span><span class="p">(</span><span class="nb">unless </span><span class="p">(</span><span class="nv">env</span><span class="w"> </span><span class="no">:exit</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nv">p-has-more</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">eval1</span><span class="w"> </span><span class="o">;</span><span class="p">(</span><span class="nv">produce</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nv">env</span><span class="w"> </span><span class="no">:exit</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nv">p-status</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span><span class="w"> </span><span class="no">:error</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">parse-err</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="nv">where</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="no">:exit</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">in </span><span class="nv">env</span><span class="w"> </span><span class="no">:exit-value</span><span class="w"> </span><span class="nv">env</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">quit</span>
<span class="w">  </span><span class="s">``Tries to exit from the current repl or run-context. Does not always exit the application.</span>
<span class="s">  Works by setting the :exit dynamic binding to true. Passing a non-nil `value` here will cause the outer</span>
<span class="s">  run-context to return that value.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">value</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">setdyn </span><span class="no">:exit</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">setdyn </span><span class="no">:exit-value</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">  </span><span class="kc">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">eval</span>
<span class="w">  </span><span class="s">``Evaluates a form in the current environment. If more control over the</span>
<span class="s">  environment is needed, use `run-context`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">form</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">compile </span><span class="nv">form</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="no">:eval</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">type </span><span class="nv">res</span><span class="p">)</span><span class="w"> </span><span class="no">:function</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">res</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">get </span><span class="nv">res</span><span class="w"> </span><span class="no">:error</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">parse</span>
<span class="w">  </span><span class="s">`Parse a string and return the first value. For complex parsing, such as for a repl with error handling,</span>
<span class="s">  use the parser api.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">str</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">p</span><span class="w"> </span><span class="p">(</span><span class="nv">parser/new</span><span class="p">)]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">parser/consume </span><span class="nv">p</span><span class="w"> </span><span class="nv">str</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:error</span><span class="w"> </span><span class="p">(</span><span class="nb">parser/status </span><span class="nv">p</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">parser/error </span><span class="nv">p</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">parser/eof </span><span class="nv">p</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">parser/has-more </span><span class="nv">p</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">parser/produce </span><span class="nv">p</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:error</span><span class="w"> </span><span class="p">(</span><span class="nb">parser/status </span><span class="nv">p</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">parser/error </span><span class="nv">p</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">error </span><span class="s">&quot;no value&quot;</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">parse-all</span>
<span class="w">  </span><span class="s">`Parse a string and return all parsed values. For complex parsing, such as for a repl with error handling,</span>
<span class="s">  use the parser api.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">str</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">p</span><span class="w"> </span><span class="p">(</span><span class="nv">parser/new</span><span class="p">)</span>
<span class="w">        </span><span class="nv">ret</span><span class="w"> </span><span class="p">@[]]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">parser/consume </span><span class="nv">p</span><span class="w"> </span><span class="nv">str</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:error</span><span class="w"> </span><span class="p">(</span><span class="nb">parser/status </span><span class="nv">p</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">parser/error </span><span class="nv">p</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">parser/eof </span><span class="nv">p</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">parser/has-more </span><span class="nv">p</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">parser/produce </span><span class="nv">p</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:error</span><span class="w"> </span><span class="p">(</span><span class="nb">parser/status </span><span class="nv">p</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">parser/error </span><span class="nv">p</span><span class="p">))</span>
<span class="w">      </span><span class="nv">ret</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">eval-string</span>
<span class="w">  </span><span class="s">``Evaluates a string in the current environment. If more control over the</span>
<span class="s">  environment is needed, use `run-context`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">str</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">ret</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">parse-all </span><span class="nv">str</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">eval </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">ret</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">load-image-dict</span>
<span class="w">  </span><span class="s">``A table used in combination with `unmarshal` to unmarshal byte sequences created</span>
<span class="s">  by `make-image`, such that `(load-image bytes)` is the same as `(unmarshal bytes load-image-dict)`.``</span>
<span class="w">  </span><span class="p">@{})</span>

<span class="p">(</span><span class="k">def </span><span class="nv">make-image-dict</span>
<span class="w">  </span><span class="s">``A table used in combination with `marshal` to marshal code (images), such that</span>
<span class="s">  `(make-image x)` is the same as `(marshal x make-image-dict)`.``</span>
<span class="w">  </span><span class="p">@{})</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">comptime</span>
<span class="w">  </span><span class="s">&quot;Evals x at compile time and returns the result. Similar to a top level unquote.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">eval </span><span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">compif</span>
<span class="w">  </span><span class="s">&quot;Check the condition `cnd` at compile time -- if truthy, compile `tru`, else compile `fals`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">cnd</span><span class="w"> </span><span class="nv">tru</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">fals</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eval </span><span class="nv">cnd</span><span class="p">)</span>
<span class="w">    </span><span class="nv">tru</span>
<span class="w">    </span><span class="nv">fals</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">compwhen</span>
<span class="w">  </span><span class="s">&quot;Check the condition `cnd` at compile time -- if truthy, compile `(upscope ;body)`, else compile nil.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">cnd</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eval </span><span class="nv">cnd</span><span class="p">)</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="k">upscope </span><span class="o">,;</span><span class="nv">body</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">make-image</span>
<span class="w">  </span><span class="s">``Create an image from an environment returned by `require`.</span>
<span class="s">  Returns the image source as a string.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">env</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">marshal </span><span class="nv">env</span><span class="w"> </span><span class="nv">make-image-dict</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">load-image</span>
<span class="w">  </span><span class="s">&quot;The inverse operation to `make-image`. Returns an environment.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">image</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">unmarshal </span><span class="nv">image</span><span class="w"> </span><span class="nv">load-image-dict</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">check-dyn-relative</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">string/has-prefix? </span><span class="s">&quot;@&quot;</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn- </span><span class="nv">check-relative</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">string/has-prefix? </span><span class="s">&quot;.&quot;</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn- </span><span class="nv">check-not-relative</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">if-not </span><span class="p">(</span><span class="nb">string/has-prefix? </span><span class="s">&quot;.&quot;</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn- </span><span class="nv">check-is-dep</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">unless </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">string/has-prefix? </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string/has-prefix? </span><span class="s">&quot;@&quot;</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string/has-prefix? </span><span class="s">&quot;.&quot;</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defn- </span><span class="nv">check-project-relative</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">string/has-prefix? </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">module/cache</span>
<span class="w">  </span><span class="s">&quot;A table, mapping loaded module identifiers to their environments.&quot;</span>
<span class="w">  </span><span class="p">@{})</span>

<span class="p">(</span><span class="k">def </span><span class="nv">module/paths</span>
<span class="w">  </span><span class="s">```</span>
<span class="s">  The list of paths to look for modules, templated for `module/expand-path`.</span>
<span class="s">  Each element is a two-element tuple, containing the path</span>
<span class="s">  template and a keyword :source, :native, or :image indicating how</span>
<span class="s">  `require` should load files found at these paths.</span>

<span class="s">  A tuple can also</span>
<span class="s">  contain a third element, specifying a filter that prevents `module/find`</span>
<span class="s">  from searching that path template if the filter doesn&#39;t match the input</span>
<span class="s">  path. The filter can be a string or a predicate function, and</span>
<span class="s">  is often a file extension, including the period.</span>
<span class="s">  ```</span>
<span class="w">  </span><span class="p">@[])</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">module/add-paths</span>
<span class="w">  </span><span class="s">```</span>
<span class="s">  Add paths to `module/paths` for a given loader such that</span>
<span class="s">  the generated paths behave like other module types, including</span>
<span class="s">  relative imports and syspath imports. `ext` is the file extension</span>
<span class="s">  to associate with this module type, including the dot. `loader` is the</span>
<span class="s">  keyword name of a loader in `module/loaders`. Returns the modified `module/paths`.</span>
<span class="s">  ```</span>
<span class="w">  </span><span class="p">[</span><span class="nv">ext</span><span class="w"> </span><span class="nv">loader</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn- </span><span class="nv">find-prefix</span>
<span class="w">    </span><span class="p">[</span><span class="nv">pre</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">find-index </span><span class="o">|</span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">string? </span><span class="p">(</span><span class="nv">$</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">string/has-prefix? </span><span class="nv">pre</span><span class="w"> </span><span class="p">(</span><span class="nv">$</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span><span class="w"> </span><span class="nv">module/paths</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">dyn-index</span><span class="w"> </span><span class="p">(</span><span class="nv">find-prefix</span><span class="w"> </span><span class="s">&quot;:@all:&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">array/insert module/paths </span><span class="nv">dyn-index</span><span class="w"> </span><span class="p">[(</span><span class="nb">string </span><span class="s">&quot;:@all:&quot;</span><span class="w"> </span><span class="nv">ext</span><span class="p">)</span><span class="w"> </span><span class="nv">loader</span><span class="w"> </span><span class="nv">check-dyn-relative</span><span class="p">])</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">all-index</span><span class="w"> </span><span class="p">(</span><span class="nv">find-prefix</span><span class="w"> </span><span class="s">&quot;.:all:&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">array/insert module/paths </span><span class="nv">all-index</span><span class="w"> </span><span class="p">[(</span><span class="nb">string </span><span class="s">&quot;.:all:&quot;</span><span class="w"> </span><span class="nv">ext</span><span class="p">)</span><span class="w"> </span><span class="nv">loader</span><span class="w"> </span><span class="nv">check-project-relative</span><span class="p">])</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">sys-index</span><span class="w"> </span><span class="p">(</span><span class="nv">find-prefix</span><span class="w"> </span><span class="s">&quot;:sys:&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">array/insert module/paths </span><span class="nv">sys-index</span><span class="w"> </span><span class="p">[(</span><span class="nb">string </span><span class="s">&quot;:sys:/:all:&quot;</span><span class="w"> </span><span class="nv">ext</span><span class="p">)</span><span class="w"> </span><span class="nv">loader</span><span class="w"> </span><span class="nv">check-is-dep</span><span class="p">])</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">curall-index</span><span class="w"> </span><span class="p">(</span><span class="nv">find-prefix</span><span class="w"> </span><span class="s">&quot;:cur:/:all:&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">array/insert module/paths </span><span class="nv">curall-index</span><span class="w"> </span><span class="p">[(</span><span class="nb">string </span><span class="s">&quot;:cur:/:all:&quot;</span><span class="w"> </span><span class="nv">ext</span><span class="p">)</span><span class="w"> </span><span class="nv">loader</span><span class="w"> </span><span class="nv">check-relative</span><span class="p">])</span>
<span class="w">  </span><span class="nv">module/paths</span><span class="p">)</span>

<span class="p">(</span><span class="nb">module/add-paths </span><span class="s">&quot;:native:&quot;</span><span class="w"> </span><span class="no">:native</span><span class="p">)</span>
<span class="p">(</span><span class="nb">module/add-paths </span><span class="s">&quot;/init.janet&quot;</span><span class="w"> </span><span class="no">:source</span><span class="p">)</span>
<span class="p">(</span><span class="nb">module/add-paths </span><span class="s">&quot;.janet&quot;</span><span class="w"> </span><span class="no">:source</span><span class="p">)</span>
<span class="p">(</span><span class="nb">module/add-paths </span><span class="s">&quot;.jimage&quot;</span><span class="w"> </span><span class="no">:image</span><span class="p">)</span>
<span class="p">(</span><span class="nb">array/insert module/paths </span><span class="mf">0</span><span class="w"> </span><span class="p">[(</span><span class="k">fn </span><span class="nv">is-cached</span><span class="w"> </span><span class="p">[</span><span class="nv">path</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">in module/cache </span><span class="nv">path</span><span class="p">)</span><span class="w"> </span><span class="nv">path</span><span class="p">))</span><span class="w"> </span><span class="no">:preload</span><span class="w"> </span><span class="nv">check-not-relative</span><span class="p">])</span>

<span class="c1"># Version of fexists that works even with a reduced OS</span>
<span class="p">(</span><span class="nb">defn- </span><span class="nv">fexists</span>
<span class="w">  </span><span class="p">[</span><span class="nv">path</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">compif </span><span class="p">(</span><span class="nb">dyn </span><span class="o">&#39;</span><span class="nv">os/stat</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">= </span><span class="no">:file</span><span class="w"> </span><span class="p">(</span><span class="nb">os/stat </span><span class="nv">path</span><span class="w"> </span><span class="no">:mode</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">file/open </span><span class="nv">path</span><span class="w"> </span><span class="no">:rb</span><span class="p">)]</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">res</span>
<span class="w">        </span><span class="p">(</span><span class="nb">try </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">file/read </span><span class="nv">f</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">          </span><span class="p">([</span><span class="nv">err</span><span class="p">]</span><span class="w"> </span><span class="kc">nil</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">file/close </span><span class="nv">f</span><span class="p">)</span>
<span class="w">      </span><span class="nv">res</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">mod-filter</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="nv">path</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">type </span><span class="nv">x</span><span class="p">)</span>
<span class="w">    </span><span class="no">:nil</span><span class="w"> </span><span class="nv">path</span>
<span class="w">    </span><span class="no">:string</span><span class="w"> </span><span class="p">(</span><span class="nb">string/has-suffix? </span><span class="nv">x</span><span class="w"> </span><span class="nv">path</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="nv">path</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">module/find</span>
<span class="w">  </span><span class="s">```</span>
<span class="s">  Try to match a module or path name from the patterns in `module/paths`.</span>
<span class="s">  Returns a tuple (fullpath kind) where the kind is one of :source, :native,</span>
<span class="s">  or :image if the module is found, otherwise a tuple with nil followed by</span>
<span class="s">  an error message.</span>
<span class="s">  ```</span>
<span class="w">  </span><span class="p">[</span><span class="nv">path</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">ret</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="p">[</span><span class="nv">p</span><span class="w"> </span><span class="nv">mod-kind</span><span class="w"> </span><span class="nv">checker</span><span class="p">]</span><span class="w"> </span><span class="nv">module/paths</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nv">mod-filter</span><span class="w"> </span><span class="nv">checker</span><span class="w"> </span><span class="nv">path</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">function? </span><span class="nv">p</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nv">p</span><span class="w"> </span><span class="nv">path</span><span class="p">)]</span>
<span class="w">          </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="p">[</span><span class="nv">res</span><span class="w"> </span><span class="nv">mod-kind</span><span class="p">])</span>
<span class="w">          </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">do</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="nv">fullpath</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="p">(</span><span class="nb">module/expand-path </span><span class="nv">path</span><span class="w"> </span><span class="nv">p</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nv">fexists</span><span class="w"> </span><span class="nv">fullpath</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="k">set </span><span class="nv">ret</span><span class="w"> </span><span class="p">[</span><span class="nv">fullpath</span><span class="w"> </span><span class="nv">mod-kind</span><span class="p">])</span>
<span class="w">            </span><span class="p">(</span><span class="nv">break</span><span class="p">))))))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="nv">ret</span><span class="w"> </span><span class="nv">ret</span>
<span class="w">    </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">expander</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">t</span><span class="w"> </span><span class="nv">_</span><span class="w"> </span><span class="nv">chk</span><span class="p">]]</span>
<span class="w">                     </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">string? </span><span class="nv">t</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nv">mod-filter</span><span class="w"> </span><span class="nv">chk</span><span class="w"> </span><span class="nv">path</span><span class="p">)</span>
<span class="w">                         </span><span class="p">(</span><span class="nb">module/expand-path </span><span class="nv">path</span><span class="w"> </span><span class="nv">t</span><span class="p">))))</span>
<span class="w">          </span><span class="nv">paths</span><span class="w"> </span><span class="p">(</span><span class="nb">filter identity </span><span class="p">(</span><span class="nb">map </span><span class="nv">expander</span><span class="w"> </span><span class="nv">module/paths</span><span class="p">))</span>
<span class="w">          </span><span class="nv">str-parts</span><span class="w"> </span><span class="p">(</span><span class="nb">interpose </span><span class="s">&quot;\n    &quot;</span><span class="w"> </span><span class="nv">paths</span><span class="p">)]</span>
<span class="w">      </span><span class="p">[</span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;could not find module &quot;</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="s">&quot;:\n    &quot;</span><span class="w"> </span><span class="o">;</span><span class="nv">str-parts</span><span class="p">)])))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">module/loading</span>
<span class="w">  </span><span class="s">`A table, mapping currently loading modules to true. Used to prevent</span>
<span class="s">  circular dependencies.`</span>
<span class="w">  </span><span class="p">@{})</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">module/value</span>
<span class="w">  </span><span class="s">``Given a module table, get the value bound to a symbol `sym`. If `private` is</span>
<span class="s">  truthy, will also resolve private module symbols. If no binding is found, will return</span>
<span class="s">  nil.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">module</span><span class="w"> </span><span class="nv">sym</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">private</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">entry</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">module</span><span class="w"> </span><span class="nv">sym</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="nv">entry</span>
<span class="w">    </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">v</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">entry</span><span class="w"> </span><span class="no">:value</span><span class="p">)</span>
<span class="w">          </span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">entry</span><span class="w"> </span><span class="no">:ref</span><span class="p">)</span>
<span class="w">          </span><span class="nv">p</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">entry</span><span class="w"> </span><span class="no">:private</span><span class="p">)]</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="nv">p</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">private</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="nv">r</span><span class="w"> </span><span class="p">(</span><span class="nb">array? </span><span class="nv">r</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">get </span><span class="nv">r</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">        </span><span class="nv">v</span><span class="p">))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">debugger-env</span>
<span class="w">  </span><span class="s">&quot;An environment that contains dot prefixed functions for debugging.&quot;</span>
<span class="w">  </span><span class="p">@{})</span>

<span class="p">(</span><span class="nb">var- </span><span class="nv">debugger-on-status-var</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">debugger</span>
<span class="w">  </span><span class="s">&quot;Run a repl-based debugger on a fiber. Optionally pass in a level</span>
<span class="s">  to differentiate nested debuggers.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">fiber</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">level</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">level</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">nextenv</span><span class="w"> </span><span class="p">(</span><span class="nb">make-env </span><span class="p">(</span><span class="nb">fiber/getenv </span><span class="nv">fiber</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">put </span><span class="nv">nextenv</span><span class="w"> </span><span class="no">:fiber</span><span class="w"> </span><span class="nv">fiber</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">put </span><span class="nv">nextenv</span><span class="w"> </span><span class="no">:debug-level</span><span class="w"> </span><span class="nv">level</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">put </span><span class="nv">nextenv</span><span class="w"> </span><span class="no">:signal</span><span class="w"> </span><span class="p">(</span><span class="nb">fiber/last-value </span><span class="nv">fiber</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">merge-into </span><span class="nv">nextenv</span><span class="w"> </span><span class="nv">debugger-env</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">debugger-chunks</span><span class="w"> </span><span class="p">[</span><span class="nv">buf</span><span class="w"> </span><span class="nv">p</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">status</span><span class="w"> </span><span class="p">(</span><span class="no">:state</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="no">:delimiters</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">c</span><span class="w"> </span><span class="p">((</span><span class="no">:where</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">prpt</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;debug[&quot;</span><span class="w"> </span><span class="nv">level</span><span class="w"> </span><span class="s">&quot;]:&quot;</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="nv">status</span><span class="w"> </span><span class="s">&quot;&gt; &quot;</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">getline </span><span class="nv">prpt</span><span class="w"> </span><span class="nv">buf</span><span class="w"> </span><span class="nv">nextenv</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;entering debug[&quot;</span><span class="w"> </span><span class="nv">level</span><span class="w"> </span><span class="s">&quot;] - (quit) to exit&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">flush</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">run-context</span>
<span class="w">    </span><span class="p">{</span><span class="no">:chunks</span><span class="w"> </span><span class="nv">debugger-chunks</span>
<span class="w">     </span><span class="no">:on-status</span><span class="w"> </span><span class="p">(</span><span class="nv">debugger-on-status-var</span><span class="w"> </span><span class="nv">nextenv</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="mf">1</span><span class="w"> </span><span class="nv">level</span><span class="p">)</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">     </span><span class="no">:env</span><span class="w"> </span><span class="nv">nextenv</span><span class="p">})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;exiting debug[&quot;</span><span class="w"> </span><span class="nv">level</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">flush</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">nextenv</span><span class="w"> </span><span class="no">:resume-value</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">debugger-on-status</span>
<span class="w">  </span><span class="s">&quot;Create a function that can be passed to `run-context`&#39;s `:on-status`</span>
<span class="s">  argument that will drop into a debugger on errors. The debugger will</span>
<span class="s">  only start on abnormal signals if the env table has the `:debug` dyn</span>
<span class="s">  set to a truthy value.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">env</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">level</span><span class="w"> </span><span class="nv">is-repl</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">level</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">fs</span><span class="w"> </span><span class="p">(</span><span class="nb">fiber/status </span><span class="nv">f</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="no">:dead</span><span class="w"> </span><span class="nv">fs</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">when </span><span class="nv">is-repl</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="o">&#39;</span><span class="nv">_</span><span class="w"> </span><span class="p">@{</span><span class="no">:value</span><span class="w"> </span><span class="nv">x</span><span class="p">})</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">pf</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">env</span><span class="w"> </span><span class="nv">*pretty-format*</span><span class="w"> </span><span class="s">&quot;%q&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">try</span>
<span class="w">          </span><span class="p">(</span><span class="nb">printf </span><span class="nv">pf</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">          </span><span class="p">([</span><span class="nv">e</span><span class="p">]</span>
<span class="w">            </span><span class="p">(</span><span class="nb">eprintf </span><span class="s">&quot;bad pretty format %v: %v&quot;</span><span class="w"> </span><span class="nv">pf</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nv">eflush</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">flush</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="nb">debug/stacktrace </span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nv">eflush</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">get </span><span class="nv">env</span><span class="w"> </span><span class="no">:debug</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">debugger </span><span class="nv">f</span><span class="w"> </span><span class="nv">level</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">set </span><span class="nv">debugger-on-status-var</span><span class="w"> </span><span class="nv">debugger-on-status</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">dofile</span>
<span class="w">  </span><span class="s">``Evaluate a file, file path, or stream and return the resulting environment. :env, :expander,</span>
<span class="s">  :source, :evaluator, :read, and :parser are passed through to the underlying</span>
<span class="s">  `run-context` call. If `exit` is true, any top level errors will trigger a</span>
<span class="s">  call to `(os/exit 1)` after printing the error.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">&amp;named</span><span class="w"> </span><span class="nv">exit</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">source</span><span class="w"> </span><span class="nv">expander</span><span class="w"> </span><span class="nv">evaluator</span><span class="w"> </span><span class="nv">read</span><span class="w"> </span><span class="nv">parser</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">type </span><span class="nv">path</span><span class="p">)</span>
<span class="w">           </span><span class="no">:core/file</span><span class="w"> </span><span class="nv">path</span>
<span class="w">           </span><span class="no">:core/stream</span><span class="w"> </span><span class="nv">path</span>
<span class="w">           </span><span class="p">(</span><span class="nb">file/open </span><span class="nv">path</span><span class="w"> </span><span class="no">:rb</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">path-is-file</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="nv">f</span><span class="w"> </span><span class="nv">path</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">env</span><span class="w"> </span><span class="p">(</span><span class="nv">make-env</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">spath</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="nv">path</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="no">:source</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">source</span><span class="w"> </span><span class="p">(</span><span class="nb">if-not </span><span class="nv">path-is-file</span><span class="w"> </span><span class="nv">spath</span><span class="w"> </span><span class="nv">path</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">exit-error</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">exit-fiber</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">chunks</span><span class="w"> </span><span class="p">[</span><span class="nv">buf</span><span class="w"> </span><span class="nv">_</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="no">:read</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="mf">4096</span><span class="w"> </span><span class="nv">buf</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">bp</span><span class="w"> </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="nv">exit</span>
<span class="w">      </span><span class="p">(</span><span class="nb">bad-parse </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">os/exit </span><span class="mf">1</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="no">:exit</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">buf</span><span class="w"> </span><span class="s">@&quot;&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">with-dyns </span><span class="p">[</span><span class="nv">*err*</span><span class="w"> </span><span class="nv">buf</span><span class="w"> </span><span class="nv">*err-color*</span><span class="w"> </span><span class="kc">false</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">bad-parse </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">exit-error</span><span class="w"> </span><span class="p">(</span><span class="nb">string/slice </span><span class="nv">buf</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="mf">-2</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">bc</span><span class="w"> </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="nv">z</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="nv">exit</span>
<span class="w">      </span><span class="p">(</span><span class="nb">bad-compile </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="nv">z</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">os/exit </span><span class="mf">1</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="no">:exit</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">buf</span><span class="w"> </span><span class="s">@&quot;&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">with-dyns </span><span class="p">[</span><span class="nv">*err*</span><span class="w"> </span><span class="nv">buf</span><span class="w"> </span><span class="nv">*err-color*</span><span class="w"> </span><span class="kc">false</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">bad-compile </span><span class="nv">x</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="nv">z</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">exit-error</span><span class="w"> </span><span class="p">(</span><span class="nb">string/slice </span><span class="nv">buf</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="mf">-2</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">exit-fiber</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">unless </span><span class="nv">f</span>
<span class="w">    </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;could not find file &quot;</span><span class="w"> </span><span class="nv">path</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">nenv</span>
<span class="w">    </span><span class="p">(</span><span class="nb">run-context </span><span class="p">{</span><span class="no">:env</span><span class="w"> </span><span class="nv">env</span>
<span class="w">                  </span><span class="no">:chunks</span><span class="w"> </span><span class="nv">chunks</span>
<span class="w">                  </span><span class="no">:on-parse-error</span><span class="w"> </span><span class="nv">bp</span>
<span class="w">                  </span><span class="no">:on-compile-error</span><span class="w"> </span><span class="nv">bc</span>
<span class="w">                  </span><span class="no">:on-status</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">]</span>
<span class="w">                               </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">not= </span><span class="p">(</span><span class="nb">fiber/status </span><span class="nv">f</span><span class="p">)</span><span class="w"> </span><span class="no">:dead</span><span class="p">)</span>
<span class="w">                                 </span><span class="p">(</span><span class="nb">when </span><span class="nv">exit</span>
<span class="w">                                   </span><span class="p">(</span><span class="nb">debug/stacktrace </span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="w">                                   </span><span class="p">(</span><span class="nv">eflush</span><span class="p">)</span>
<span class="w">                                   </span><span class="p">(</span><span class="nb">os/exit </span><span class="mf">1</span><span class="p">))</span>
<span class="w">                                 </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">get </span><span class="nv">env</span><span class="w"> </span><span class="no">:debug</span><span class="p">)</span>
<span class="w">                                   </span><span class="p">((</span><span class="nb">debugger-on-status </span><span class="nv">env</span><span class="p">)</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">                                   </span><span class="p">(</span><span class="nv">do</span>
<span class="w">                                     </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="no">:exit</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">                                     </span><span class="p">(</span><span class="k">set </span><span class="nv">exit-error</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">                                     </span><span class="p">(</span><span class="k">set </span><span class="nv">exit-fiber</span><span class="w"> </span><span class="nv">f</span><span class="p">)))))</span>
<span class="w">                  </span><span class="no">:evaluator</span><span class="w"> </span><span class="nv">evaluator</span>
<span class="w">                  </span><span class="no">:expander</span><span class="w"> </span><span class="nv">expander</span>
<span class="w">                  </span><span class="no">:read</span><span class="w"> </span><span class="nv">read</span>
<span class="w">                  </span><span class="no">:parser</span><span class="w"> </span><span class="nv">parser</span>
<span class="w">                  </span><span class="no">:source</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">source</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">path-is-file</span><span class="w"> </span><span class="no">:&lt;anonymous&gt;</span><span class="w"> </span><span class="nv">spath</span><span class="p">))}))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">if-not </span><span class="nv">path-is-file</span><span class="w"> </span><span class="p">(</span><span class="no">:close</span><span class="w"> </span><span class="nv">f</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="nv">exit-error</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="nv">exit-fiber</span>
<span class="w">      </span><span class="p">(</span><span class="nb">propagate </span><span class="nv">exit-error</span><span class="w"> </span><span class="nv">exit-fiber</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">error </span><span class="nv">exit-error</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">nenv</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">module/loaders</span>
<span class="w">  </span><span class="s">``A table of loading method names to loading functions.</span>
<span class="s">  This table lets `require` and `import` load many different kinds</span>
<span class="s">  of files as modules.``</span>
<span class="w">  </span><span class="p">@{</span><span class="no">:native</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="nv">native-loader</span><span class="w"> </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">native </span><span class="nv">path</span><span class="w"> </span><span class="p">(</span><span class="nv">make-env</span><span class="p">)))</span>
<span class="w">    </span><span class="no">:source</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="nv">source-loader</span><span class="w"> </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">              </span><span class="p">(</span><span class="nb">put module/loading </span><span class="nv">path</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">defer </span><span class="p">(</span><span class="nb">put module/loading </span><span class="nv">path</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nb">dofile </span><span class="nv">path</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">)))</span>
<span class="w">    </span><span class="no">:preload</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="nv">preload-loader</span><span class="w"> </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">               </span><span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">m</span><span class="w"> </span><span class="p">(</span><span class="nb">in module/cache </span><span class="nv">path</span><span class="p">)]</span>
<span class="w">                 </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">function? </span><span class="nv">m</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="k">set </span><span class="p">(</span><span class="nb">module/cache </span><span class="nv">path</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">m</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">))</span>
<span class="w">                   </span><span class="nv">m</span><span class="p">)))</span>
<span class="w">    </span><span class="no">:image</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="nv">image-loader</span><span class="w"> </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">load-image </span><span class="p">(</span><span class="nb">slurp </span><span class="nv">path</span><span class="p">)))})</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">require-1</span>
<span class="w">  </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">args</span><span class="w"> </span><span class="nv">kargs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">fullpath</span><span class="w"> </span><span class="nv">mod-kind</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">module/find </span><span class="nv">path</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">unless </span><span class="nv">fullpath</span><span class="w"> </span><span class="p">(</span><span class="nb">error </span><span class="nv">mod-kind</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">check</span><span class="w"> </span><span class="p">(</span><span class="nb">if-not </span><span class="p">(</span><span class="nv">kargs</span><span class="w"> </span><span class="no">:fresh</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">in module/cache </span><span class="nv">fullpath</span><span class="p">))]</span>
<span class="w">    </span><span class="nv">check</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">module/loading </span><span class="nv">fullpath</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;circular dependency &quot;</span><span class="w"> </span><span class="nv">fullpath</span><span class="w"> </span><span class="s">&quot; detected&quot;</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">loader</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">keyword? </span><span class="nv">mod-kind</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">module/loaders </span><span class="nv">mod-kind</span><span class="p">)</span><span class="w"> </span><span class="nv">mod-kind</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">unless </span><span class="nv">loader</span><span class="w"> </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;module type &quot;</span><span class="w"> </span><span class="nv">mod-kind</span><span class="w"> </span><span class="s">&quot; unknown&quot;</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">env</span><span class="w"> </span><span class="p">(</span><span class="nv">loader</span><span class="w"> </span><span class="nv">fullpath</span><span class="w"> </span><span class="nv">args</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put module/cache </span><span class="nv">fullpath</span><span class="w"> </span><span class="nv">env</span><span class="p">)</span>
<span class="w">        </span><span class="nv">env</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">require</span>
<span class="w">  </span><span class="s">``Require a module with the given name. Will search all of the paths in</span>
<span class="s">  `module/paths`. Returns the new environment</span>
<span class="s">  returned from compiling and running the file.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">require-1</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">struct </span><span class="o">;</span><span class="nv">args</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">merge-module</span>
<span class="w">  </span><span class="s">``Merge a module source into the `target` environment with a `prefix`, as with the `import` macro.</span>
<span class="s">  This lets users emulate the behavior of `import` with a custom module table.</span>
<span class="s">  If `export` is truthy, then merged functions are not marked as private. Returns</span>
<span class="s">  the modified target environment.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">target</span><span class="w"> </span><span class="nv">source</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">prefix</span><span class="w"> </span><span class="nv">export</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[[</span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="no">:pairs</span><span class="w"> </span><span class="nv">source</span><span class="w"> </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol? </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nv">v</span><span class="w"> </span><span class="no">:private</span><span class="p">))]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">newv</span><span class="w"> </span><span class="p">(</span><span class="nb">table/setproto </span><span class="p">@{</span><span class="no">:private</span><span class="w"> </span><span class="p">(</span><span class="nb">not </span><span class="nv">export</span><span class="p">)}</span><span class="w"> </span><span class="nv">v</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">target</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol </span><span class="nv">prefix</span><span class="w"> </span><span class="nv">k</span><span class="p">)</span><span class="w"> </span><span class="nv">newv</span><span class="p">))</span>
<span class="w">  </span><span class="nv">target</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">import*</span>
<span class="w">  </span><span class="s">``Function form of `import`. Same parameters, but the path</span>
<span class="s">  and other symbol parameters should be strings instead.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">env</span><span class="w"> </span><span class="p">(</span><span class="nv">curenv</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">kargs</span><span class="w"> </span><span class="p">(</span><span class="nb">table </span><span class="o">;</span><span class="nv">args</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="p">{</span><span class="no">:as</span><span class="w"> </span><span class="nv">as</span>
<span class="w">        </span><span class="no">:prefix</span><span class="w"> </span><span class="nv">prefix</span>
<span class="w">        </span><span class="no">:export</span><span class="w"> </span><span class="nv">ep</span><span class="p">}</span><span class="w"> </span><span class="nv">kargs</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">newenv</span><span class="w"> </span><span class="p">(</span><span class="nv">require-1</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="nv">args</span><span class="w"> </span><span class="nv">kargs</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">prefix</span><span class="w"> </span><span class="p">(</span><span class="nv">or</span>
<span class="w">                </span><span class="p">(</span><span class="nb">and </span><span class="nv">as</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="nv">as</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">))</span>
<span class="w">                </span><span class="nv">prefix</span>
<span class="w">                </span><span class="p">(</span><span class="nb">string </span><span class="p">(</span><span class="nb">last </span><span class="p">(</span><span class="nb">string/split </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="nv">path</span><span class="p">))</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">merge-module </span><span class="nv">env</span><span class="w"> </span><span class="nv">newenv</span><span class="w"> </span><span class="nv">prefix</span><span class="w"> </span><span class="nv">ep</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">import</span>
<span class="w">  </span><span class="s">``Import a module. First requires the module, and then merges its</span>
<span class="s">  symbols into the current environment, prepending a given prefix as needed.</span>
<span class="s">  (use the :as or :prefix option to set a prefix). If no prefix is provided,</span>
<span class="s">  use the name of the module as a prefix. One can also use &quot;`:export true`&quot;</span>
<span class="s">  to re-export the imported symbols. If &quot;`:exit true`&quot; is given as an argument,</span>
<span class="s">  any errors encountered at the top level in the module will cause `(os/exit 1)`</span>
<span class="s">  to be called. Dynamic bindings will NOT be imported. Use :fresh to bypass the</span>
<span class="s">  module cache.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ps</span><span class="w"> </span><span class="p">(</span><span class="nb">partition </span><span class="mf">2</span><span class="w"> </span><span class="nv">args</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">argm</span><span class="w"> </span><span class="p">(</span><span class="nb">mapcat </span><span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">]]</span><span class="w"> </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">k</span><span class="w"> </span><span class="no">:as</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="nv">v</span><span class="p">)</span><span class="w"> </span><span class="nv">v</span><span class="p">)])</span><span class="w"> </span><span class="nv">ps</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">tuple import* </span><span class="p">(</span><span class="nb">string </span><span class="nv">path</span><span class="p">)</span><span class="w"> </span><span class="o">;</span><span class="nv">argm</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">use</span>
<span class="w">  </span><span class="s">``Similar to `import`, but imported bindings are not prefixed with a module</span>
<span class="s">  identifier. Can also import multiple modules in one shot.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">modules</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="p">(</span><span class="nb">map </span><span class="o">|~</span><span class="p">(</span><span class="o">,</span><span class="nb">import* </span><span class="o">,</span><span class="p">(</span><span class="nb">string </span><span class="nv">$</span><span class="p">)</span><span class="w"> </span><span class="no">:prefix</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">modules</span><span class="p">)))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Documentation</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">env-walk</span>
<span class="w">  </span><span class="p">[</span><span class="nv">pred</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">local</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">env</span><span class="w"> </span><span class="p">(</span><span class="nb">fiber/getenv </span><span class="p">(</span><span class="nv">fiber/current</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">envs</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">  </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">var </span><span class="nv">e</span><span class="w"> </span><span class="nv">env</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">while </span><span class="nv">e</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">envs</span><span class="w"> </span><span class="nv">e</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">e</span><span class="w"> </span><span class="p">(</span><span class="nb">table/getproto </span><span class="nv">e</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">local</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">ret-set</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">envi</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">envs</span>
<span class="w">         </span><span class="nv">k</span><span class="w"> </span><span class="no">:keys</span><span class="w"> </span><span class="nv">envi</span>
<span class="w">         </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nv">pred</span><span class="w"> </span><span class="nv">k</span><span class="p">)]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">ret-set</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">keys </span><span class="nv">ret-set</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">all-bindings</span>
<span class="w">  </span><span class="s">``Get all symbols available in an environment. Defaults to the current</span>
<span class="s">  fiber&#39;s environment. If `local` is truthy, will not show inherited bindings</span>
<span class="s">  (from prototype tables).``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">local</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">env-walk</span><span class="w"> </span><span class="nb">symbol? </span><span class="nv">env</span><span class="w"> </span><span class="nv">local</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">all-dynamics</span>
<span class="w">  </span><span class="s">``Get all dynamic bindings in an environment. Defaults to the current</span>
<span class="s">  fiber&#39;s environment. If `local` is truthy, will not show inherited bindings</span>
<span class="s">  (from prototype tables).``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">local</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">env-walk</span><span class="w"> </span><span class="nb">keyword? </span><span class="nv">env</span><span class="w"> </span><span class="nv">local</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*doc-width*</span>
<span class="w">  </span><span class="s">&quot;Width in columns to print documentation printed with `doc-format`.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*doc-color*</span>
<span class="w">  </span><span class="s">&quot;Whether or not to colorize documentation printed with `doc-format`.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">doc-format</span>
<span class="w">  </span><span class="s">`Reformat a docstring to wrap a certain width. Docstrings can either be plaintext</span>
<span class="s">  or a subset of markdown. This allows a long single line of prose or formatted text to be</span>
<span class="s">  a well-formed docstring. Returns a buffer containing the formatted text.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">str</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">width</span><span class="w"> </span><span class="nv">indent</span><span class="w"> </span><span class="nv">colorize</span><span class="p">]</span>

<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">indent</span><span class="w"> </span><span class="mf">4</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">max-width</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">or </span><span class="nv">width</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*doc-width*</span><span class="w"> </span><span class="mf">80</span><span class="p">))</span><span class="w"> </span><span class="mf">8</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">has-color</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not= </span><span class="kc">nil</span><span class="w"> </span><span class="nv">colorize</span><span class="p">)</span>
<span class="w">                   </span><span class="nv">colorize</span>
<span class="w">                   </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*doc-color*</span><span class="p">)))</span>

<span class="w">  </span><span class="c1"># Terminal codes for emission/tokenization</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">delimiters</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="nv">has-color</span>
<span class="w">      </span><span class="p">{</span><span class="no">:underline</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;\e[4m&quot;</span><span class="w"> </span><span class="s">&quot;\e[24m&quot;</span><span class="p">]</span>
<span class="w">       </span><span class="no">:code</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;\e[97m&quot;</span><span class="w"> </span><span class="s">&quot;\e[39m&quot;</span><span class="p">]</span>
<span class="w">       </span><span class="no">:italics</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;\e[4m&quot;</span><span class="w"> </span><span class="s">&quot;\e[24m&quot;</span><span class="p">]</span>
<span class="w">       </span><span class="no">:bold</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;\e[1m&quot;</span><span class="w"> </span><span class="s">&quot;\e[22m&quot;</span><span class="p">]}</span>
<span class="w">      </span><span class="p">{</span><span class="no">:underline</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;_&quot;</span><span class="w"> </span><span class="s">&quot;_&quot;</span><span class="p">]</span>
<span class="w">       </span><span class="no">:code</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;`&quot;</span><span class="w"> </span><span class="s">&quot;`&quot;</span><span class="p">]</span>
<span class="w">       </span><span class="no">:italics</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;*&quot;</span><span class="w"> </span><span class="s">&quot;*&quot;</span><span class="p">]</span>
<span class="w">       </span><span class="no">:bold</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;**&quot;</span><span class="w"> </span><span class="s">&quot;**&quot;</span><span class="p">]}))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">modes</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">toggle-mode</span><span class="w"> </span><span class="p">[</span><span class="nv">mode</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">active</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">modes</span><span class="w"> </span><span class="nv">mode</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">delims</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">delimiters</span><span class="w"> </span><span class="nv">mode</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">put </span><span class="nv">modes</span><span class="w"> </span><span class="nv">mode</span><span class="w"> </span><span class="p">(</span><span class="nb">not </span><span class="nv">active</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">delims</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">active</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span>

<span class="w">  </span><span class="c1"># Parse state</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">cursor</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="c1"># indexes into string for parsing</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">stack</span><span class="w"> </span><span class="p">@[])</span><span class="w"> </span><span class="c1"># return value for this block.</span>

<span class="w">  </span><span class="c1"># Traversal helpers</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">c</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">str</span><span class="w"> </span><span class="nv">cursor</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">cn</span><span class="w"> </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">str</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">n</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">c++</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">str</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">++ </span><span class="nv">cursor</span><span class="p">)</span><span class="w"> </span><span class="nv">ret</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">c+=n</span><span class="w"> </span><span class="p">[</span><span class="nv">n</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">ret</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">str</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">+= </span><span class="nv">cursor</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="nv">ret</span><span class="p">))</span>
<span class="w">  </span><span class="c1"># skip* functions return number of characters matched and advance the cursor.</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">skipwhite</span><span class="w"> </span><span class="p">[]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot; &quot;</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">++ </span><span class="nv">cursor</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">- </span><span class="nv">cursor</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">skipline</span><span class="w"> </span><span class="p">[]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">y</span><span class="w"> </span><span class="p">(</span><span class="nv">c</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">and </span><span class="nv">y</span><span class="w"> </span><span class="p">(</span><span class="nb">not= </span><span class="nv">y</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;\n&quot;</span><span class="p">))))</span><span class="w"> </span><span class="p">(</span><span class="nb">++ </span><span class="nv">cursor</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">c++</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">- </span><span class="nv">cursor</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>

<span class="w">  </span><span class="c1"># Detection helpers - return number of characters matched</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">ul?</span><span class="w"> </span><span class="p">[]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="nv">x1</span><span class="w"> </span><span class="p">(</span><span class="nv">cn</span><span class="w"> </span><span class="mf">1</span><span class="p">)]</span>
<span class="w">      </span><span class="p">(</span><span class="nv">and</span>
<span class="w">        </span><span class="p">(</span><span class="nb">= </span><span class="nv">x1</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot; &quot;</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;*&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;-&quot;</span><span class="p">)))</span>
<span class="w">        </span><span class="mf">2</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">ol?</span><span class="w"> </span><span class="p">[]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">old</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;0&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;9&quot;</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="nv">c++</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">c1</span><span class="w"> </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="nv">c2</span><span class="w"> </span><span class="p">(</span><span class="nv">cn</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nv">c*</span><span class="w"> </span><span class="nv">cursor</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">cursor</span><span class="w"> </span><span class="nv">old</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">c1</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;.&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="nv">c2</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot; &quot;</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">- </span><span class="nv">c*</span><span class="w"> </span><span class="nv">cursor</span><span class="w"> </span><span class="mf">-2</span><span class="p">))))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">fcb?</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;`&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">cn</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">cn</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span><span class="w"> </span><span class="mf">3</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">nl?</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;\n&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">c</span><span class="p">)))</span>

<span class="w">  </span><span class="c1"># Parse helper</span>
<span class="w">  </span><span class="c1"># parse-* functions push nodes to `stack`, and return</span>
<span class="w">  </span><span class="c1"># the indentation they leave the cursor on.</span>

<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">parse-blocks</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span><span class="w"> </span><span class="c1"># mutual recursion</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">getslice</span><span class="w"> </span><span class="p">[</span><span class="nv">from</span><span class="w"> </span><span class="nv">to</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">to</span><span class="w"> </span><span class="p">(</span><span class="nb">min </span><span class="nv">to</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">str</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">string/slice </span><span class="nv">str</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">to</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">push</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">stack</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">parse-list</span><span class="w"> </span><span class="p">[</span><span class="nv">bullet-check</span><span class="w"> </span><span class="nv">initial</span><span class="w"> </span><span class="nv">indent</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">temp-stack</span><span class="w"> </span><span class="p">@[</span><span class="nv">initial</span><span class="p">])</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">old-stack</span><span class="w"> </span><span class="nv">stack</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">stack</span><span class="w"> </span><span class="nv">temp-stack</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">current-indent</span><span class="w"> </span><span class="nv">indent</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">current-indent</span><span class="w"> </span><span class="nv">indent</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">item-indent</span>
<span class="w">        </span><span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nv">bullet-check</span><span class="p">)]</span>
<span class="w">          </span><span class="p">(</span><span class="nv">c+=n</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">+ </span><span class="nv">indent</span><span class="w"> </span><span class="p">(</span><span class="nv">skipwhite</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">unless </span><span class="nv">item-indent</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="nv">current-indent</span><span class="w"> </span><span class="p">(</span><span class="nv">skipwhite</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">item-stack</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">stack</span><span class="w"> </span><span class="nv">item-stack</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">current-indent</span><span class="w"> </span><span class="p">(</span><span class="nv">parse-blocks</span><span class="w"> </span><span class="nv">item-indent</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">stack</span><span class="w"> </span><span class="nv">temp-stack</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">push</span><span class="w"> </span><span class="nv">item-stack</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">stack</span><span class="w"> </span><span class="nv">old-stack</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">push</span><span class="w"> </span><span class="nv">temp-stack</span><span class="p">)</span>
<span class="w">    </span><span class="nv">current-indent</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">add-codeblock</span><span class="w"> </span><span class="p">[</span><span class="nv">indent</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">end</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">replace-chunk</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">string/repeat </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="nv">indent</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">push</span><span class="w"> </span><span class="p">@[</span><span class="no">:cb</span><span class="w"> </span><span class="p">(</span><span class="nb">string/replace-all </span><span class="nv">replace-chunk</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nv">getslice</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">end</span><span class="p">))])</span>
<span class="w">    </span><span class="p">(</span><span class="nv">skipline</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">skipwhite</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">parse-fcb</span><span class="w"> </span><span class="p">[</span><span class="nv">indent</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nv">c+=n</span><span class="w"> </span><span class="mf">3</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">skipline</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">c+=n</span><span class="w"> </span><span class="nv">indent</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">start</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">end</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nv">fcb?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">skipline</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">end</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">skipwhite</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">add-codeblock</span><span class="w"> </span><span class="nv">indent</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">end</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">parse-icb</span><span class="w"> </span><span class="p">[</span><span class="nv">indent</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">current-indent</span><span class="w"> </span><span class="nv">indent</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">start</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">end</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">skipline</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">end</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">current-indent</span><span class="w"> </span><span class="p">(</span><span class="nv">skipwhite</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">current-indent</span><span class="w"> </span><span class="nv">indent</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">break</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">add-codeblock</span><span class="w"> </span><span class="nv">indent</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">end</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">tokenize-line</span><span class="w"> </span><span class="p">[</span><span class="nv">line</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">tokens</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">token</span><span class="w"> </span><span class="s">@&quot;&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">token-length</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">defn </span><span class="nv">delim</span><span class="w"> </span><span class="p">[</span><span class="nv">mode</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">d</span><span class="w"> </span><span class="p">(</span><span class="nv">toggle-mode</span><span class="w"> </span><span class="nv">mode</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">if-not </span><span class="nv">has-color</span><span class="w"> </span><span class="p">(</span><span class="nb">+= </span><span class="nv">token-length</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">d</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">buffer/push </span><span class="nv">token</span><span class="w"> </span><span class="nv">d</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">defn </span><span class="nv">endtoken</span><span class="w"> </span><span class="p">[]</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">first </span><span class="nv">token</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">array/push </span><span class="nv">tokens</span><span class="w"> </span><span class="p">[(</span><span class="nb">string </span><span class="nv">token</span><span class="p">)</span><span class="w"> </span><span class="nv">token-length</span><span class="p">]))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">buffer/clear </span><span class="nv">token</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">token-length</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">line</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">b</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">line</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">        </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">b</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;\n&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="nv">b</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot; &quot;</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="nv">endtoken</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">= </span><span class="nv">b</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;`&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nv">delim</span><span class="w"> </span><span class="no">:code</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nv">modes</span><span class="w"> </span><span class="no">:code</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">          </span><span class="p">(</span><span class="nb">= </span><span class="nv">b</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">`\`</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nv">do</span>
<span class="w">                            </span><span class="p">(</span><span class="nb">++ </span><span class="nv">token-length</span><span class="p">)</span>
<span class="w">                            </span><span class="p">(</span><span class="nb">buffer/push </span><span class="nv">token</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">line</span><span class="w"> </span><span class="p">(</span><span class="nb">++ </span><span class="nv">i</span><span class="p">))))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">= </span><span class="nv">b</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;_&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nv">delim</span><span class="w"> </span><span class="no">:underline</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">= </span><span class="nv">b</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;*&quot;</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;*&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">line</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">            </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">++ </span><span class="nv">i</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nv">delim</span><span class="w"> </span><span class="no">:bold</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nv">delim</span><span class="w"> </span><span class="no">:italics</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">++ </span><span class="nv">token-length</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">buffer/push </span><span class="nv">token</span><span class="w"> </span><span class="nv">b</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">++ </span><span class="nv">token-length</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">buffer/push </span><span class="nv">token</span><span class="w"> </span><span class="nv">b</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">endtoken</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">tokens</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nv">set</span>
<span class="w">    </span><span class="nv">parse-blocks</span>
<span class="w">    </span><span class="p">(</span><span class="k">fn </span><span class="nv">parse-blocks</span><span class="w"> </span><span class="p">[</span><span class="nv">indent</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="nv">new-indent</span><span class="w"> </span><span class="nv">indent</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="nv">p-start</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="nv">p-end</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">defn </span><span class="nv">p-line</span><span class="w"> </span><span class="p">[]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">unless </span><span class="nv">p-start</span>
<span class="w">          </span><span class="p">(</span><span class="k">set </span><span class="nv">p-start</span><span class="w"> </span><span class="nv">cursor</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">skipline</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="nv">p-end</span><span class="w"> </span><span class="nv">cursor</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="nv">new-indent</span><span class="w"> </span><span class="p">(</span><span class="nv">skipwhite</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">defn </span><span class="nv">finish-p</span><span class="w"> </span><span class="p">[]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">and </span><span class="nv">p-start</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">p-end</span><span class="w"> </span><span class="nv">p-start</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nv">push</span><span class="w"> </span><span class="p">(</span><span class="nv">tokenize-line</span><span class="w"> </span><span class="p">(</span><span class="nv">getslice</span><span class="w"> </span><span class="nv">p-start</span><span class="w"> </span><span class="nv">p-end</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="k">set </span><span class="nv">p-start</span><span class="w"> </span><span class="kc">nil</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">new-indent</span><span class="w"> </span><span class="nv">indent</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">          </span><span class="p">(</span><span class="nv">nl?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nv">finish-p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">c++</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">new-indent</span><span class="w"> </span><span class="p">(</span><span class="nv">skipwhite</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nv">ul?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nv">finish-p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">new-indent</span><span class="w"> </span><span class="p">(</span><span class="nv">parse-list</span><span class="w"> </span><span class="nv">ul?</span><span class="w"> </span><span class="no">:ul</span><span class="w"> </span><span class="nv">new-indent</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nv">ol?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nv">finish-p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">new-indent</span><span class="w"> </span><span class="p">(</span><span class="nv">parse-list</span><span class="w"> </span><span class="nv">ol?</span><span class="w"> </span><span class="no">:ol</span><span class="w"> </span><span class="nv">new-indent</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nv">fcb?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nv">finish-p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">new-indent</span><span class="w"> </span><span class="p">(</span><span class="nv">parse-fcb</span><span class="w"> </span><span class="nv">new-indent</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">new-indent</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="mf">4</span><span class="w"> </span><span class="nv">indent</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nv">finish-p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">new-indent</span><span class="w"> </span><span class="p">(</span><span class="nv">parse-icb</span><span class="w"> </span><span class="nv">new-indent</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nv">p-line</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">finish-p</span><span class="p">)</span>
<span class="w">      </span><span class="nv">new-indent</span><span class="p">))</span>

<span class="w">  </span><span class="c1"># Handle first line specially for defn, defmacro, etc.</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;(&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">str</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">skipline</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">first-line</span><span class="w"> </span><span class="p">(</span><span class="nb">string/slice </span><span class="nv">str</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="nv">cursor</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">fl-open</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">has-color</span><span class="w"> </span><span class="s">&quot;\e[97m&quot;</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">fl-close</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">has-color</span><span class="w"> </span><span class="s">&quot;\e[39m&quot;</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">push</span><span class="w"> </span><span class="p">[[(</span><span class="nb">string </span><span class="nv">fl-open</span><span class="w"> </span><span class="nv">first-line</span><span class="w"> </span><span class="nv">fl-close</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">first-line</span><span class="p">)]]))</span>

<span class="w">  </span><span class="p">(</span><span class="nv">parse-blocks</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>

<span class="w">  </span><span class="c1"># Emission state</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">buf</span><span class="w"> </span><span class="s">@&quot;&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">current-column</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>

<span class="w">  </span><span class="c1"># Emission</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">emit-indent</span><span class="w"> </span><span class="p">[</span><span class="nv">indent</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">delta</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="nv">indent</span><span class="w"> </span><span class="nv">current-column</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&lt; </span><span class="mf">0</span><span class="w"> </span><span class="nv">delta</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">buffer/push </span><span class="nv">buf</span><span class="w"> </span><span class="p">(</span><span class="nb">string/repeat </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="nv">delta</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">current-column</span><span class="w"> </span><span class="nv">indent</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">emit-nl</span><span class="w"> </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">indent</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">buffer/push </span><span class="nv">buf</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">current-column</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">emit-word</span><span class="w"> </span><span class="p">[</span><span class="nv">word</span><span class="w"> </span><span class="nv">indent</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">len</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">last-byte</span><span class="w"> </span><span class="p">(</span><span class="nb">last </span><span class="nv">buf</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nv">and</span>
<span class="w">            </span><span class="nv">last-byte</span>
<span class="w">            </span><span class="p">(</span><span class="nb">not= </span><span class="nv">last-byte</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;\n&quot;</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">not= </span><span class="nv">last-byte</span><span class="w"> </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot; &quot;</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">buffer/push </span><span class="nv">buf</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">++ </span><span class="nv">current-column</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">default </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">word</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">and </span><span class="nv">indent</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">+ </span><span class="mf">1</span><span class="w"> </span><span class="nv">current-column</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="nv">max-width</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">emit-nl</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">emit-indent</span><span class="w"> </span><span class="nv">indent</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">buffer/push </span><span class="nv">buf</span><span class="w"> </span><span class="nv">word</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+= </span><span class="nv">current-column</span><span class="w"> </span><span class="nv">len</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">emit-code</span>
<span class="w">    </span><span class="p">[</span><span class="nv">code</span><span class="w"> </span><span class="nv">indent</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">replacement</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">string/repeat </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="mf">4</span><span class="w"> </span><span class="nv">indent</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">emit-indent</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="mf">4</span><span class="w"> </span><span class="nv">indent</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">buffer/push </span><span class="nv">buf</span><span class="w"> </span><span class="p">(</span><span class="nb">string/replace-all </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="nv">replacement</span><span class="w"> </span><span class="nv">code</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">chr </span><span class="s">&quot;\n&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">last </span><span class="nv">code</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">current-column</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">emit-nl</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">emit-node</span>
<span class="w">    </span><span class="p">[</span><span class="nv">el</span><span class="w"> </span><span class="nv">indent</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nv">emit-indent</span><span class="w"> </span><span class="nv">indent</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">tuple? </span><span class="nv">el</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">rep</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">string/repeat </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="nv">indent</span><span class="p">))]</span>
<span class="w">        </span><span class="p">(</span><span class="nb">each </span><span class="p">[</span><span class="nv">word</span><span class="w"> </span><span class="nv">len</span><span class="p">]</span><span class="w"> </span><span class="nv">el</span>
<span class="w">          </span><span class="p">(</span><span class="nv">emit-word</span>
<span class="w">            </span><span class="p">(</span><span class="nb">string/replace-all </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="nv">rep</span><span class="w"> </span><span class="nv">word</span><span class="p">)</span>
<span class="w">            </span><span class="nv">indent</span>
<span class="w">            </span><span class="nv">len</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">emit-nl</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">case </span><span class="p">(</span><span class="nb">first </span><span class="nv">el</span><span class="p">)</span>
<span class="w">        </span><span class="no">:ul</span><span class="w"> </span><span class="p">(</span><span class="nb">for </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">el</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">emit-indent</span><span class="w"> </span><span class="nv">indent</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nv">emit-word</span><span class="w"> </span><span class="s">&quot;* &quot;</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">each </span><span class="nv">subel</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">el</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">emit-node</span><span class="w"> </span><span class="nv">subel</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="mf">2</span><span class="w"> </span><span class="nv">indent</span><span class="p">))))</span>
<span class="w">        </span><span class="no">:ol</span><span class="w"> </span><span class="p">(</span><span class="nb">for </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">el</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">emit-indent</span><span class="w"> </span><span class="nv">indent</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="k">def </span><span class="nv">lab</span><span class="w"> </span><span class="p">(</span><span class="nb">string/format </span><span class="s">&quot;%d. &quot;</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nv">emit-word</span><span class="w"> </span><span class="nv">lab</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">each </span><span class="nv">subel</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">el</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">emit-node</span><span class="w"> </span><span class="nv">subel</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">length </span><span class="nv">lab</span><span class="p">)</span><span class="w"> </span><span class="nv">indent</span><span class="p">))))</span>
<span class="w">        </span><span class="no">:cb</span><span class="w"> </span><span class="p">(</span><span class="nv">emit-code</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">el</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nv">indent</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">el</span><span class="w"> </span><span class="nv">stack</span>
<span class="w">    </span><span class="p">(</span><span class="nv">emit-nl</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">emit-node</span><span class="w"> </span><span class="nv">el</span><span class="w"> </span><span class="nv">indent</span><span class="p">))</span>

<span class="w">  </span><span class="nv">buf</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">print-index</span>
<span class="w">  </span><span class="s">&quot;Print bindings in the current environment given a filter function.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">fltr</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">bindings</span><span class="w"> </span><span class="p">(</span><span class="nb">filter </span><span class="nv">fltr</span><span class="w"> </span><span class="p">(</span><span class="nv">all-bindings</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">dynamics</span><span class="w"> </span><span class="p">(</span><span class="nb">map describe </span><span class="p">(</span><span class="nb">filter </span><span class="nv">fltr</span><span class="w"> </span><span class="p">(</span><span class="nv">all-dynamics</span><span class="p">))))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">print</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">doc-format </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;Bindings:\n\n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">string/join </span><span class="nv">bindings</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">))</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="kc">false</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">print</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">doc-format </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;Dynamics:\n\n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">string/join </span><span class="nv">dynamics</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">))</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="kc">false</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;\n    Use (doc sym) for more information on a binding.\n&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">print-module-entry</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">bind-type</span>
<span class="w">    </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;    &quot;</span>
<span class="w">            </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">              </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="no">:redef</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="p">(</span><span class="nb">in </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="no">:ref</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="no">:ref</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="no">:var</span><span class="w"> </span><span class="s">&quot; (&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">type </span><span class="p">(</span><span class="nb">in </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="no">:ref</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="no">:macro</span><span class="p">)</span><span class="w"> </span><span class="no">:macro</span>
<span class="w">              </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="no">:module</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="no">:module</span><span class="w"> </span><span class="s">&quot; (&quot;</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="no">:kind</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">type </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="no">:value</span><span class="p">)))</span>
<span class="w">            </span><span class="s">&quot;\n&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">sm</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="no">:source-map</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">d</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="w"> </span><span class="no">:doc</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;\n\n&quot;</span>
<span class="w">         </span><span class="nv">bind-type</span>
<span class="w">         </span><span class="p">(</span><span class="nb">when-let </span><span class="p">[[</span><span class="nv">path</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="nv">col</span><span class="p">]</span><span class="w"> </span><span class="nv">sm</span><span class="p">]</span>
<span class="w">           </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;    &quot;</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">and </span><span class="nv">line</span><span class="w"> </span><span class="nv">col</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot; on line &quot;</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="s">&quot;, column &quot;</span><span class="w"> </span><span class="nv">col</span><span class="p">))))</span>
<span class="w">         </span><span class="p">(</span><span class="nb">when </span><span class="nv">sm</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">if </span><span class="nv">d</span><span class="w"> </span><span class="p">(</span><span class="nb">doc-format </span><span class="nv">d</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;\n    no documentation found.\n&quot;</span><span class="p">)</span>
<span class="w">         </span><span class="s">&quot;\n&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">print-special-form-entry</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;\n\n&quot;</span>
<span class="w">         </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;    special form\n\n&quot;</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;    (&quot;</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="s">&quot; ...)\n\n&quot;</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;    See https://janet-lang.org/docs/specials.html\n\n&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">doc*</span>
<span class="w">  </span><span class="s">&quot;Get the documentation for a symbol in a given environment. Function form of `doc`.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">sym</span><span class="p">]</span>

<span class="w">  </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">    </span><span class="p">(</span><span class="nb">string? </span><span class="nv">sym</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">print-index</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">string/find </span><span class="nv">sym</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>

<span class="w">    </span><span class="nv">sym</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">sym</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">x</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">index-of </span><span class="nv">sym</span><span class="w"> </span><span class="o">&#39;</span><span class="p">[</span><span class="k">break def do fn if quasiquote </span><span class="nv">quote</span>
<span class="w">                            </span><span class="k">set splice unquote upscope var </span><span class="nv">while</span><span class="p">])</span>
<span class="w">          </span><span class="p">(</span><span class="nv">print-special-form-entry</span><span class="w"> </span><span class="nv">sym</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nv">do</span>
<span class="w">            </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">fullpath</span><span class="w"> </span><span class="nv">mod-kind</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">module/find </span><span class="p">(</span><span class="nb">string </span><span class="nv">sym</span><span class="p">)))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">mod-env</span><span class="w"> </span><span class="p">(</span><span class="nb">in module/cache </span><span class="nv">fullpath</span><span class="p">)]</span>
<span class="w">              </span><span class="p">(</span><span class="nv">print-module-entry</span><span class="w"> </span><span class="p">{</span><span class="no">:module</span><span class="w"> </span><span class="kc">true</span>
<span class="w">                                   </span><span class="no">:kind</span><span class="w"> </span><span class="nv">mod-kind</span>
<span class="w">                                   </span><span class="no">:source-map</span><span class="w"> </span><span class="p">[</span><span class="nv">fullpath</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="kc">nil</span><span class="p">]</span>
<span class="w">                                   </span><span class="no">:doc</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">mod-env</span><span class="w"> </span><span class="no">:doc</span><span class="p">)})</span>
<span class="w">              </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;symbol &quot;</span><span class="w"> </span><span class="nv">sym</span><span class="w"> </span><span class="s">&quot; not found.&quot;</span><span class="p">))))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">print-module-entry</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>

<span class="w">    </span><span class="c1"># else</span>
<span class="w">    </span><span class="p">(</span><span class="nv">print-index</span><span class="w"> </span><span class="nv">identity</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">doc</span>
<span class="w">  </span><span class="s">``Shows documentation for the given symbol, or can show a list of available bindings.</span>
<span class="s">  If `sym` is a symbol, will look for documentation for that symbol. If `sym` is a string</span>
<span class="s">  or is not provided, will show all lexical and dynamic bindings in the current environment</span>
<span class="s">  containing that string (all bindings will be shown if no string is given).``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">sym</span><span class="p">]</span>
<span class="w">  </span><span class="o">~</span><span class="p">(</span><span class="o">,</span><span class="nb">doc* </span><span class="o">&#39;,</span><span class="nv">sym</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">doc-of</span>
<span class="w">  </span><span class="s">`Searches all loaded modules in module/cache for a given binding and prints out its documentation.</span>
<span class="s">  This does a search by value instead of by name. Returns nil.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">found</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">module-set</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="p">[[</span><span class="nv">root-env</span><span class="p">]</span><span class="w"> </span><span class="nv">module/cache</span><span class="p">]</span>
<span class="w">         </span><span class="nv">module</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">module-set</span>
<span class="w">         </span><span class="nv">value</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="nv">module</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">check</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">get </span><span class="nv">value</span><span class="w"> </span><span class="no">:ref</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">value</span><span class="w"> </span><span class="no">:value</span><span class="p">))]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="nv">check</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nv">print-module-entry</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="nv">found</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nv">break</span><span class="p">))))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">if-not </span><span class="nv">found</span>
<span class="w">    </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;documentation for value &quot;</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="s">&quot; not found.&quot;</span><span class="p">)))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Debugger</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.fiber</span>
<span class="w">  </span><span class="s">&quot;Get the current fiber being debugged.&quot;</span>
<span class="w">  </span><span class="p">[]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">dyn </span><span class="no">:fiber</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.signal</span>
<span class="w">  </span><span class="s">&quot;Get the current signal being debugged.&quot;</span>
<span class="w">  </span><span class="p">[]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">dyn </span><span class="no">:signal</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.stack</span>
<span class="w">  </span><span class="s">&quot;Print the current fiber stack.&quot;</span>
<span class="w">  </span><span class="p">[]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">print</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-dyns </span><span class="p">[</span><span class="nv">*err-color*</span><span class="w"> </span><span class="kc">false</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">debug/stacktrace </span><span class="p">(</span><span class="nv">.fiber</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">.signal</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nv">print</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.frame</span>
<span class="w">  </span><span class="s">&quot;Show a stack frame&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">stack</span><span class="w"> </span><span class="p">(</span><span class="nb">debug/stack </span><span class="p">(</span><span class="nv">.fiber</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">in </span><span class="nv">stack</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">n</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.locals</span>
<span class="w">  </span><span class="s">&quot;Show local bindings&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nv">.frame</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="no">:locals</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.fn</span>
<span class="w">  </span><span class="s">&quot;Get the current function.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">in </span><span class="p">(</span><span class="nv">.frame</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="no">:function</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.slots</span>
<span class="w">  </span><span class="s">&quot;Get an array of slots in a stack frame.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">in </span><span class="p">(</span><span class="nv">.frame</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="no">:slots</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.slot</span>
<span class="w">  </span><span class="s">&quot;Get the value of the nth slot.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">nth</span><span class="w"> </span><span class="nv">frame-idx</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">in </span><span class="p">(</span><span class="nv">.slots</span><span class="w"> </span><span class="nv">frame-idx</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">nth</span><span class="w"> </span><span class="mf">0</span><span class="p">)))</span>

<span class="c1"># Conditional compilation for disasm</span>
<span class="p">(</span><span class="nb">compwhen </span><span class="p">(</span><span class="nb">dyn </span><span class="o">&#39;</span><span class="nv">disasm</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">.disasm</span>
<span class="w">    </span><span class="s">&quot;Gets the assembly for the current function.&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">frame</span><span class="w"> </span><span class="p">(</span><span class="nv">.frame</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">func</span><span class="w"> </span><span class="p">(</span><span class="nv">frame</span><span class="w"> </span><span class="no">:function</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">disasm </span><span class="nv">func</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">.bytecode</span>
<span class="w">    </span><span class="s">&quot;Get the bytecode for the current function.&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">    </span><span class="p">((</span><span class="nv">.disasm</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="no">:bytecode</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">.ppasm</span>
<span class="w">    </span><span class="s">&quot;Pretty prints the assembly for the current function.&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">frame</span><span class="w"> </span><span class="p">(</span><span class="nv">.frame</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">func</span><span class="w"> </span><span class="p">(</span><span class="nv">frame</span><span class="w"> </span><span class="no">:function</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">dasm</span><span class="w"> </span><span class="p">(</span><span class="nb">disasm </span><span class="nv">func</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">bytecode</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">dasm</span><span class="w"> </span><span class="no">:bytecode</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">pc</span><span class="w"> </span><span class="p">(</span><span class="nv">frame</span><span class="w"> </span><span class="no">:pc</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">sourcemap</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">dasm</span><span class="w"> </span><span class="no">:sourcemap</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">last-loc</span><span class="w"> </span><span class="p">[</span><span class="mf">-2</span><span class="w"> </span><span class="mf">-2</span><span class="p">])</span>
<span class="w">    </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;\n  signal:     &quot;</span><span class="w"> </span><span class="p">(</span><span class="nv">.signal</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;  status:     &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">fiber/status </span><span class="p">(</span><span class="nv">.fiber</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;  function:   &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">dasm</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="s">&quot;&lt;anonymous&gt;&quot;</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; [&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">dasm</span><span class="w"> </span><span class="no">:source</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">constants</span><span class="w"> </span><span class="p">(</span><span class="nv">dasm</span><span class="w"> </span><span class="no">:constants</span><span class="p">)]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eprintf </span><span class="s">&quot;  constants:  %.4q&quot;</span><span class="w"> </span><span class="nv">constants</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">eprintf </span><span class="s">&quot;  slots:      %.4q\n&quot;</span><span class="w"> </span><span class="p">(</span><span class="nv">frame</span><span class="w"> </span><span class="no">:slots</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">src-path</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">dasm</span><span class="w"> </span><span class="no">:source</span><span class="p">)]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nv">fexists</span><span class="w"> </span><span class="nv">src-path</span><span class="p">)</span>
<span class="w">                 </span><span class="nv">sourcemap</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">defn </span><span class="nv">dump</span>
<span class="w">          </span><span class="p">[</span><span class="nv">src</span><span class="w"> </span><span class="nv">cur</span><span class="p">]</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="nv">offset</span><span class="w"> </span><span class="mf">5</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="nv">beg</span><span class="w"> </span><span class="p">(</span><span class="nb">max </span><span class="mf">1</span><span class="w"> </span><span class="p">(</span><span class="nb">- </span><span class="nv">cur</span><span class="w"> </span><span class="nv">offset</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="nv">lines</span><span class="w"> </span><span class="p">(</span><span class="nb">array/concat </span><span class="p">@[</span><span class="s">&quot;&quot;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">string/split </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="nv">src</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="nv">end</span><span class="w"> </span><span class="p">(</span><span class="nb">min </span><span class="p">(</span><span class="nb">+ </span><span class="nv">cur</span><span class="w"> </span><span class="nv">offset</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">lines</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="nv">digits</span><span class="w"> </span><span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">math/floor </span><span class="p">(</span><span class="nb">math/log10 </span><span class="nv">end</span><span class="p">))))</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="nv">fmt-str</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;%&quot;</span><span class="w"> </span><span class="nv">digits</span><span class="w"> </span><span class="s">&quot;d: %s&quot;</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">for </span><span class="nv">i</span><span class="w"> </span><span class="nv">beg</span><span class="w"> </span><span class="nv">end</span>
<span class="w">            </span><span class="p">(</span><span class="nb">eprin </span><span class="s">&quot; &quot;</span><span class="p">)</span><span class="w"> </span><span class="c1"># breakpoint someday?</span>
<span class="w">            </span><span class="p">(</span><span class="nb">eprin </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">i</span><span class="w"> </span><span class="nv">cur</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;&gt; &quot;</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">eprintf </span><span class="nv">fmt-str</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">lines</span><span class="w"> </span><span class="nv">i</span><span class="p">))))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">let </span><span class="p">[[</span><span class="nv">sl</span><span class="w"> </span><span class="nv">_</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">sourcemap</span><span class="w"> </span><span class="nv">pc</span><span class="p">)]</span>
<span class="w">          </span><span class="p">(</span><span class="nv">dump</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp </span><span class="nv">src-path</span><span class="p">)</span><span class="w"> </span><span class="nv">sl</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nv">eprint</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">padding</span><span class="w"> </span><span class="p">(</span><span class="nb">string/repeat </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="mf">20</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="no">:range</span><span class="w"> </span><span class="p">[</span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">bytecode</span><span class="p">)]</span>
<span class="w">           </span><span class="no">:let</span><span class="w"> </span><span class="p">[</span><span class="nv">instr</span><span class="w"> </span><span class="p">(</span><span class="nv">bytecode</span><span class="w"> </span><span class="nv">i</span><span class="p">)]]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eprin </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">tuple/type </span><span class="nv">instr</span><span class="p">)</span><span class="w"> </span><span class="no">:brackets</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;*&quot;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eprin </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">i</span><span class="w"> </span><span class="nv">pc</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;&gt; &quot;</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eprinf </span><span class="s">&quot;%.20s&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="p">(</span><span class="nb">string/join </span><span class="p">(</span><span class="nb">map string </span><span class="nv">instr</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">padding</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">when </span><span class="nv">sourcemap</span>
<span class="w">        </span><span class="p">(</span><span class="nb">let </span><span class="p">[[</span><span class="nv">sl</span><span class="w"> </span><span class="nv">sc</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">sourcemap</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span>
<span class="w">              </span><span class="nv">loc</span><span class="w"> </span><span class="p">[</span><span class="nv">sl</span><span class="w"> </span><span class="nv">sc</span><span class="p">]]</span>
<span class="w">          </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">not= </span><span class="nv">loc</span><span class="w"> </span><span class="nv">last-loc</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="k">set </span><span class="nv">last-loc</span><span class="w"> </span><span class="nv">loc</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">eprin </span><span class="s">&quot; # line &quot;</span><span class="w"> </span><span class="nv">sl</span><span class="w"> </span><span class="s">&quot;, column &quot;</span><span class="w"> </span><span class="nv">sc</span><span class="p">))))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">eprint</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">eprint</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">.breakall</span>
<span class="w">    </span><span class="s">&quot;Set breakpoints on all instructions in the current function.&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">fun</span><span class="w"> </span><span class="p">(</span><span class="nv">.fn</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">bytecode</span><span class="w"> </span><span class="p">(</span><span class="nv">.bytecode</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">bytecode</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">debug/fbreak </span><span class="nv">fun</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;set &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">bytecode</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; breakpoints in &quot;</span><span class="w"> </span><span class="nv">fun</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">.clearall</span>
<span class="w">    </span><span class="s">&quot;Clear all breakpoints on the current function.&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">fun</span><span class="w"> </span><span class="p">(</span><span class="nv">.fn</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">bytecode</span><span class="w"> </span><span class="p">(</span><span class="nv">.bytecode</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">bytecode</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">debug/unfbreak </span><span class="nv">fun</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;cleared &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">bytecode</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; breakpoints in &quot;</span><span class="w"> </span><span class="nv">fun</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.source</span>
<span class="w">  </span><span class="s">&quot;Show the source code for the function being debugged.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">frame</span><span class="w"> </span><span class="p">(</span><span class="nv">.frame</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nv">frame</span><span class="w"> </span><span class="no">:source</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">all-source</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp </span><span class="nv">s</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="nv">all-source</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.break</span>
<span class="w">  </span><span class="s">&quot;Set breakpoint at the current pc.&quot;</span>
<span class="w">  </span><span class="p">[]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">frame</span><span class="w"> </span><span class="p">(</span><span class="nv">.frame</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">fun</span><span class="w"> </span><span class="p">(</span><span class="nv">frame</span><span class="w"> </span><span class="no">:function</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">pc</span><span class="w"> </span><span class="p">(</span><span class="nv">frame</span><span class="w"> </span><span class="no">:pc</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">debug/fbreak </span><span class="nv">fun</span><span class="w"> </span><span class="nv">pc</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;set breakpoint in &quot;</span><span class="w"> </span><span class="nv">fun</span><span class="w"> </span><span class="s">&quot; at pc=&quot;</span><span class="w"> </span><span class="nv">pc</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.clear</span>
<span class="w">  </span><span class="s">&quot;Clear the current breakpoint.&quot;</span>
<span class="w">  </span><span class="p">[]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">frame</span><span class="w"> </span><span class="p">(</span><span class="nv">.frame</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">fun</span><span class="w"> </span><span class="p">(</span><span class="nv">frame</span><span class="w"> </span><span class="no">:function</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">pc</span><span class="w"> </span><span class="p">(</span><span class="nv">frame</span><span class="w"> </span><span class="no">:pc</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">debug/unfbreak </span><span class="nv">fun</span><span class="w"> </span><span class="nv">pc</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">eprint </span><span class="s">&quot;cleared breakpoint in &quot;</span><span class="w"> </span><span class="nv">fun</span><span class="w"> </span><span class="s">&quot; at pc=&quot;</span><span class="w"> </span><span class="nv">pc</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.next</span>
<span class="w">  </span><span class="s">&quot;Go to the next breakpoint.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">n</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">resume </span><span class="p">(</span><span class="nv">.fiber</span><span class="p">))))</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.nextc</span>
<span class="w">  </span><span class="s">&quot;Go to the next breakpoint, clearing the current breakpoint.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">.clear</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">.next</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">.step</span>
<span class="w">  </span><span class="s">&quot;Execute the next n instructions.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">n</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">forv </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">n</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">set </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">debug/step </span><span class="p">(</span><span class="nv">.fiber</span><span class="p">))))</span>
<span class="w">  </span><span class="nv">res</span><span class="p">)</span>

<span class="p">(</span><span class="nb">def- </span><span class="nv">debugger-keys</span><span class="w"> </span><span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="nb">partial string/has-prefix? </span><span class="s">&quot;.&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">keys </span><span class="nv">root-env</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">each </span><span class="nv">k</span><span class="w"> </span><span class="nv">debugger-keys</span><span class="w"> </span><span class="p">(</span><span class="nb">put debugger-env </span><span class="nv">k</span><span class="w"> </span><span class="p">(</span><span class="nb">root-env </span><span class="nv">k</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">put root-env </span><span class="nv">k</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### REPL</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">repl</span>
<span class="w">  </span><span class="s">``Run a repl. The first parameter is an optional function to call to</span>
<span class="s">  get a chunk of source code that should return nil for end of file.</span>
<span class="s">  The second parameter is a function that is called when a signal is</span>
<span class="s">  caught. One can provide an optional environment table to run</span>
<span class="s">  the repl in, as well as an optional parser or read function to pass</span>
<span class="s">  to `run-context`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">chunks</span><span class="w"> </span><span class="nv">onsignal</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">parser</span><span class="w"> </span><span class="nv">read</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">env</span><span class="w"> </span><span class="p">(</span><span class="nv">make-env</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">default </span><span class="nv">chunks</span>
<span class="w">    </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">buf</span><span class="w"> </span><span class="nv">p</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="nv">getline</span>
<span class="w">        </span><span class="p">(</span><span class="nv">string</span>
<span class="w">          </span><span class="s">&quot;repl:&quot;</span>
<span class="w">          </span><span class="p">((</span><span class="no">:where</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">          </span><span class="s">&quot;:&quot;</span>
<span class="w">          </span><span class="p">(</span><span class="no">:state</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="no">:delimiters</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;&gt; &quot;</span><span class="p">)</span>
<span class="w">        </span><span class="nv">buf</span><span class="w"> </span><span class="nv">env</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">run-context </span><span class="p">{</span><span class="no">:env</span><span class="w"> </span><span class="nv">env</span>
<span class="w">                </span><span class="no">:chunks</span><span class="w"> </span><span class="nv">chunks</span>
<span class="w">                </span><span class="no">:on-status</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="nv">onsignal</span><span class="w"> </span><span class="p">(</span><span class="nb">debugger-on-status </span><span class="nv">env</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>
<span class="w">                </span><span class="no">:parser</span><span class="w"> </span><span class="nv">parser</span>
<span class="w">                </span><span class="no">:read</span><span class="w"> </span><span class="nv">read</span>
<span class="w">                </span><span class="no">:source</span><span class="w"> </span><span class="no">:repl</span><span class="p">}))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Extras</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">compwhen </span><span class="p">(</span><span class="nb">dyn </span><span class="o">&#39;</span><span class="nv">ev/go</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn net/close </span><span class="s">&quot;Alias for `ev/close`.&quot;</span><span class="w"> </span><span class="p">[</span><span class="nv">stream</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">ev/close </span><span class="nv">stream</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">ev/call</span>
<span class="w">    </span><span class="s">```</span>
<span class="s">    Call a function asynchronously.</span>
<span class="s">    Returns a fiber that is scheduled to run the function.</span>
<span class="s">    ```</span>
<span class="w">    </span><span class="p">[</span><span class="nv">f</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">ev/go </span><span class="p">(</span><span class="k">fn </span><span class="nv">_call</span><span class="w"> </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">f</span><span class="w"> </span><span class="o">;</span><span class="nv">args</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defmacro </span><span class="nv">ev/spawn</span>
<span class="w">    </span><span class="s">&quot;Run some code in a new fiber. This is shorthand for `(ev/go (fn [] ;body))`.&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="o">,</span><span class="nb">ev/go </span><span class="p">(</span><span class="k">fn </span><span class="nv">_spawn</span><span class="w"> </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defmacro </span><span class="nv">ev/do-thread</span>
<span class="w">    </span><span class="s">``Run some code in a new thread. Suspends the current fiber until the thread is complete, and</span>
<span class="s">    evaluates to nil.``</span>
<span class="w">    </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="o">,</span><span class="nb">ev/thread </span><span class="p">(</span><span class="k">fn </span><span class="nv">_do-thread</span><span class="w"> </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defmacro </span><span class="nv">ev/spawn-thread</span>
<span class="w">    </span><span class="s">``Run some code in a new thread. Like `ev/do-thread`, but returns nil immediately.``</span>
<span class="w">    </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">    </span><span class="o">~</span><span class="p">(</span><span class="o">,</span><span class="nb">ev/thread </span><span class="p">(</span><span class="k">fn </span><span class="nv">_spawn-thread</span><span class="w"> </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="o">,;</span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="no">:n</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defmacro </span><span class="nv">ev/with-deadline</span>
<span class="w">    </span><span class="s">`Run a body of code with a deadline, such that if the code does not complete before</span>
<span class="s">    the deadline is up, it will be canceled.`</span>
<span class="w">    </span><span class="p">[</span><span class="nv">deadline</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">f</span><span class="p">]</span>
<span class="w">      </span><span class="o">~</span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="o">,</span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">coro </span><span class="o">,;</span><span class="nv">body</span><span class="p">)]</span>
<span class="w">         </span><span class="p">(</span><span class="o">,</span><span class="nb">ev/deadline </span><span class="o">,</span><span class="nv">deadline</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="o">,</span><span class="nv">f</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="o">,</span><span class="nb">resume </span><span class="o">,</span><span class="nv">f</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn- </span><span class="nv">cancel-all</span><span class="w"> </span><span class="p">[</span><span class="nv">chan</span><span class="w"> </span><span class="nv">fibers</span><span class="w"> </span><span class="nv">reason</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">each </span><span class="nv">f</span><span class="w"> </span><span class="nv">fibers</span><span class="w"> </span><span class="p">(</span><span class="nb">ev/cancel </span><span class="nv">f</span><span class="w"> </span><span class="nv">reason</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">fibers</span><span class="p">)]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">table/clear </span><span class="nv">fibers</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">repeat </span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="nb">ev/take </span><span class="nv">chan</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn- </span><span class="nv">wait-for-fibers</span>
<span class="w">    </span><span class="p">[</span><span class="nv">chan</span><span class="w"> </span><span class="nv">fibers</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">defer </span><span class="p">(</span><span class="nv">cancel-all</span><span class="w"> </span><span class="nv">chan</span><span class="w"> </span><span class="nv">fibers</span><span class="w"> </span><span class="s">&quot;parent canceled&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">length </span><span class="nv">fibers</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">sig</span><span class="w"> </span><span class="nv">fiber</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">ev/take </span><span class="nv">chan</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">sig</span><span class="w"> </span><span class="no">:ok</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">put </span><span class="nv">fibers</span><span class="w"> </span><span class="nv">fiber</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nv">do</span>
<span class="w">            </span><span class="p">(</span><span class="nv">cancel-all</span><span class="w"> </span><span class="nv">chan</span><span class="w"> </span><span class="nv">fibers</span><span class="w"> </span><span class="s">&quot;sibling canceled&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">propagate </span><span class="p">(</span><span class="nb">fiber/last-value </span><span class="nv">fiber</span><span class="p">)</span><span class="w"> </span><span class="nv">fiber</span><span class="p">))))))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defmacro </span><span class="nv">ev/gather</span>
<span class="w">    </span><span class="s">``</span>
<span class="s">    Run a number of fibers in parallel on the event loop, and join when they complete.</span>
<span class="s">    Returns the gathered results in an array.</span>
<span class="s">    ``</span>
<span class="w">    </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">bodies</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">with-syms </span><span class="p">[</span><span class="nv">chan</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="nv">fset</span><span class="w"> </span><span class="nv">ftemp</span><span class="p">]</span>
<span class="w">      </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">         </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">fset</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">         </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">chan</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nv">ev/chan</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="p">@[])</span>
<span class="w">         </span><span class="o">,;</span><span class="p">(</span><span class="nb">seq </span><span class="p">[[</span><span class="nv">i</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span><span class="w"> </span><span class="no">:pairs</span><span class="w"> </span><span class="nv">bodies</span><span class="p">]</span>
<span class="w">             </span><span class="o">~</span><span class="p">(</span><span class="nv">do</span>
<span class="w">                </span><span class="p">(</span><span class="k">def </span><span class="o">,</span><span class="nv">ftemp</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nb">ev/go </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">put </span><span class="o">,</span><span class="nv">res</span><span class="w"> </span><span class="o">,</span><span class="nv">i</span><span class="w"> </span><span class="o">,</span><span class="nv">body</span><span class="p">))</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="o">,</span><span class="nv">chan</span><span class="p">))</span>
<span class="w">                </span><span class="p">(</span><span class="o">,</span><span class="nb">put </span><span class="o">,</span><span class="nv">fset</span><span class="w"> </span><span class="o">,</span><span class="nv">ftemp</span><span class="w"> </span><span class="o">,</span><span class="nv">ftemp</span><span class="p">)))</span>
<span class="w">         </span><span class="p">(</span><span class="o">,</span><span class="nv">wait-for-fibers</span><span class="w"> </span><span class="o">,</span><span class="nv">chan</span><span class="w"> </span><span class="o">,</span><span class="nv">fset</span><span class="p">)</span>
<span class="w">         </span><span class="o">,</span><span class="nv">res</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">compwhen </span><span class="p">(</span><span class="nb">dyn </span><span class="o">&#39;</span><span class="nv">net/listen</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">net/server</span>
<span class="w">    </span><span class="s">&quot;Start a server asynchronously with `net/listen` and `net/accept-loop`. Returns the new server stream.&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="nv">host</span><span class="w"> </span><span class="nv">port</span><span class="w"> </span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">handler</span><span class="w"> </span><span class="nv">type</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nb">net/listen </span><span class="nv">host</span><span class="w"> </span><span class="nv">port</span><span class="w"> </span><span class="nv">type</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="nv">handler</span>
<span class="w">      </span><span class="p">(</span><span class="nb">ev/go </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">net/accept-loop </span><span class="nv">s</span><span class="w"> </span><span class="nv">handler</span><span class="p">))))</span>
<span class="w">    </span><span class="nv">s</span><span class="p">))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### FFI Extra</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defmacro </span><span class="nv">delay</span>
<span class="w">  </span><span class="s">&quot;Lazily evaluate a series of expressions. Returns a function that</span>
<span class="s">  returns the result of the last expression. Will only evaluate the</span>
<span class="s">  body once, and then memoizes the result.&quot;</span>
<span class="w">  </span><span class="p">[</span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">forms</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">state</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">loaded</span><span class="w"> </span><span class="p">(</span><span class="nv">gensym</span><span class="p">))</span>
<span class="w">  </span><span class="o">~</span><span class="p">((</span><span class="k">fn </span><span class="p">[]</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="o">,</span><span class="nv">state</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">var </span><span class="o">,</span><span class="nv">loaded</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">fn </span><span class="p">[]</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="o">,</span><span class="nv">loaded</span>
<span class="w">          </span><span class="o">,</span><span class="nv">state</span>
<span class="w">          </span><span class="p">(</span><span class="nv">do</span>
<span class="w">            </span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">loaded</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="k">set </span><span class="o">,</span><span class="nv">state</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="o">,;</span><span class="nv">forms</span><span class="p">))))))))</span>

<span class="p">(</span><span class="nb">compwhen </span><span class="p">(</span><span class="nb">dyn </span><span class="o">&#39;</span><span class="nv">ffi/native</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defdyn </span><span class="nv">*ffi-context*</span><span class="w"> </span><span class="s">&quot; Current native library for ffi/bind and other settings&quot;</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn- </span><span class="nv">default-mangle</span>
<span class="w">    </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">string/replace-all </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="s">&quot;_&quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">ffi/context</span>
<span class="w">    </span><span class="s">&quot;Set the path of the dynamic library to implictly bind, as well</span>
<span class="s">     as other global state for ease of creating native bindings.&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="nv">&amp;opt</span><span class="w"> </span><span class="nv">native-path</span><span class="w"> </span><span class="nv">&amp;named</span><span class="w"> </span><span class="nv">map-symbols</span><span class="w"> </span><span class="nv">lazy</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">default </span><span class="nv">map-symbols</span><span class="w"> </span><span class="nv">default-mangle</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">lib</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">lazy</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">(</span><span class="nb">ffi/native </span><span class="nv">native-path</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">lazy-lib</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">lazy</span><span class="w"> </span><span class="p">(</span><span class="nb">delay </span><span class="p">(</span><span class="nb">ffi/native </span><span class="nv">native-path</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*ffi-context*</span>
<span class="w">            </span><span class="p">@{</span><span class="no">:native-path</span><span class="w"> </span><span class="nv">native-path</span>
<span class="w">              </span><span class="no">:native</span><span class="w"> </span><span class="nv">lib</span>
<span class="w">              </span><span class="no">:native-lazy</span><span class="w"> </span><span class="nv">lazy-lib</span>
<span class="w">              </span><span class="no">:lazy</span><span class="w"> </span><span class="nv">lazy</span>
<span class="w">              </span><span class="no">:map-symbols</span><span class="w"> </span><span class="nv">map-symbols</span><span class="p">}))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defmacro </span><span class="nv">ffi/defbind</span>
<span class="w">    </span><span class="s">&quot;Generate bindings for native functions in a convenient manner.&quot;</span>
<span class="w">    </span><span class="p">[</span><span class="nv">name</span><span class="w"> </span><span class="nv">ret-type</span><span class="w"> </span><span class="nv">&amp;</span><span class="w"> </span><span class="nv">body</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">real-ret-type</span><span class="w"> </span><span class="p">(</span><span class="nb">eval </span><span class="nv">ret-type</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">meta</span><span class="w"> </span><span class="p">(</span><span class="nb">slice </span><span class="nv">body</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="mf">-2</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">arg-pairs</span><span class="w"> </span><span class="p">(</span><span class="nb">partition </span><span class="mf">2</span><span class="w"> </span><span class="p">(</span><span class="nb">last </span><span class="nv">body</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">formal-args</span><span class="w"> </span><span class="p">(</span><span class="nb">map </span><span class="mf">0</span><span class="w"> </span><span class="nv">arg-pairs</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">type-args</span><span class="w"> </span><span class="p">(</span><span class="nb">map </span><span class="mf">1</span><span class="w"> </span><span class="nv">arg-pairs</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">computed-type-args</span><span class="w"> </span><span class="p">(</span><span class="nb">eval </span><span class="o">~</span><span class="p">[</span><span class="o">,;</span><span class="nv">type-args</span><span class="p">]))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="p">{</span><span class="no">:native</span><span class="w"> </span><span class="nv">lib</span>
<span class="w">          </span><span class="no">:lazy</span><span class="w"> </span><span class="nv">lazy</span>
<span class="w">          </span><span class="no">:native-lazy</span><span class="w"> </span><span class="nv">llib</span>
<span class="w">          </span><span class="no">:map-symbols</span><span class="w"> </span><span class="nv">ms</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*ffi-context*</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;no ffi context found&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">raw-symbol</span><span class="w"> </span><span class="p">(</span><span class="nv">ms</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">defn </span><span class="nv">make-sig</span><span class="w"> </span><span class="p">[]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">ffi/signature </span><span class="no">:default</span><span class="w"> </span><span class="nv">real-ret-type</span><span class="w"> </span><span class="o">;</span><span class="nv">computed-type-args</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">defn </span><span class="nv">make-ptr</span><span class="w"> </span><span class="p">[]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">ffi/lookup </span><span class="p">(</span><span class="k">if </span><span class="nv">lazy</span><span class="w"> </span><span class="p">(</span><span class="nv">llib</span><span class="p">)</span><span class="w"> </span><span class="nv">lib</span><span class="p">)</span><span class="w"> </span><span class="nv">raw-symbol</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;failed to find ffi symbol &quot;</span><span class="w"> </span><span class="nv">raw-symbol</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="nv">lazy</span>
<span class="w">      </span><span class="o">~</span><span class="p">(</span><span class="nb">defn </span><span class="o">,</span><span class="nv">name</span><span class="w"> </span><span class="o">,;</span><span class="nv">meta</span><span class="w"> </span><span class="p">[</span><span class="o">,;</span><span class="nv">formal-args</span><span class="p">]</span>
<span class="w">         </span><span class="p">(</span><span class="o">,</span><span class="nb">ffi/call </span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">delay </span><span class="p">(</span><span class="nv">make-ptr</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">delay </span><span class="p">(</span><span class="nv">make-sig</span><span class="p">)))</span><span class="w"> </span><span class="o">,;</span><span class="nv">formal-args</span><span class="p">))</span>
<span class="w">      </span><span class="o">~</span><span class="p">(</span><span class="nb">defn </span><span class="o">,</span><span class="nv">name</span><span class="w"> </span><span class="o">,;</span><span class="nv">meta</span><span class="w"> </span><span class="p">[</span><span class="o">,;</span><span class="nv">formal-args</span><span class="p">]</span>
<span class="w">         </span><span class="p">(</span><span class="o">,</span><span class="nb">ffi/call </span><span class="o">,</span><span class="p">(</span><span class="nv">make-ptr</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nv">make-sig</span><span class="p">)</span><span class="w"> </span><span class="o">,;</span><span class="nv">formal-args</span><span class="p">)))))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Flychecking</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">no-side-effects</span>
<span class="w">  </span><span class="s">`Check if form may have side effects. If returns true, then the src</span>
<span class="s">  must not have side effects, such as calling a C function.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">src</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">    </span><span class="p">(</span><span class="nb">tuple? </span><span class="nv">src</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">tuple/type </span><span class="nv">src</span><span class="p">)</span><span class="w"> </span><span class="no">:brackets</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">all </span><span class="nv">no-side-effects</span><span class="w"> </span><span class="nv">src</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">array? </span><span class="nv">src</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">all </span><span class="nv">no-side-effects</span><span class="w"> </span><span class="nv">src</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">dictionary? </span><span class="nv">src</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">all </span><span class="nv">no-side-effects</span><span class="w"> </span><span class="p">(</span><span class="nb">keys </span><span class="nv">src</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nb">all </span><span class="nv">no-side-effects</span><span class="w"> </span><span class="p">(</span><span class="nb">values </span><span class="nv">src</span><span class="p">)))</span>
<span class="w">    </span><span class="kc">true</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">is-safe-def</span><span class="w"> </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nv">no-side-effects</span><span class="w"> </span><span class="p">(</span><span class="nb">last </span><span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">def- </span><span class="nv">safe-forms</span><span class="w"> </span><span class="p">{</span><span class="o">&#39;</span><span class="nb">defn </span><span class="kc">true</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">varfn </span><span class="kc">true</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">defn- </span><span class="kc">true</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">defmacro </span><span class="kc">true</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">defmacro- </span><span class="kc">true</span>
<span class="w">                  </span><span class="o">&#39;</span><span class="k">def </span><span class="nv">is-safe-def</span><span class="w"> </span><span class="o">&#39;</span><span class="k">var </span><span class="nv">is-safe-def</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">def- </span><span class="nv">is-safe-def</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">var- </span><span class="nv">is-safe-def</span>
<span class="w">                  </span><span class="o">&#39;</span><span class="nb">defglobal </span><span class="nv">is-safe-def</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">varglobal </span><span class="nv">is-safe-def</span><span class="p">})</span>

<span class="p">(</span><span class="nb">def- </span><span class="nv">importers</span><span class="w"> </span><span class="p">{</span><span class="o">&#39;</span><span class="nb">import </span><span class="kc">true</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">import* </span><span class="kc">true</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">dofile </span><span class="kc">true</span><span class="w"> </span><span class="o">&#39;</span><span class="nb">require </span><span class="kc">true</span><span class="p">})</span>
<span class="p">(</span><span class="nb">defn- </span><span class="nv">use-2</span><span class="w"> </span><span class="p">[</span><span class="nv">evaluator</span><span class="w"> </span><span class="nv">args</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">a</span><span class="w"> </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">import* </span><span class="p">(</span><span class="nb">string </span><span class="nv">a</span><span class="p">)</span><span class="w"> </span><span class="no">:prefix</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="no">:evaluator</span><span class="w"> </span><span class="nv">evaluator</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">flycheck-evaluator</span>
<span class="w">  </span><span class="s">``An evaluator function that is passed to `run-context` that lints (flychecks) code.</span>
<span class="s">  This means code will parsed and compiled, macros executed, but the code will not be run.</span>
<span class="s">  Used by `flycheck`.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">thunk</span><span class="w"> </span><span class="nv">source</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">where</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">tuple? </span><span class="nv">source</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">head</span><span class="w"> </span><span class="p">(</span><span class="nv">source</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">safe-check</span>
<span class="w">      </span><span class="p">(</span><span class="nv">or</span>
<span class="w">        </span><span class="p">(</span><span class="nv">safe-forms</span><span class="w"> </span><span class="nv">head</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">symbol? </span><span class="nv">head</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">string/has-prefix? </span><span class="s">&quot;define-&quot;</span><span class="w"> </span><span class="nv">head</span><span class="p">)</span><span class="w"> </span><span class="nv">is-safe-def</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">cond</span>
<span class="w">      </span><span class="c1"># Sometimes safe form</span>
<span class="w">      </span><span class="p">(</span><span class="nb">function? </span><span class="nv">safe-check</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nv">safe-check</span><span class="w"> </span><span class="nv">source</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">thunk</span><span class="p">))</span>
<span class="w">      </span><span class="c1"># Always safe form</span>
<span class="w">      </span><span class="nv">safe-check</span>
<span class="w">      </span><span class="p">(</span><span class="nv">thunk</span><span class="p">)</span>
<span class="w">      </span><span class="c1"># Use</span>
<span class="w">      </span><span class="p">(</span><span class="nb">= </span><span class="o">&#39;</span><span class="nb">use </span><span class="nv">head</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">use-2</span><span class="w"> </span><span class="nv">flycheck-evaluator</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/slice </span><span class="nv">source</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">      </span><span class="c1"># Import-like form</span>
<span class="w">      </span><span class="p">(</span><span class="nv">importers</span><span class="w"> </span><span class="nv">head</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">let </span><span class="p">[[</span><span class="nv">l</span><span class="w"> </span><span class="nv">c</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/sourcemap </span><span class="nv">source</span><span class="p">)</span>
<span class="w">            </span><span class="nv">newtup</span><span class="w"> </span><span class="p">(</span><span class="nb">tuple/setmap </span><span class="p">(</span><span class="nb">tuple </span><span class="o">;</span><span class="nv">source</span><span class="w"> </span><span class="no">:evaluator</span><span class="w"> </span><span class="nv">flycheck-evaluator</span><span class="p">)</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="nv">c</span><span class="p">)]</span>
<span class="w">        </span><span class="p">((</span><span class="nb">compile </span><span class="nv">newtup</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">where</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">flycheck</span>
<span class="w">  </span><span class="s">``Check a file for errors without running the file. Found errors will be printed to stderr</span>
<span class="s">  in the usual format. Macros will still be executed, however, so</span>
<span class="s">  arbitrary execution is possible. Other arguments are the same as `dofile`. `path` can also be</span>
<span class="s">  a file value such as stdin. Returns nil.``</span>
<span class="w">  </span><span class="p">[</span><span class="nv">path</span><span class="w"> </span><span class="nv">&amp;keys</span><span class="w"> </span><span class="nv">kwargs</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">old-modcache</span><span class="w"> </span><span class="p">(</span><span class="nb">table/clone </span><span class="nv">module/cache</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">table/clear </span><span class="nv">module/cache</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">try</span>
<span class="w">    </span><span class="p">(</span><span class="nb">dofile </span><span class="nv">path</span><span class="w"> </span><span class="no">:evaluator</span><span class="w"> </span><span class="nv">flycheck-evaluator</span><span class="w"> </span><span class="o">;</span><span class="p">(</span><span class="nb">kvs </span><span class="nv">kwargs</span><span class="p">))</span>
<span class="w">    </span><span class="p">([</span><span class="nv">e</span><span class="w"> </span><span class="nv">f</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">debug/stacktrace </span><span class="nv">f</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">table/clear </span><span class="nv">module/cache</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">merge-into module/cache </span><span class="nv">old-modcache</span><span class="p">)</span>
<span class="w">  </span><span class="kc">nil</span><span class="p">)</span>


<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### CLI Tool Main</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="c1"># conditional compilation for reduced os</span>
<span class="p">(</span><span class="nb">def- </span><span class="nv">getenv-alias</span><span class="w"> </span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">entry</span><span class="w"> </span><span class="p">(</span><span class="nb">in root-env </span><span class="o">&#39;</span><span class="nv">os/getenv</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nv">entry</span><span class="w"> </span><span class="no">:value</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">])))</span>

<span class="p">(</span><span class="nb">defn- </span><span class="nv">run-main</span>
<span class="w">  </span><span class="p">[</span><span class="nv">env</span><span class="w"> </span><span class="nv">subargs</span><span class="w"> </span><span class="nv">arg</span><span class="p">]</span>
<span class="w">  </span><span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">entry</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">env</span><span class="w"> </span><span class="o">&#39;</span><span class="nv">main</span><span class="p">)</span>
<span class="w">             </span><span class="nv">main</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">get </span><span class="nv">entry</span><span class="w"> </span><span class="no">:value</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="p">(</span><span class="nb">get </span><span class="nv">entry</span><span class="w"> </span><span class="no">:ref</span><span class="p">)</span><span class="w"> </span><span class="mf">0</span><span class="p">))]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">guard</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">get </span><span class="nv">env</span><span class="w"> </span><span class="no">:debug</span><span class="p">)</span><span class="w"> </span><span class="no">:ydt</span><span class="w"> </span><span class="no">:y</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">defn </span><span class="nv">wrap-main</span><span class="w"> </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span>
<span class="w">      </span><span class="p">(</span><span class="nv">main</span><span class="w"> </span><span class="o">;</span><span class="nv">subargs</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">f</span><span class="w"> </span><span class="p">(</span><span class="nb">fiber/new </span><span class="nv">wrap-main</span><span class="w"> </span><span class="nv">guard</span><span class="w"> </span><span class="nv">env</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">var </span><span class="nv">res</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">fiber/can-resume? </span><span class="nv">f</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">set </span><span class="nv">res</span><span class="w"> </span><span class="p">(</span><span class="nb">resume </span><span class="nv">f</span><span class="w"> </span><span class="nv">res</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">not= </span><span class="no">:dead</span><span class="w"> </span><span class="p">(</span><span class="nb">fiber/status </span><span class="nv">f</span><span class="p">))</span>
<span class="w">        </span><span class="p">((</span><span class="nb">debugger-on-status </span><span class="nv">env</span><span class="p">)</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">res</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*args*</span>
<span class="w">  </span><span class="s">&quot;Dynamic bindings that will contain command line arguments at program start.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*executable*</span>
<span class="w">  </span><span class="s">``Name of the interpreter executable used to execute this program. Corresponds to `argv[0]` in the call to</span>
<span class="s">    `int main(int argc, char **argv);`.``</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defdyn </span><span class="nv">*profilepath*</span>
<span class="w">  </span><span class="s">&quot;Path to profile file loaded when starting up the repl.&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">compwhen </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">dyn </span><span class="o">&#39;</span><span class="nv">os/isatty</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">defmacro os/isatty </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defn </span><span class="nv">cli-main</span>
<span class="w">  </span><span class="s">`Entrance for the Janet CLI tool. Call this function with the command line</span>
<span class="s">  arguments as an array or tuple of strings to invoke the CLI interface.`</span>
<span class="w">  </span><span class="p">[</span><span class="nv">args</span><span class="p">]</span>

<span class="w">  </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*args*</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">should-repl</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">no-file</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">quiet</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">raw-stdin</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">handleopts</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">exit-on-error</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">colorize</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">debug-flag</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">compile-only</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">warn-level</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">error-level</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">expect-image</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">jp</span><span class="w"> </span><span class="p">(</span><span class="nv">getenv-alias</span><span class="w"> </span><span class="s">&quot;JANET_PATH&quot;</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*syspath*</span><span class="w"> </span><span class="nv">jp</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">jprofile</span><span class="w"> </span><span class="p">(</span><span class="nv">getenv-alias</span><span class="w"> </span><span class="s">&quot;JANET_PROFILE&quot;</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*profilepath*</span><span class="w"> </span><span class="nv">jprofile</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">set </span><span class="nv">colorize</span><span class="w"> </span><span class="p">(</span><span class="nv">and</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nv">getenv-alias</span><span class="w"> </span><span class="s">&quot;NO_COLOR&quot;</span><span class="p">))</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">os/isatty </span><span class="nv">stdout</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn- </span><span class="nv">get-lint-level</span>
<span class="w">    </span><span class="p">[</span><span class="nv">i</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">x</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">scan-number </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">keyword </span><span class="nv">x</span><span class="p">)))</span>

<span class="w">  </span><span class="c1"># Flag handlers</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">handlers</span>
<span class="w">    </span><span class="p">{</span><span class="s">&quot;h&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span>
<span class="w">           </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;usage: &quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*executable*</span><span class="w"> </span><span class="s">&quot;janet&quot;</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; [options] script args...&quot;</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nv">print</span>
<span class="w">             </span><span class="s">```</span>
<span class="s">             Options are:</span>
<span class="s">               -h : Show this help</span>
<span class="s">               -v : Print the version string</span>
<span class="s">               -s : Use raw stdin instead of getline like functionality</span>
<span class="s">               -e code : Execute a string of janet</span>
<span class="s">               -E code arguments... : Evaluate an expression as a short-fn with arguments</span>
<span class="s">               -d : Set the debug flag in the REPL</span>
<span class="s">               -r : Enter the REPL after running all scripts</span>
<span class="s">               -R : Disables loading profile.janet when JANET_PROFILE is present</span>
<span class="s">               -p : Keep on executing if there is a top-level error (persistent)</span>
<span class="s">               -q : Hide logo (quiet)</span>
<span class="s">               -k : Compile scripts but do not execute (flycheck)</span>
<span class="s">               -m syspath : Set system path for loading global modules</span>
<span class="s">               -c source output : Compile janet source code into an image</span>
<span class="s">               -i : Load the script argument as an image file instead of source code</span>
<span class="s">               -n : Disable ANSI color output in the REPL</span>
<span class="s">               -N : Enable ANSI color output in the REPL</span>
<span class="s">               -l lib : Use a module before processing more arguments</span>
<span class="s">               -w level : Set the lint warning level - default is &quot;normal&quot;</span>
<span class="s">               -x level : Set the lint error level - default is &quot;none&quot;</span>
<span class="s">               -- : Stop handling options</span>
<span class="s">             ```</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nb">os/exit </span><span class="mf">0</span><span class="p">)</span>
<span class="w">           </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;v&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">print janet/version </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="nv">janet/build</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">os/exit </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;s&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">raw-stdin</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">should-repl</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">should-repl</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;p&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">exit-on-error</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;q&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">quiet</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;i&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">expect-image</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;k&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">compile-only</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">exit-on-error</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;n&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">colorize</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;N&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">colorize</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;m&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*syspath*</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;c&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="nv">c-switch</span><span class="w"> </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span>
<span class="w">           </span><span class="p">(</span><span class="k">def </span><span class="nv">path</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">           </span><span class="p">(</span><span class="k">def </span><span class="nv">e</span><span class="w"> </span><span class="p">(</span><span class="nb">dofile </span><span class="nv">path</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="nb">spit </span><span class="p">(</span><span class="nb">in </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">make-image </span><span class="nv">e</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="k">set </span><span class="nv">no-file</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">           </span><span class="mf">3</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">handleopts</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;l&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="nv">l-switch</span><span class="w"> </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span>
<span class="w">           </span><span class="p">(</span><span class="nb">import* </span><span class="p">(</span><span class="nb">in </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span>
<span class="w">                    </span><span class="no">:prefix</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="no">:exit</span><span class="w"> </span><span class="nv">exit-on-error</span><span class="p">)</span>
<span class="w">           </span><span class="mf">2</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;e&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="nv">e-switch</span><span class="w"> </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span>
<span class="w">           </span><span class="p">(</span><span class="k">set </span><span class="nv">no-file</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nb">eval-string </span><span class="p">(</span><span class="nb">in </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">           </span><span class="mf">2</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;E&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="nv">E-switch</span><span class="w"> </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span>
<span class="w">           </span><span class="p">(</span><span class="k">set </span><span class="nv">no-file</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="k">def </span><span class="nv">subargs</span><span class="w"> </span><span class="p">(</span><span class="nb">array/slice </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">2</span><span class="p">)))</span>
<span class="w">           </span><span class="p">(</span><span class="k">def </span><span class="nv">src</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">short-fn </span><span class="o">,</span><span class="p">(</span><span class="nb">parse </span><span class="p">(</span><span class="nb">in </span><span class="nv">args</span><span class="w"> </span><span class="p">(</span><span class="nb">+ </span><span class="nv">i</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span><span class="w"> </span><span class="nv">E-expression</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="k">def </span><span class="nv">thunk</span><span class="w"> </span><span class="p">(</span><span class="nb">compile </span><span class="nv">src</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">function? </span><span class="nv">thunk</span><span class="p">)</span>
<span class="w">             </span><span class="p">((</span><span class="nv">thunk</span><span class="p">)</span><span class="w"> </span><span class="o">;</span><span class="nv">subargs</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nb">error </span><span class="p">(</span><span class="nb">get </span><span class="nv">thunk</span><span class="w"> </span><span class="no">:error</span><span class="p">)))</span>
<span class="w">           </span><span class="nv">math/inf</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;d&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">debug-flag</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;w&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">warn-level</span><span class="w"> </span><span class="p">(</span><span class="nv">get-lint-level</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;x&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">i</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">set </span><span class="nv">error-level</span><span class="w"> </span><span class="p">(</span><span class="nv">get-lint-level</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span>
<span class="w">     </span><span class="s">&quot;R&quot;</span><span class="w"> </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*profilepath*</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span><span class="w"> </span><span class="mf">1</span><span class="p">)})</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn- </span><span class="nv">dohandler</span><span class="w"> </span><span class="p">[</span><span class="nv">n</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">&amp;</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">h</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">handlers</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="nv">h</span><span class="w"> </span><span class="p">(</span><span class="nv">h</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;unknown flag -&quot;</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="nb">in </span><span class="nv">handlers</span><span class="w"> </span><span class="s">&quot;h&quot;</span><span class="p">)))))</span>

<span class="w">  </span><span class="c1"># Process arguments</span>
<span class="w">  </span><span class="p">(</span><span class="k">var </span><span class="nv">i</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">lenargs</span><span class="w"> </span><span class="p">(</span><span class="nb">length </span><span class="nv">args</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">while </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">i</span><span class="w"> </span><span class="nv">lenargs</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">arg</span><span class="w"> </span><span class="p">(</span><span class="nb">in </span><span class="nv">args</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">and </span><span class="nv">handleopts</span><span class="w"> </span><span class="p">(</span><span class="nb">= </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">string/slice </span><span class="nv">arg</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">+= </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nv">dohandler</span><span class="w"> </span><span class="p">(</span><span class="nb">string/slice </span><span class="nv">arg</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">subargs</span><span class="w"> </span><span class="p">(</span><span class="nb">array/slice </span><span class="nv">args</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="nv">no-file</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="nv">expect-image</span>
<span class="w">          </span><span class="p">(</span><span class="nv">do</span>
<span class="w">            </span><span class="p">(</span><span class="k">def </span><span class="nv">env</span><span class="w"> </span><span class="p">(</span><span class="nb">load-image </span><span class="p">(</span><span class="nb">slurp </span><span class="nv">arg</span><span class="p">)))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*args*</span><span class="w"> </span><span class="nv">subargs</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*lint-error*</span><span class="w"> </span><span class="nv">error-level</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*lint-warn*</span><span class="w"> </span><span class="nv">warn-level</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">when </span><span class="nv">debug-flag</span>
<span class="w">              </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*debug*</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*redef*</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nv">run-main</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">subargs</span><span class="w"> </span><span class="nv">arg</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nv">do</span>
<span class="w">            </span><span class="p">(</span><span class="k">def </span><span class="nv">env</span><span class="w"> </span><span class="p">(</span><span class="nv">make-env</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*args*</span><span class="w"> </span><span class="nv">subargs</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*lint-error*</span><span class="w"> </span><span class="nv">error-level</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*lint-warn*</span><span class="w"> </span><span class="nv">warn-level</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">when </span><span class="nv">debug-flag</span>
<span class="w">              </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*debug*</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*redef*</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="k">if </span><span class="nv">compile-only</span>
<span class="w">              </span><span class="p">(</span><span class="nb">flycheck </span><span class="nv">arg</span><span class="w"> </span><span class="no">:exit</span><span class="w"> </span><span class="nv">exit-on-error</span><span class="w"> </span><span class="no">:env</span><span class="w"> </span><span class="nv">env</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nv">do</span>
<span class="w">                </span><span class="p">(</span><span class="nb">dofile </span><span class="nv">arg</span><span class="w"> </span><span class="no">:exit</span><span class="w"> </span><span class="nv">exit-on-error</span><span class="w"> </span><span class="no">:env</span><span class="w"> </span><span class="nv">env</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nv">run-main</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">subargs</span><span class="w"> </span><span class="nv">arg</span><span class="p">)))))</span>
<span class="w">        </span><span class="p">(</span><span class="k">set </span><span class="nv">i</span><span class="w"> </span><span class="nv">lenargs</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">or </span><span class="nv">should-repl</span><span class="w"> </span><span class="nv">no-file</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">if</span>
<span class="w">      </span><span class="nv">compile-only</span><span class="w"> </span><span class="p">(</span><span class="nb">flycheck stdin </span><span class="no">:source</span><span class="w"> </span><span class="no">:stdin</span><span class="w"> </span><span class="no">:exit</span><span class="w"> </span><span class="nv">exit-on-error</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nv">do</span>
<span class="w">        </span><span class="p">(</span><span class="nb">if-not </span><span class="nv">quiet</span>
<span class="w">          </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Janet &quot;</span><span class="w"> </span><span class="nb">janet/version </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="nb">janet/build </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="p">(</span><span class="nv">os/which</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="p">(</span><span class="nv">os/arch</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="p">(</span><span class="nv">os/compiler</span><span class="p">)</span><span class="w"> </span><span class="s">&quot; - &#39;(doc)&#39; for help&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nv">flush</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">defn </span><span class="nv">getprompt</span><span class="w"> </span><span class="p">[</span><span class="nv">p</span><span class="p">]</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="p">[</span><span class="nv">line</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">parser/where </span><span class="nv">p</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">string </span><span class="s">&quot;repl:&quot;</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">parser/state </span><span class="nv">p</span><span class="w"> </span><span class="no">:delimiters</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;&gt; &quot;</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">defn </span><span class="nv">getstdin</span><span class="w"> </span><span class="p">[</span><span class="nb">prompt </span><span class="nv">buf</span><span class="w"> </span><span class="nv">_</span><span class="p">]</span>
<span class="w">          </span><span class="p">(</span><span class="nb">file/write stdout </span><span class="nv">prompt</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">file/flush </span><span class="nv">stdout</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">file/read stdin </span><span class="no">:line</span><span class="w"> </span><span class="nv">buf</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">env</span><span class="w"> </span><span class="p">(</span><span class="nv">make-env</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">profile.janet</span><span class="w"> </span><span class="p">(</span><span class="nb">dyn </span><span class="nv">*profilepath*</span><span class="p">)]</span>
<span class="w">          </span><span class="p">(</span><span class="k">def </span><span class="nv">new-env</span><span class="w"> </span><span class="p">(</span><span class="nb">dofile </span><span class="nv">profile.janet</span><span class="w"> </span><span class="no">:exit</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">merge-module </span><span class="nv">env</span><span class="w"> </span><span class="nv">new-env</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="kc">false</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">when </span><span class="nv">debug-flag</span>
<span class="w">          </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*debug*</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">put </span><span class="nv">env</span><span class="w"> </span><span class="nv">*redef*</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">def </span><span class="nv">getter</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">raw-stdin</span><span class="w"> </span><span class="nv">getstdin</span><span class="w"> </span><span class="nv">getline</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">defn </span><span class="nv">getchunk</span><span class="w"> </span><span class="p">[</span><span class="nv">buf</span><span class="w"> </span><span class="nv">p</span><span class="p">]</span>
<span class="w">          </span><span class="p">(</span><span class="nv">getter</span><span class="w"> </span><span class="p">(</span><span class="nv">getprompt</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span><span class="w"> </span><span class="nv">buf</span><span class="w"> </span><span class="nv">env</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*pretty-format*</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">colorize</span><span class="w"> </span><span class="s">&quot;%.20Q&quot;</span><span class="w"> </span><span class="s">&quot;%.20q&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*err-color*</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">colorize</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*doc-color*</span><span class="w"> </span><span class="p">(</span><span class="k">if </span><span class="nv">colorize</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*lint-error*</span><span class="w"> </span><span class="nv">error-level</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">setdyn </span><span class="nv">*lint-warn*</span><span class="w"> </span><span class="nv">error-level</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">repl </span><span class="nv">getchunk</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="nv">env</span><span class="p">)))))</span>

<span class="c1">###</span>
<span class="c1">###</span>
<span class="c1">### Bootstrap</span>
<span class="c1">###</span>
<span class="c1">###</span>

<span class="p">(</span><span class="nv">do</span>

<span class="w">  </span><span class="c1"># Modify root-env to remove private symbols and</span>
<span class="w">  </span><span class="c1"># flatten nested tables.</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[[</span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="p">(</span><span class="nb">pairs </span><span class="nv">root-env</span><span class="p">)</span>
<span class="w">         </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol? </span><span class="nv">k</span><span class="p">)]</span>
<span class="w">    </span><span class="p">(</span><span class="k">def </span><span class="nv">flat</span><span class="w"> </span><span class="p">(</span><span class="nb">table/proto-flatten </span><span class="nv">v</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nv">boot/config</span><span class="w"> </span><span class="no">:no-docstrings</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">put </span><span class="nv">flat</span><span class="w"> </span><span class="no">:doc</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nv">boot/config</span><span class="w"> </span><span class="no">:no-sourcemaps</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">put </span><span class="nv">flat</span><span class="w"> </span><span class="no">:source-map</span><span class="w"> </span><span class="kc">nil</span><span class="p">))</span>
<span class="w">    </span><span class="c1"># Fix directory separators on windows to make image identical between windows and non-windows</span>
<span class="w">    </span><span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">sm</span><span class="w"> </span><span class="p">(</span><span class="nb">get </span><span class="nv">flat</span><span class="w"> </span><span class="no">:source-map</span><span class="p">)]</span>
<span class="w">      </span><span class="p">(</span><span class="nb">put </span><span class="nv">flat</span><span class="w"> </span><span class="no">:source-map</span><span class="w"> </span><span class="p">[(</span><span class="nb">string/replace-all </span><span class="s">&quot;\\&quot;</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="p">(</span><span class="nv">sm</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nv">sm</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">sm</span><span class="w"> </span><span class="mf">2</span><span class="p">)]))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nv">v</span><span class="w"> </span><span class="no">:private</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">put root-env </span><span class="nv">k</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">put root-env </span><span class="nv">k</span><span class="w"> </span><span class="nv">flat</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">put root-env </span><span class="o">&#39;</span><span class="nv">boot/config</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">put root-env </span><span class="o">&#39;</span><span class="nv">boot/args</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>

<span class="w">  </span><span class="c1"># Build dictionary for loading images</span>
<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">load-dict</span><span class="w"> </span><span class="p">(</span><span class="nb">env-lookup </span><span class="nv">root-env</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">pairs </span><span class="nv">load-dict</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">number? </span><span class="nv">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">put </span><span class="nv">load-dict</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="kc">nil</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">merge-into load-image-dict </span><span class="nv">load-dict</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">image</span>
<span class="w">    </span><span class="p">(</span><span class="nb">let </span><span class="p">[</span><span class="nv">env-pairs</span><span class="w"> </span><span class="p">(</span><span class="nb">pairs </span><span class="p">(</span><span class="nb">env-lookup </span><span class="nv">root-env</span><span class="p">))</span>
<span class="w">          </span><span class="nv">essential-pairs</span><span class="w"> </span><span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">cfunction? </span><span class="nv">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">abstract? </span><span class="nv">v</span><span class="p">)))</span><span class="w"> </span><span class="nv">env-pairs</span><span class="p">)</span>
<span class="w">          </span><span class="nv">lookup</span><span class="w"> </span><span class="p">(</span><span class="nb">table </span><span class="o">;</span><span class="p">(</span><span class="nb">mapcat identity </span><span class="nv">essential-pairs</span><span class="p">))</span>
<span class="w">          </span><span class="nv">reverse-lookup</span><span class="w"> </span><span class="p">(</span><span class="nb">invert </span><span class="nv">lookup</span><span class="p">)]</span>
<span class="w">      </span><span class="c1"># Check no duplicate values</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">temp</span><span class="w"> </span><span class="p">@{})</span>
<span class="w">      </span><span class="p">(</span><span class="nb">eachp </span><span class="p">[</span><span class="nv">k</span><span class="w"> </span><span class="nv">v</span><span class="p">]</span><span class="w"> </span><span class="nv">lookup</span>
<span class="w">        </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">in </span><span class="nv">temp</span><span class="w"> </span><span class="nv">v</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">errorf </span><span class="s">&quot;duplicate value: %v&quot;</span><span class="w"> </span><span class="nv">v</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">put </span><span class="nv">temp</span><span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="nv">k</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">marshal root-env </span><span class="nv">reverse-lookup</span><span class="p">)))</span>

<span class="w">  </span><span class="c1"># Create amalgamation</span>

<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">feature-header</span><span class="w"> </span><span class="s">&quot;src/core/features.h&quot;</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">local-headers</span>
<span class="w">    </span><span class="p">[</span><span class="s">&quot;src/core/state.h&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/util.h&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/gc.h&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/vector.h&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/fiber.h&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/regalloc.h&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/compile.h&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/emit.h&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/symcache.h&quot;</span><span class="p">])</span>

<span class="w">  </span><span class="p">(</span><span class="k">def </span><span class="nv">core-sources</span>
<span class="w">    </span><span class="p">[</span><span class="s">&quot;src/core/abstract.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/array.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/asm.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/buffer.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/bytecode.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/capi.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/cfuns.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/compile.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/corelib.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/debug.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/emit.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/ev.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/ffi.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/fiber.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/gc.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/inttypes.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/io.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/marsh.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/math.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/net.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/os.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/parse.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/peg.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/pp.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/regalloc.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/run.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/specials.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/state.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/string.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/strtod.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/struct.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/symcache.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/table.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/tuple.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/util.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/value.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/vector.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/vm.c&quot;</span>
<span class="w">     </span><span class="s">&quot;src/core/wrap.c&quot;</span><span class="p">])</span>

<span class="w">  </span><span class="c1"># Print janet.c to stdout</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;/* Amalgamated build - DO NOT EDIT */&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;/* Generated from janet version &quot;</span><span class="w"> </span><span class="nb">janet/version </span><span class="s">&quot;-&quot;</span><span class="w"> </span><span class="nb">janet/build </span><span class="s">&quot; */&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;#define JANET_BUILD \&quot;&quot;</span><span class="w"> </span><span class="nb">janet/build </span><span class="s">&quot;\&quot;&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">```#define JANET_AMALG```</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">defn </span><span class="nv">do-one-file</span>
<span class="w">    </span><span class="p">[</span><span class="nv">fname</span><span class="p">]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">unless </span><span class="p">(</span><span class="nb">has-value? </span><span class="nv">boot/args</span><span class="w"> </span><span class="s">&quot;image-only&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;\n/* &quot;</span><span class="w"> </span><span class="nv">fname</span><span class="w"> </span><span class="s">&quot; */&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;#line 0 \&quot;&quot;</span><span class="w"> </span><span class="nv">fname</span><span class="w"> </span><span class="s">&quot;\&quot;\n&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">def </span><span class="nv">source</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp </span><span class="nv">fname</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">string/replace-all </span><span class="s">&quot;\r&quot;</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="nv">source</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="nv">do-one-file</span><span class="w"> </span><span class="nv">feature-header</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">```#include &quot;janet.h&quot;```</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">h</span><span class="w"> </span><span class="nv">local-headers</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do-one-file</span><span class="w"> </span><span class="nv">h</span><span class="p">))</span>

<span class="w">  </span><span class="c1"># windows.h should not be included in any of the external or internal headers - only in .c files.</span>
<span class="w">  </span><span class="p">(</span><span class="nv">print</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;/* Windows work around - winsock2 must be included before windows.h, especially in amalgamated build */&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;#if defined(JANET_WINDOWS) &amp;&amp; defined(JANET_NET)&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;#include &lt;winsock2.h&gt;&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;#endif&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nv">print</span><span class="p">)</span>

<span class="w">  </span><span class="p">(</span><span class="nb">each </span><span class="nv">s</span><span class="w"> </span><span class="nv">core-sources</span>
<span class="w">    </span><span class="p">(</span><span class="nv">do-one-file</span><span class="w"> </span><span class="nv">s</span><span class="p">))</span>

<span class="w">  </span><span class="c1"># Create C source file that contains images a uint8_t buffer. This</span>
<span class="w">  </span><span class="c1"># can be compiled and linked statically into the main janet library</span>
<span class="w">  </span><span class="c1"># and example client.</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;static const unsigned char janet_core_image_bytes[] = {&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop </span><span class="p">[</span><span class="nv">line</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="p">(</span><span class="nb">partition </span><span class="mf">16</span><span class="w"> </span><span class="nv">image</span><span class="p">)]</span>
<span class="w">    </span><span class="p">(</span><span class="nb">prin </span><span class="s">&quot;  &quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">each </span><span class="nv">b</span><span class="w"> </span><span class="nv">line</span>
<span class="w">      </span><span class="p">(</span><span class="nb">prinf </span><span class="s">&quot;0x%.2X, &quot;</span><span class="w"> </span><span class="nv">b</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nv">print</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;  0\n};\n&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;const unsigned char *janet_core_image = janet_core_image_bytes;&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;size_t janet_core_image_size = sizeof(janet_core_image_bytes);&quot;</span><span class="p">))</span>
</pre></div>
</body>
</html>
