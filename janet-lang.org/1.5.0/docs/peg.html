
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Parsing Expression Grammars</title>
    <meta name="description" content="Janet is a functional and imperative programming language. It runs on Windows, Linux, macOS, FreeBSD and *nix.">
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" charset="utf-8">
    <link rel="stylesheet" href="../css/docpage.css" type="text/css" media="screen" charset="utf-8">
    <link rel="shortcut icon" href="assets/favicon.ico">

    <!-- Open Graph -->
    <meta property="og:description" content="Janet is a functional and imperative programming language. It runs on Windows, Linux, macOS, FreeBSD and *nix." />
    <meta property="og:title" content="Parsing Expression Grammars" />
    <meta property="og:type" content="website" />
  </head>
  <body>

    <div id="toc-toggle" class="">
      <div class="bar topbar"></div>
      <div class="bar"></div>
      <div class="bar botbar"></div>
    </div>
    <script charset="utf-8">
      function toggleToc() {
        var toggler = document.getElementById('toc-toggle');
        var wrapper = document.querySelector('.toc');
        wrapper.classList.toggle('toc-hidden');
        toggler.classList.toggle('open');
        window.localStorage.setItem('show-toc', toggler.classList.contains('open'));
      }
      function addTocToggle() {
        var el = document.getElementById('toc-toggle');
        if (window.localStorage.getItem('show-toc') === 'true') {
          toggleToc()
        }
        el.addEventListener('click', toggleToc);
      }
      window.addEventListener('DOMContentLoaded', addTocToggle);
    </script>

    

    <div class="twocol">
      <div class="toc toc-hidden">
        <ul>
          <li><span><a href="../index.html">Home</a></span></li><li class="caret"><span><a href="index.html">Documentation</a></span><ul><li><span><a href="syntax.html">Syntax and the Parser</a></span></li><li><span><a href="specials.html">Special Forms</a></span></li><li><span><a href="numbers.html">Numbers and Arithmetic</a></span></li><li><span><a href="bindings.html">Bindings (def and var)</a></span></li><li><span><a href="flow.html">Flow</a></span></li><li><span><a href="functions.html">Functions</a></span></li><li><span><a href="strings.html">Strings, Keywords, and Symbols</a></span></li><li><span><a href="loop.html">Looping</a></span></li><li><span><a href="macros.html">Macros</a></span></li><li><span><a href="destructuring.html">Destructuring</a></span></li><li class="caret"><span><a href="data_structures/index.html">Data Structures</a></span><ul><li><span><a href="data_structures/arrays.html">Arrays</a></span></li><li><span><a href="data_structures/buffers.html">Buffers</a></span></li><li><span><a href="data_structures/tables.html">Tables</a></span></li><li><span><a href="data_structures/structs.html">Structs</a></span></li><li><span><a href="data_structures/tuples.html">Tuples</a></span></li></ul></li><li><span><a href="modules.html">Modules</a></span></li><li class="caret"><span><a href="fibers/index.html">Fibers</a></span><ul><li><span><a href="fibers/dynamic_bindings.html">Dynamic Bindings</a></span></li><li><span><a href="fibers/error_handling.html">Errors</a></span></li></ul></li><li><span><a href="object_oriented.html">Object Oriented Programming</a></span></li><li><span class="selected"><a href="peg.html">Parsing Expression Grammars</a></span></li><li><span><a href="prototypes.html">Prototypes</a></span></li><li><span><a href="abstract_machine.html">The Janet Abstract Machine</a></span></li><li><span><a href="jpm.html">jpm</a></span></li></ul></li><li class="caret"><span><a href="../api/index.html">API</a></span><ul><li><span><a href="../api/array.html">array</a></span></li><li><span><a href="../api/buffer.html">buffer</a></span></li><li><span><a href="../api/debug.html">debug</a></span></li><li><span><a href="../api/fiber.html">fiber</a></span></li><li><span><a href="../api/file.html">file</a></span></li><li><span><a href="../api/int.html">int</a></span></li><li><span><a href="../api/math.html">math</a></span></li><li><span><a href="../api/module.html">module</a></span></li><li><span><a href="../api/os.html">os</a></span></li><li><span><a href="../api/peg.html">peg</a></span></li><li><span><a href="../api/parser.html">parser</a></span></li><li><span><a href="../api/string.html">string</a></span></li><li><span><a href="../api/table.html">table</a></span></li><li><span><a href="../api/tuple.html">tuple</a></span></li><li><span><a href="../api/tarray.html">tarray</a></span></li></ul></li><li class="caret"><span><a href="../capi/index.html">C API</a></span><ul><li><span><a href="../capi/wrapping.html">Wrapping Types</a></span></li><li><span><a href="../capi/embedding.html">Embedding</a></span></li><li><span><a href="../capi/configuration.html">Configuration</a></span></li><li><span><a href="../capi/array.html">Array C API</a></span></li><li><span><a href="../capi/buffer.html">Buffer C API</a></span></li><li><span><a href="../capi/table.html">Table C API</a></span></li><li><span><a href="../capi/fiber.html">Fiber C API</a></span></li><li><span><a href="../capi/memory-model.html">Memory Model</a></span></li><li><span><a href="../capi/writing-c-functions.html">Writing C Functions</a></span></li></ul></li>
        </ul>
      </div>
      <div class="content-wrapper main-content">
        <h4 class="subtitle">Janet 1.5.0-719f7ba Documentation<br>(Other Versions:
          <a href="../../1.4.0/docs/peg.html">1.4.0</a>
          <a href="../../1.3.1/docs/peg.html">1.3.1</a>)</h4>
        <h1 class="subtitle">Parsing Expression Grammars</h1>
        <div class="prevnext-bar">
          <span class="prev"><a href="object_oriented.html"><span class="prevnext-text">Object Oriented Programming</span></a></span>

          <span class="next"><a href="prototypes.html"><span class="prevnext-text">Prototypes</span></a></span>
        </div>
        

<p>A common programming task is recognizing patterns in text, be it
filtering emails from a list or extracting data from a CSV file. Programming
languages and libraries usually offer a number of tools for this, including prebuilt
parsers, simple operations on strings (splitting a string on commas), and regular expressions.
The pre-built or custom-built parser is usually the most robust solution, but can
be very complex to maintain and may not exist for many languages. String functions are not
powerful enough for a large class of languages, and regular expressions can be hard to read
(which characters are escaped?) and under-powered (don't parse HTML with regex!).
</p>
<p>PEGs, or Parsing Expression Grammars, are another formalism for recognizing languages that
are easier to write than a custom parser and more powerful than regular expressions. They also
can produce grammars that are easily understandable and fast. PEGs can also be compiled
to a bytecode format that can be reused. Janet offers the <code class="mendoza-code">peg</code> module for writing and
evaluating PEGs.
</p>
<p>Janet's <code class="mendoza-code">peg</code> module borrows syntax and ideas from both LPeg and REBOL/Red parse module. Janet has
no built in regex module because PEGs offer a superset of regex's functionality.
</p>
<p>Below is a simple example for checking if a string is a valid IP address. Notice how
the grammar is descriptive enough that you can read it even if you don't know the peg
syntax (example is translated from a <a href="https://www.red-lang.org/2013/11/041-introducing-parse.html">RED language blog post</a>).
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">ip-address</span>
 '{<span class="mdzsyn-keyword">:dig</span> (<span class="mdzsyn-coresym">range</span> <span class="mdzsyn-string">"09"</span>)
   <span class="mdzsyn-keyword">:0-4</span> (<span class="mdzsyn-coresym">range</span> <span class="mdzsyn-string">"04"</span>)
   <span class="mdzsyn-keyword">:0-5</span> (<span class="mdzsyn-coresym">range</span> <span class="mdzsyn-string">"05"</span>)
   <span class="mdzsyn-keyword">:byte</span> (<span class="mdzsyn-symbol">choice</span>
           (<span class="mdzsyn-symbol">sequence</span> <span class="mdzsyn-string">"25"</span> <span class="mdzsyn-keyword">:0-5</span>)
           (<span class="mdzsyn-symbol">sequence</span> <span class="mdzsyn-string">"2"</span> <span class="mdzsyn-keyword">:0-4</span> <span class="mdzsyn-keyword">:dig</span>)
           (<span class="mdzsyn-symbol">sequence</span> <span class="mdzsyn-string">"1"</span> <span class="mdzsyn-keyword">:dig</span> <span class="mdzsyn-keyword">:dig</span>)
           (<span class="mdzsyn-symbol">between</span> <span class="mdzsyn-number">1</span> <span class="mdzsyn-number">2</span> <span class="mdzsyn-keyword">:dig</span>))
   <span class="mdzsyn-keyword">:main</span> (<span class="mdzsyn-symbol">sequence</span> <span class="mdzsyn-keyword">:byte</span> <span class="mdzsyn-string">"."</span> <span class="mdzsyn-keyword">:byte</span> <span class="mdzsyn-string">"."</span> <span class="mdzsyn-keyword">:byte</span> <span class="mdzsyn-string">"."</span> <span class="mdzsyn-keyword">:byte</span>)})

(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">ip-address</span> <span class="mdzsyn-string">"0.0.0.0"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">ip-address</span> <span class="mdzsyn-string">"elephant"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">ip-address</span> <span class="mdzsyn-string">"256.0.0.0"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">ip-address</span> <span class="mdzsyn-string">"0.0.0.0more text"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span></code></pre><h2>The API
</h2>
<p>The <code class="mendoza-code">peg</code> module has few functions because the complexity is exposed through the
pattern syntax. Note that there is only one match function, <code class="mendoza-code">peg/match</code>. Variations
on matching, such as parsing or searching, can be implemented inside patterns.
PEGs can also be compiled ahead of time with <code class="mendoza-code">peg/compile</code> if a PEG will be reused
many times.
</p>
<h3><code class="mendoza-code">(peg/match peg text [,start=0] &amp; arguments)</code>
</h3>
<p>Match a peg against some text. Returns an array of captured data if the text
matches, or nil if there is no match. The caller can provide an optional start
index to begin matching the text at, otherwise the PEG starts on the first character
of text. A peg can either a compile PEG object or peg source.
</p>
<h3><code class="mendoza-code">(peg/compile peg)</code>
</h3>
<p>Compiles a peg source data structure into a new PEG. Throws an error if there are problems
with the peg code.
</p>
<h2>Primitive Patterns
</h2>
<p>Larger patterns are built up with primitive patterns, which recognize individual
characters, string literals, or a given number of characters. A character in Janet
is considered a byte, so PEGs will work on any string of bytes. No special meaning is
given to the 0 byte, or the string terminator in many languages.
</p>
<table>
    <tr><th>Pattern Signature</th> <th>What it Matches</th></tr>
    <tr><td>string ("cat")   </td> <td> The literal string. </td></tr>
    <tr><td>integer (3)      </td> <td> Matches a number of characters, and advances that many characters. If negative, matches if not that many characters and does not advance. For example, -1 will match the end of a string </td></tr>
    <tr><td><code class="mendoza-code">(range "az" "AZ")</code> </td> <td> Matches characters in a range and advances 1 character. Multiple ranges can be combined together. </td></tr>
    <tr><td><code class="mendoza-code">(set "abcd")</code>  </td> <td> Match any character in the argument string. Advances 1 character. </td></tr>
</table><p>Primitive patterns are not that useful by themselves, but can be passed to <code class="mendoza-code">peg/match</code> and <code class="mendoza-code">peg/compile</code> like any other pattern.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-string">"hello"</span> <span class="mdzsyn-string">"hello"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-string">"hello"</span> <span class="mdzsyn-string">"hi"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-number">1</span> <span class="mdzsyn-string">"hi"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-number">1</span> <span class="mdzsyn-string">""</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> '(<span class="mdzsyn-coresym">range</span> <span class="mdzsyn-string">"AZ"</span>) <span class="mdzsyn-string">"F"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> '(<span class="mdzsyn-coresym">range</span> <span class="mdzsyn-string">"AZ"</span>) <span class="mdzsyn-string">"-"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> '(<span class="mdzsyn-coresym">set</span> <span class="mdzsyn-string">"AZ"</span>) <span class="mdzsyn-string">"F"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> '(<span class="mdzsyn-coresym">set</span> <span class="mdzsyn-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>) <span class="mdzsyn-string">"F"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span></code></pre><h2>Combining Patterns
</h2>
<p>These primitive patterns can be combined with several combinators to match a wide number of
languages. These combinators
can be thought of as the looping and branching forms in a traditional language
(that is how they are implemented when compiled to bytecode).
</p>
<table>
    <tr><th>Pattern Signature</th> <th>What it matches</th></tr>
    <tr><td><code class="mendoza-code">(choice a b c ...)</code> </td> <td> Tries to match a, then b, and so on. Will succeed on the first successful match, and fails if none of the arguments match the text. </td></tr>
    <tr><td><code class="mendoza-code">(+ a b c ...)</code> </td> <td> Alias for <code class="mendoza-code">(choice a b c ...)</code> </td></tr>
    <tr><td><code class="mendoza-code">(sequence a b c)</code> </td> <td> Tries to match a, b, c and so on in sequence. If any of these arguments fail to match the text, the whole pattern fails. </td></tr>
    <tr><td><code class="mendoza-code">(* a b c ...)</code> </td> <td> Alias for <code class="mendoza-code">(sequence a b c ...)</code> </td></tr>
    <tr><td><code class="mendoza-code">(any x)</code> </td> <td> Matches 0 or more repetitions of x. </td></tr>
    <tr><td><code class="mendoza-code">(some x)</code> </td> <td> Matches 1 or more repetitions of x. </td></tr>
    <tr><td><code class="mendoza-code">(between min max x)</code> </td> <td> Matches between min and max (inclusive) repetitions of x. </td></tr>
    <tr><td><code class="mendoza-code">(at-least n x)</code> </td> <td> Matches at least n repetitions of x. </td></tr>
    <tr><td><code class="mendoza-code">(at-most n x)</code> </td> <td>  Matches at most n repetitions of x. </td></tr>
    <tr><td><code class="mendoza-code">(if cond patt)</code> </td> <td> Tries to match patt only if cond matches as well. cond will not produce any captures. </td></tr>
    <tr><td><code class="mendoza-code">(if-not cond patt)</code> </td> <td> Tries to match only if cond does not match. cond will not produce any captures. </td></tr>
    <tr><td><code class="mendoza-code">(not patt)</code> </td> <td> Matches only if patt does not match. Will not produce captures or advance any characters. </td></tr>
    <tr><td><code class="mendoza-code">(! patt)</code>   </td> <td> Alias for <code class="mendoza-code">(not patt)</code> </td></tr>
    <tr><td><code class="mendoza-code">(look offset patt)</code> </td> <td> Matches only if patt matches at a fixed offset. offset can be any integer. patt will not produce captures and the peg will not advance any characters. </td></tr>
    <tr><td><code class="mendoza-code">(&gt; offset patt)</code> </td> <td> Alias for <code class="mendoza-code">(look offset patt)</code> </td></tr>
    <tr><td><code class="mendoza-code">(opt patt)</code> </td> <td> Alias for <code class="mendoza-code">(between 0 1 patt)</code> </td></tr>
    <tr><td><code class="mendoza-code">(? patt)</code> </td> <td> Alias for <code class="mendoza-code">(between 0 1 patt)</code> </td></tr></table><p>PEGs try to match an input text with a pattern in a greedy manner.
This means that if a rule fails to match, that rule will fail and not try again. The only
backtracking provided in a peg is provided by the <code class="mendoza-code">(choice x y z ...)</code> special, which will
try rules in order until one succeeds, and the whole pattern succeeds. If no sub pattern
succeeds, then the whole pattern fails. Note that this means that the order of <code class="mendoza-code">x y z</code> in choice
DOES matter. If y matches everything that z matches, z will never succeed.
</p>
<h2>Captures
</h2>
<p>So far we have only been concerned with "does this text match this language?". This is useful, but
it is often more useful to extract data from text if it does match a peg. The <code class="mendoza-code">peg</code> module
uses that concept of a capture stack to extract data from text. As the PEG is trying to match
a piece of text, some forms may push Janet values onto the capture stack as a side effect. If the
text matches the main peg language, <code class="mendoza-code">(peg/match)</code> will return the final capture stack as an array.
</p>
<p>Capture specials will only push captures to the capture stack if their child pattern matches the text.
Most captures specials will match the same text as their first argument pattern. Also most specials
that produce captures can take an optional argument <code class="mendoza-code">tag</code> that applies a keyword tag to the capture.
These tagged captures can then be recaptured via the <code class="mendoza-code">(backref tag)</code> special in subsequent matches.
Tagged captures, when combined with the <code class="mendoza-code">(cmt)</code> special, provide a powerful form of look-behind
that can make many grammars simpler.
</p>
<table>
    <tr><th>Pattern Signature</th> <th>What it matches</th></tr>
    <tr><td><code class="mendoza-code">(capture patt ?tag)</code> </td> <td> Captures all of the text in patt if patt matches, If patt contains any captures, then those captures will be pushed to the capture stack before the total text. </td></tr>
    <tr><td><code class="mendoza-code">(&lt;- patt ?tag)</code> </td> <td> Alias for <code class="mendoza-code">(capture patt ?tag)</code> </td></tr>
    <tr><td><code class="mendoza-code">(quote patt ?tag)</code> </td> <td> Another alias for <code class="mendoza-code">(capture patt ?tag)</code>. This allows code like <code class="mendoza-code">'patt</code> to capture a pattern. </td></tr>
    <tr><td><code class="mendoza-code">(group patt ?tag) </code> </td> <td> Captures an array of all of the captures in patt. </td></tr>
    <tr><td><code class="mendoza-code">(replace patt subst ?tag)</code> </td> <td> Replaces the captures produced by patt by applying subst to them. If subst is a table or struct, will push <code class="mendoza-code">(get subst last-capture)</code> to the capture stack after removing the old captures. If a subst is a function, will call subst with the captures of patt as arguments and push the result to the capture stack. Otherwise, will push subst literally to the capture stack. </td></tr>
    <tr><td><code class="mendoza-code">(/ patt subst ?tag)</code> </td> <td> Alias for <code class="mendoza-code">(replace patt subst ?tag)</code> </td></tr>
    <tr><td><code class="mendoza-code">(constant k ?tag)</code> </td> <td> Captures a constant value and advances no characters. </td></tr>
    <tr><td><code class="mendoza-code">(argument n ?tag)</code> </td> <td> Captures the nth extra argument to the match function and does not advance. </td></tr>
    <tr><td><code class="mendoza-code">(position ?tag)</code> </td> <td> Captures the current index into the text and advances no input. </td></tr>
    <tr><td><code class="mendoza-code">($ ?tag)</code> </td> <td> Alias for <code class="mendoza-code">(position ?tag)</code>. </td></tr>
    <tr><td><code class="mendoza-code">(accumulate patt ?tag)</code> </td> <td> Capture a string that is the concatenation of all captures in patt. This will try to be efficient and not create intermediate strings if possible. </td></tr>
    <tr><td><code class="mendoza-code">(% patt ?tag)</code> </td> <td> Alias for <code class="mendoza-code">(accumulate patt ?tag)</code> </td></tr>
    <tr><td><code class="mendoza-code">(cmt patt fun ?tag)</code> </td> <td> Invokes fun with all of the captures of patt as arguments (if patt matches). If the result is truthy, then captures the result. The whole expression fails if fun returns false or nil. </td></tr>
    <tr><td><code class="mendoza-code">(backref tag ?tag)</code> </td> <td> Duplicates the last capture with the tag <code class="mendoza-code">tag</code>. If no such capture exists then the match fails. </td></tr>
    <tr><td><code class="mendoza-code">(-&gt; tag ?tag)</code> </td> <td> Alias for <code class="mendoza-code">(backref tag)</code>. </td></tr>
    <tr><td><code class="mendoza-code">(error patt)</code> </td> <td> Throws a Janet error if patt matches. The error thrown will be the last capture of patt, or a generic error if patt produces no captures. </td></tr>
    <tr><td><code class="mendoza-code">(drop patt)</code> </td> <td> Ignores (drops) all captures from patt. </td></tr></table><h2>Grammars and Recursion
</h2>
<p>The feature that makes PEGs so much more powerful than pattern matching solutions like (vanilla) regex is mutual recursion.
To do recursion in a peg, you can wrap multiple patterns in a grammar, which is a Janet struct. The patterns must be named by
keywords, which can then be used in all sub-patterns in the grammar.
</p>
<p>Each grammar, defined by a struct, must also have a main rule, called :main, that is the pattern that the entire grammar
is defined by.
</p>
<p>An example grammar that uses mutual recursion:
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">my-grammar</span>
 '{<span class="mdzsyn-keyword">:a</span> (<span class="mdzsyn-coresym">*</span> <span class="mdzsyn-string">"a"</span> <span class="mdzsyn-keyword">:b</span> <span class="mdzsyn-string">"a"</span>)
   <span class="mdzsyn-keyword">:b</span> (<span class="mdzsyn-coresym">*</span> <span class="mdzsyn-string">"b"</span> (<span class="mdzsyn-coresym">+</span> <span class="mdzsyn-keyword">:a</span> <span class="mdzsyn-number">0</span>) <span class="mdzsyn-string">"b"</span>)
   <span class="mdzsyn-keyword">:main</span> (<span class="mdzsyn-coresym">*</span> <span class="mdzsyn-string">"("</span> <span class="mdzsyn-keyword">:b</span> <span class="mdzsyn-string">")"</span>)})

(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">my-grammar</span> <span class="mdzsyn-string">"(bb)"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">my-grammar</span> <span class="mdzsyn-string">"(babbab)"</span>) <span class="mdzsyn-comment"># -&gt; @[]</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">my-grammar</span> <span class="mdzsyn-string">"(baab)"</span>) <span class="mdzsyn-comment"># -&gt; nil</span>
(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">my-grammar</span> <span class="mdzsyn-string">"(babaabab)"</span>) <span class="mdzsyn-comment"># -&gt; nil</span></code></pre><p>Keep in mind that recursion is implemented with a stack, meaning that very recursive grammars
can overflow the stack. The compiler is able to turn some recursion into iteration via tail call optimization, but some patterns
may fail on large inputs. It is also possible to construct (very poorly written) patterns that will result in long loops and be very
slow in general.
</p>
<h2>String Searching and other Idioms
</h2>
<p>Although all pattern matching is done in anchored mode, operations like global substitution
and searching can be implemented with the peg module. A simple Janet function that produces PEGs
that search for strings shows how captures and looping specials can composed, and how quasiquoting
can be used to embed values in patterns.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">defn</span> <span class="mdzsyn-symbol">finder</span>
 <span class="mdzsyn-string">"Creates a peg that finds all locations of str in the text."</span>
 [<span class="mdzsyn-symbol">str</span>]
 (<span class="mdzsyn-coresym">peg/compile</span> ~(<span class="mdzsyn-symbol">any</span> (<span class="mdzsyn-coresym">+</span> (<span class="mdzsyn-coresym">*</span> (<span class="mdzsyn-symbol">$</span>) ,<span class="mdzsyn-symbol">str</span>) <span class="mdzsyn-number">1</span>))))

(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">where-are-the-dogs?</span> (<span class="mdzsyn-symbol">finder</span> <span class="mdzsyn-string">"dog"</span>))

(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">where-are-the-dogs?</span> <span class="mdzsyn-string">"dog dog cat dog"</span>) <span class="mdzsyn-comment"># -&gt; @[0 4 12]</span>

<span class="mdzsyn-comment"># Our finder function also works any pattern, not just strings.</span>

(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">find-cats</span> (<span class="mdzsyn-symbol">finder</span> '(<span class="mdzsyn-coresym">*</span> <span class="mdzsyn-string">"c"</span> (<span class="mdzsyn-coresym">some</span> <span class="mdzsyn-string">"a"</span>) <span class="mdzsyn-string">"t"</span>)))

(<span class="mdzsyn-coresym">peg/match</span> <span class="mdzsyn-symbol">find-cats</span> <span class="mdzsyn-string">"cat ct caat caaaaat cat"</span>) <span class="mdzsyn-comment"># -&gt; @[0 7 12 20]</span></code></pre><p>We can also wrap a peg to turn it into a global substituion grammar with
the accumulate special <code class="mendoza-code">(%)</code>.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">defn</span> <span class="mdzsyn-symbol">replacer</span>
 <span class="mdzsyn-string">"Creates a peg that replaces instances of patt with subst."</span>
 [<span class="mdzsyn-symbol">patt</span> <span class="mdzsyn-symbol">subst</span>]
 (<span class="mdzsyn-coresym">peg/compile</span> ~(<span class="mdzsyn-coresym">%</span> (<span class="mdzsyn-symbol">any</span> (<span class="mdzsyn-coresym">+</span> (<span class="mdzsyn-coresym">/</span> (<span class="mdzsyn-symbol">&lt;-</span> ,<span class="mdzsyn-symbol">patt</span>) ,<span class="mdzsyn-symbol">subst</span>) (<span class="mdzsyn-symbol">&lt;-</span> <span class="mdzsyn-number">1</span>))))))</code></pre>
        <div class="prevnext-bar">
          <span class="prev"><a href="object_oriented.html"><span class="prevnext-text">Object Oriented Programming</span></a></span>
          <span class="next"><a href="prototypes.html"><span class="prevnext-text">Prototypes</span></a></span>
        </div>
      </div>
    </div>

    
<footer>
  &copy; Calvin Rose 2019
  <div class="gentag">Generated on November 10, 2019 at 17:38:46 with Janet 1.5.0-719f7ba</div>
  <div class="see-problem">See a problem? Source
    <a href="https://github.com/janet-lang/janet-lang.org">on GitHub</a></div>
</footer>



  </body>
</html>
