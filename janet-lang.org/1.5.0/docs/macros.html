
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Macros</title>
    <meta name="description" content="Janet is a functional and imperative programming language. It runs on Windows, Linux, macOS, FreeBSD and *nix.">
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" charset="utf-8">
    <link rel="stylesheet" href="../css/docpage.css" type="text/css" media="screen" charset="utf-8">
    <link rel="shortcut icon" href="assets/favicon.ico">

    <!-- Open Graph -->
    <meta property="og:description" content="Janet is a functional and imperative programming language. It runs on Windows, Linux, macOS, FreeBSD and *nix." />
    <meta property="og:title" content="Macros" />
    <meta property="og:type" content="website" />
  </head>
  <body>

    <div id="toc-toggle" class="">
      <div class="bar topbar"></div>
      <div class="bar"></div>
      <div class="bar botbar"></div>
    </div>
    <script charset="utf-8">
      function toggleToc() {
        var toggler = document.getElementById('toc-toggle');
        var wrapper = document.querySelector('.toc');
        wrapper.classList.toggle('toc-hidden');
        toggler.classList.toggle('open');
        window.localStorage.setItem('show-toc', toggler.classList.contains('open'));
      }
      function addTocToggle() {
        var el = document.getElementById('toc-toggle');
        if (window.localStorage.getItem('show-toc') === 'true') {
          toggleToc()
        }
        el.addEventListener('click', toggleToc);
      }
      window.addEventListener('DOMContentLoaded', addTocToggle);
    </script>

    

    <div class="twocol">
      <div class="toc toc-hidden">
        <ul>
          <li><span><a href="../index.html">Home</a></span></li><li class="caret"><span><a href="index.html">Documentation</a></span><ul><li><span><a href="syntax.html">Syntax and the Parser</a></span></li><li><span><a href="specials.html">Special Forms</a></span></li><li><span><a href="numbers.html">Numbers and Arithmetic</a></span></li><li><span><a href="bindings.html">Bindings (def and var)</a></span></li><li><span><a href="flow.html">Flow</a></span></li><li><span><a href="functions.html">Functions</a></span></li><li><span><a href="strings.html">Strings, Keywords, and Symbols</a></span></li><li><span><a href="loop.html">Looping</a></span></li><li><span class="selected"><a href="macros.html">Macros</a></span></li><li><span><a href="destructuring.html">Destructuring</a></span></li><li class="caret"><span><a href="data_structures/index.html">Data Structures</a></span><ul><li><span><a href="data_structures/arrays.html">Arrays</a></span></li><li><span><a href="data_structures/buffers.html">Buffers</a></span></li><li><span><a href="data_structures/tables.html">Tables</a></span></li><li><span><a href="data_structures/structs.html">Structs</a></span></li><li><span><a href="data_structures/tuples.html">Tuples</a></span></li></ul></li><li><span><a href="modules.html">Modules</a></span></li><li class="caret"><span><a href="fibers/index.html">Fibers</a></span><ul><li><span><a href="fibers/dynamic_bindings.html">Dynamic Bindings</a></span></li><li><span><a href="fibers/error_handling.html">Errors</a></span></li></ul></li><li><span><a href="object_oriented.html">Object Oriented Programming</a></span></li><li><span><a href="peg.html">Parsing Expression Grammars</a></span></li><li><span><a href="prototypes.html">Prototypes</a></span></li><li><span><a href="abstract_machine.html">The Janet Abstract Machine</a></span></li><li><span><a href="jpm.html">jpm</a></span></li></ul></li><li class="caret"><span><a href="../api/index.html">API</a></span><ul><li><span><a href="../api/array.html">array</a></span></li><li><span><a href="../api/buffer.html">buffer</a></span></li><li><span><a href="../api/debug.html">debug</a></span></li><li><span><a href="../api/fiber.html">fiber</a></span></li><li><span><a href="../api/file.html">file</a></span></li><li><span><a href="../api/int.html">int</a></span></li><li><span><a href="../api/math.html">math</a></span></li><li><span><a href="../api/module.html">module</a></span></li><li><span><a href="../api/os.html">os</a></span></li><li><span><a href="../api/peg.html">peg</a></span></li><li><span><a href="../api/parser.html">parser</a></span></li><li><span><a href="../api/string.html">string</a></span></li><li><span><a href="../api/table.html">table</a></span></li><li><span><a href="../api/tuple.html">tuple</a></span></li><li><span><a href="../api/tarray.html">tarray</a></span></li></ul></li><li class="caret"><span><a href="../capi/index.html">C API</a></span><ul><li><span><a href="../capi/wrapping.html">Wrapping Types</a></span></li><li><span><a href="../capi/embedding.html">Embedding</a></span></li><li><span><a href="../capi/configuration.html">Configuration</a></span></li><li><span><a href="../capi/array.html">Array C API</a></span></li><li><span><a href="../capi/buffer.html">Buffer C API</a></span></li><li><span><a href="../capi/table.html">Table C API</a></span></li><li><span><a href="../capi/fiber.html">Fiber C API</a></span></li><li><span><a href="../capi/memory-model.html">Memory Model</a></span></li><li><span><a href="../capi/writing-c-functions.html">Writing C Functions</a></span></li></ul></li>
        </ul>
      </div>
      <div class="content-wrapper main-content">
        <h4 class="subtitle">Janet 1.5.0-719f7ba Documentation<br>(Other Versions:
          <a href="../../1.4.0/docs/macros.html">1.4.0</a>
          <a href="../../1.3.1/docs/macros.html">1.3.1</a>)</h4>
        <h1 class="subtitle">Macros</h1>
        <div class="prevnext-bar">
          <span class="prev"><a href="loop.html"><span class="prevnext-text">Looping</span></a></span>

          <span class="next"><a href="destructuring.html"><span class="prevnext-text">Destructuring</span></a></span>
        </div>
        

<p>Janet supports macros like most lisps. A macro is like a function, but transforms
the code itself rather than data. They let you extend the syntax of the language itself.
</p>
<p>You have seen some macros already. The <code class="mendoza-code">let</code>, <code class="mendoza-code">loop</code>, and <code class="mendoza-code">defn</code> forms are macros. When the compiler
sees a macro, it evaluates the macro and then compiles the result. We say the macro has been
<strong>expanded</strong> after the compiler evaluates it. A simple version of the <code class="mendoza-code">defn</code> macro can
be thought of as transforming code of the form
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-symbol">defn1</span> <span class="mdzsyn-symbol">myfun</span> [<span class="mdzsyn-symbol">x</span>] <span class="mdzsyn-symbol">body</span>)</code></pre><p>into
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">myfun</span> (<span class="mdzsyn-coresym">fn</span> <span class="mdzsyn-symbol">myfun</span> [<span class="mdzsyn-symbol">x</span>] <span class="mdzsyn-symbol">body</span>))</code></pre><p>We could write such a macro like so:
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">defmacro</span> <span class="mdzsyn-symbol">defn1</span> [<span class="mdzsyn-symbol">name</span> <span class="mdzsyn-symbol">args</span> <span class="mdzsyn-symbol">body</span>]
 (<span class="mdzsyn-coresym">tuple</span> '<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">name</span> (<span class="mdzsyn-coresym">tuple</span> '<span class="mdzsyn-coresym">fn</span> <span class="mdzsyn-symbol">name</span> <span class="mdzsyn-symbol">args</span> <span class="mdzsyn-symbol">body</span>)))</code></pre><p>There are a couple of issues with this macro, but it will work for simple functions
quite well.
</p>
<p>The first issue is that our defn2 macro can't define functions with multiple expressions
in the body. We can make the macro variadic, just like a function. Here is a second version
of this macro.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">defmacro</span> <span class="mdzsyn-symbol">defn2</span> [<span class="mdzsyn-symbol">name</span> <span class="mdzsyn-symbol">args</span> <span class="mdzsyn-symbol">&amp;</span> <span class="mdzsyn-symbol">body</span>]
 (<span class="mdzsyn-coresym">tuple</span> '<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">name</span> (<span class="mdzsyn-coresym">apply</span> <span class="mdzsyn-coresym">tuple</span> '<span class="mdzsyn-coresym">fn</span> <span class="mdzsyn-symbol">name</span> <span class="mdzsyn-symbol">args</span> <span class="mdzsyn-symbol">body</span>)))</code></pre><p>Great! Now we can define functions with multiple elements in the body. We can still improve this
macro even more though. First, we can add a docstring to it. If someone is using the function later,
they can use <code class="mendoza-code">(doc defn3)</code> to get a description of the function. Next, we can rewrite the macro
using janet's builtin quasiquoting facilities.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">defmacro</span> <span class="mdzsyn-symbol">defn3</span>
 <span class="mdzsyn-string">"Defines a new function."</span>
 [<span class="mdzsyn-symbol">name</span> <span class="mdzsyn-symbol">args</span> <span class="mdzsyn-symbol">&amp;</span> <span class="mdzsyn-symbol">body</span>]
 ~(<span class="mdzsyn-coresym">def</span> ,<span class="mdzsyn-symbol">name</span> (<span class="mdzsyn-coresym">fn</span> ,<span class="mdzsyn-symbol">name</span> ,<span class="mdzsyn-symbol">args</span> ,;<span class="mdzsyn-symbol">body</span>)))</code></pre><p>This is functionally identical to our previous version <code class="mendoza-code">defn2</code>, but written in such
a way that the macro output is more clear. The leading tilde <code class="mendoza-code">~</code> is shorthand for the
<code class="mendoza-code">(quasiquote x)</code> special form, which is like <code class="mendoza-code">(quote x)</code> except we can unquote
expressions inside it. The comma in front of <code class="mendoza-code">name</code> and <code class="mendoza-code">args</code> is an unquote, which
allows us to put a value in the quasiquote. Without the unquote, the symbol 'name\'
would be put in the returned tuple, and every function we defined
would be called 'name\'!.
</p>
<p>Similar to name, we must also unquote body. However, a normal unquote doesn't work.
See what happens if we use a normal unquote for body as well.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">name</span> '<span class="mdzsyn-symbol">myfunction</span>)
(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">args</span> '[<span class="mdzsyn-symbol">x</span> <span class="mdzsyn-symbol">y</span> <span class="mdzsyn-symbol">z</span>])
(<span class="mdzsyn-coresym">defn</span> <span class="mdzsyn-symbol">body</span> '[(<span class="mdzsyn-coresym">print</span> <span class="mdzsyn-symbol">x</span>) (<span class="mdzsyn-coresym">print</span> <span class="mdzsyn-symbol">y</span>) (<span class="mdzsyn-coresym">print</span> <span class="mdzsyn-symbol">z</span>)])

~(<span class="mdzsyn-coresym">def</span> ,<span class="mdzsyn-symbol">name</span> (<span class="mdzsyn-coresym">fn</span> ,<span class="mdzsyn-symbol">name</span> ,<span class="mdzsyn-symbol">args</span> ,<span class="mdzsyn-symbol">body</span>))
<span class="mdzsyn-comment"># -&gt; (def myfunction (fn myfunction (x y z) ((print x) (print y) (print z))))</span></code></pre><p>There is an extra set of parentheses around the body of our function! We don't
want to put the body <strong>inside</strong> the form <code class="mendoza-code">(fn args ...)</code>, we want to <strong>splice</strong> it
into the form. Luckily, janet has the <code class="mendoza-code">(splice x)</code> special form for this purpose,
and a shorthand for it, the ; character.
When combined with the unquote special, we get the desired output.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">~(<span class="mdzsyn-coresym">def</span> ,<span class="mdzsyn-symbol">name</span> (<span class="mdzsyn-coresym">fn</span> ,<span class="mdzsyn-symbol">name</span> ,<span class="mdzsyn-symbol">args</span> ,;<span class="mdzsyn-symbol">body</span>))
<span class="mdzsyn-comment"># -&gt; (def myfunction (fn myfunction (x y z) (print x) (print y) (print z)))</span></code></pre><h2>Hygiene
</h2>
<p>Sometime when we write macros, we must generate symbols for local bindings. Ignoring that
it could be written as a function, consider
the following macro
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">defmacro</span> <span class="mdzsyn-symbol">max1</span>
 <span class="mdzsyn-string">"Get the max of two values."</span>
 [<span class="mdzsyn-symbol">x</span> <span class="mdzsyn-symbol">y</span>]
 ~(<span class="mdzsyn-coresym">if</span> (<span class="mdzsyn-coresym">&gt;</span> ,<span class="mdzsyn-symbol">x</span> ,<span class="mdzsyn-symbol">y</span>) ,<span class="mdzsyn-symbol">x</span> ,<span class="mdzsyn-symbol">y</span>))</code></pre><p>This almost works, but will evaluate both x and y twice. This is because both show up
in the macro twice. For example, <code class="mendoza-code">(max1 (do (print 1) 1) (do (print 2) 2))</code> will
print both 1 and 2 twice, which is surprising to a user of this macro.
</p>
<p>We can do better:
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">defmacro</span> <span class="mdzsyn-symbol">max2</span>
 <span class="mdzsyn-string">"Get the max of two values."</span>
 [<span class="mdzsyn-symbol">x</span> <span class="mdzsyn-symbol">y</span>]
 ~(<span class="mdzsyn-coresym">let</span> [<span class="mdzsyn-symbol">x</span> ,<span class="mdzsyn-symbol">x</span>
        <span class="mdzsyn-symbol">y</span> ,<span class="mdzsyn-symbol">y</span>]
    (<span class="mdzsyn-coresym">if</span> (<span class="mdzsyn-coresym">&gt;</span> <span class="mdzsyn-symbol">x</span> <span class="mdzsyn-symbol">y</span>) <span class="mdzsyn-symbol">x</span> <span class="mdzsyn-symbol">y</span>)))</code></pre><p>Now we have no double evaluation problem! But we now have an even more subtle problem.
What happens in the following code?
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">x</span> <span class="mdzsyn-number">10</span>)
(<span class="mdzsyn-symbol">max2</span> <span class="mdzsyn-number">8</span> (<span class="mdzsyn-coresym">+</span> <span class="mdzsyn-symbol">x</span> <span class="mdzsyn-number">4</span>))</code></pre><p>We want the max to be 14, but this will actually evaluate to 12! This can be understood
if we expand the macro. You can expand a macro once in janet using the <code class="mendoza-code">(macex1 x)</code> function.
(To expand macros until there are no macros left to expand, use <code class="mendoza-code">(macex x)</code>. Be careful,
 janet has many macros, so the full expansion may be almost unreadable).
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">macex1</span> '(<span class="mdzsyn-symbol">max2</span> <span class="mdzsyn-number">8</span> (<span class="mdzsyn-coresym">+</span> <span class="mdzsyn-symbol">x</span> <span class="mdzsyn-number">4</span>)))
<span class="mdzsyn-comment"># -&gt; (let (x 8 y (+ x 4)) (if (&gt; x y) x y))</span></code></pre><p>After expansion, y wrongly refers to the x inside the macro (which is bound to 8) rather than the x defined
to be 10. The problem is the reuse of the symbol x inside the macro, which overshadowed the original
binding. This problem is called the <a href="https://en.wikipedia.org/wiki/Hygienic_macro#The_hygiene_problem">hygiene problem</a> which is well known in many programming languages. Some languages provide
complicated solutions to this problem, but Janet opts for a much simpler, if not primitive solution.
</p>
<p>Janet provides a general solution to this problem in terms of the <code class="mendoza-code">(gensym)</code> function, which returns
a symbol which is guaranteed to be unique and not collide with any symbols defined previously. We can define
our macro once more for a fully correct macro.
</p>
<pre class="mendoza-codeblock"><code data-language="janet"><span class="mdzsyn-symbol">janet</span>
(<span class="mdzsyn-coresym">defmacro</span> <span class="mdzsyn-symbol">max3</span>
 <span class="mdzsyn-string">"Get the max of two values."</span>
 [<span class="mdzsyn-symbol">x</span> <span class="mdzsyn-symbol">y</span>]
 (<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">$x</span> (<span class="mdzsyn-coresym">gensym</span>))
 (<span class="mdzsyn-coresym">def</span> <span class="mdzsyn-symbol">$y</span> (<span class="mdzsyn-coresym">gensym</span>))
 ~(<span class="mdzsyn-coresym">let</span> [,<span class="mdzsyn-symbol">$x</span> ,<span class="mdzsyn-symbol">x</span>
        ,<span class="mdzsyn-symbol">$y</span> ,<span class="mdzsyn-symbol">y</span>]
    (<span class="mdzsyn-coresym">if</span> (<span class="mdzsyn-coresym">&gt;</span> ,<span class="mdzsyn-symbol">$x</span> ,<span class="mdzsyn-symbol">$y</span>) ,<span class="mdzsyn-symbol">$x</span> ,<span class="mdzsyn-symbol">$y</span>)))</code></pre><p>Since it is quite common to create several gensyms for use inside a macro body, Janet
provides a macro <code class="mendoza-code">with-syms</code> to make this definition a bit terser.
</p>
<pre class="mendoza-codeblock"><code data-language="janet">(<span class="mdzsyn-coresym">defmacro</span> <span class="mdzsyn-symbol">max4</span>
 <span class="mdzsyn-string">"Get the max of two values."</span>
 [<span class="mdzsyn-symbol">x</span> <span class="mdzsyn-symbol">y</span>]
 (<span class="mdzsyn-coresym">with-syms</span> [<span class="mdzsyn-symbol">$x</span> <span class="mdzsyn-symbol">$y</span>]
   ~(<span class="mdzsyn-coresym">let</span> [,<span class="mdzsyn-symbol">$x</span> ,<span class="mdzsyn-symbol">x</span>
          ,<span class="mdzsyn-symbol">$y</span> ,<span class="mdzsyn-symbol">y</span>]
      (<span class="mdzsyn-coresym">if</span> (<span class="mdzsyn-coresym">&gt;</span> ,<span class="mdzsyn-symbol">$x</span> ,<span class="mdzsyn-symbol">$y</span>) ,<span class="mdzsyn-symbol">$x</span> ,<span class="mdzsyn-symbol">$y</span>))))</code></pre><p>As you can see, macros are very powerful but also are prone to subtle bugs. You must remember that
at their core, macros are just functions that output code, and the code that they return must
work in many contexts! Many times a function will suffice and be more useful that a macro, as
functions can be more easily passed around and used as first class values.
</p>
        <div class="prevnext-bar">
          <span class="prev"><a href="loop.html"><span class="prevnext-text">Looping</span></a></span>
          <span class="next"><a href="destructuring.html"><span class="prevnext-text">Destructuring</span></a></span>
        </div>
      </div>
    </div>

    
<footer>
  &copy; Calvin Rose 2019
  <div class="gentag">Generated on November 10, 2019 at 17:38:46 with Janet 1.5.0-719f7ba</div>
  <div class="see-problem">See a problem? Source
    <a href="https://github.com/janet-lang/janet-lang.org">on GitHub</a></div>
</footer>



  </body>
</html>
